/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.83, Date: 19-Mar-2007.
 */
#include "asn1intl.h"
#include "NBAP-IEs.h"
#include "NBAP-Constants.h"

/**************************************************************/
/*                                                            */
/*  CommonPhysicalChannelID                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonPhysicalChannelID (ASN1CTXT* pctxt, CommonPhysicalChannelID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonPhysicalChannelID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonPhysicalChannelID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FDD_S_CCPCH_Offset                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FDD_S_CCPCH_Offset (ASN1CTXT* pctxt, FDD_S_CCPCH_Offset* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_FDD_S_CCPCH_Offset: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(149));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_FDD_S_CCPCH_Offset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_ScramblingCode                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_ScramblingCode (ASN1CTXT* pctxt, DL_ScramblingCode* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_ScramblingCode: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_ScramblingCode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FDD_DL_ChannelisationCodeNumber                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FDD_DL_ChannelisationCodeNumber (ASN1CTXT* pctxt, FDD_DL_ChannelisationCodeNumber* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_FDD_DL_ChannelisationCodeNumber: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(511));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_FDD_DL_ChannelisationCodeNumber: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TFCS_CTFC                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TFCS_CTFC (ASN1CTXT* pctxt, TFCS_CTFC* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_TFCS_CTFC: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* ctfc2bit */
      case 0:
         PU_PUSHNAME (pctxt, "u.ctfc2bit");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.ctfc2bit, OSUINTCONST(0), OSUINTCONST(3));
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* ctfc4bit */
      case 1:
         PU_PUSHNAME (pctxt, "u.ctfc4bit");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.ctfc4bit, OSUINTCONST(0), OSUINTCONST(15));
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* ctfc6bit */
      case 2:
         PU_PUSHNAME (pctxt, "u.ctfc6bit");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.ctfc6bit, OSUINTCONST(0), OSUINTCONST(63));
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* ctfc8bit */
      case 3:
         PU_PUSHNAME (pctxt, "u.ctfc8bit");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.ctfc8bit, OSUINTCONST(0), OSUINTCONST(255));
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* ctfc12bit */
      case 4:
         PU_PUSHNAME (pctxt, "u.ctfc12bit");

         stat = pd_ConsUInt16 (pctxt, &pvalue->u.ctfc12bit, OSUINTCONST(0), OSUINTCONST(4095));
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* ctfc16bit */
      case 5:
         PU_PUSHNAME (pctxt, "u.ctfc16bit");

         stat = pd_ConsUInt16 (pctxt, &pvalue->u.ctfc16bit, OSUINTCONST(0), OSUINTCONST(65535));
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* ctfcmaxbit */
      case 6:
         PU_PUSHNAME (pctxt, "u.ctfcmaxbit");

         stat = pd_ConsUnsigned (pctxt, &pvalue->u.ctfcmaxbit, OSUINTCONST(0), OSUINTCONST(16777215));
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TFCS_CTFC: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BetaCD                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BetaCD (ASN1CTXT* pctxt, BetaCD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_BetaCD: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_BetaCD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatCombination_Beta_signalledGainFactors_gai  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatCombination_Beta_signalledGainFactors_gainFactor_fdd (ASN1CTXT* pctxt, TransportFormatCombination_Beta_signalledGainFactors_gainFactor_fdd* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatCombination_Beta_signalledGainFactors_gainFactor_fdd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode betaC */

   PU_PUSHNAME (pctxt, "betaC");

   stat = asn1PD_BetaCD (pctxt, &pvalue->betaC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode betaD */

   PU_PUSHNAME (pctxt, "betaD");

   stat = asn1PD_BetaCD (pctxt, &pvalue->betaD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatCombination_Beta_signalledGainFactors_gainFactor_fdd: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatCombination_Beta_signalledGainFactors_gai  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatCombination_Beta_signalledGainFactors_gainFactor (ASN1CTXT* pctxt, TransportFormatCombination_Beta_signalledGainFactors_gainFactor* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatCombination_Beta_signalledGainFactors_gainFactor: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* fdd */
         case 0:
            PU_PUSHNAME (pctxt, "u.fdd");

            pvalue->u.fdd = rtMemAllocTypeZ (pctxt, TransportFormatCombination_Beta_signalledGainFactors_gainFactor_fdd);
            if (pvalue->u.fdd == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_TransportFormatCombination_Beta_signalledGainFactors_gainFactor_fdd (pctxt, pvalue->u.fdd);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* tdd */
         case 1:
            PU_PUSHNAME (pctxt, "u.tdd");

            stat = asn1PD_BetaCD (pctxt, &pvalue->u.tdd);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatCombination_Beta_signalledGainFactors_gainFactor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RefTFCNumber                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RefTFCNumber (ASN1CTXT* pctxt, RefTFCNumber* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RefTFCNumber: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(3));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_RefTFCNumber: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatCombination_Beta_signalledGainFactors      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatCombination_Beta_signalledGainFactors (ASN1CTXT* pctxt, TransportFormatCombination_Beta_signalledGainFactors* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatCombination_Beta_signalledGainFactors: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "refTFCNumberPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.refTFCNumberPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode gainFactor */

   PU_PUSHNAME (pctxt, "gainFactor");

   stat = asn1PD_TransportFormatCombination_Beta_signalledGainFactors_gainFactor (pctxt, &pvalue->gainFactor);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode refTFCNumber */

   if (pvalue->m.refTFCNumberPresent) {
      PU_PUSHNAME (pctxt, "refTFCNumber");

      stat = asn1PD_RefTFCNumber (pctxt, &pvalue->refTFCNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatCombination_Beta_signalledGainFactors: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatCombination_Beta                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatCombination_Beta (ASN1CTXT* pctxt, TransportFormatCombination_Beta* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatCombination_Beta: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* signalledGainFactors */
         case 0:
            PU_PUSHNAME (pctxt, "u.signalledGainFactors");

            pvalue->u.signalledGainFactors = rtMemAllocTypeZ (pctxt, TransportFormatCombination_Beta_signalledGainFactors);
            if (pvalue->u.signalledGainFactors == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_TransportFormatCombination_Beta_signalledGainFactors (pctxt, pvalue->u.signalledGainFactors);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* computedGainFactors */
         case 1:
            PU_PUSHNAME (pctxt, "u.computedGainFactors");

            stat = asn1PD_RefTFCNumber (pctxt, &pvalue->u.computedGainFactors);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatCombination_Beta: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TFCS_TFCSList_element                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TFCS_TFCSList_element (ASN1CTXT* pctxt, TFCS_TFCSList_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TFCS_TFCSList_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "tFC_BetaPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tFC_BetaPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cTFC */

   PU_PUSHNAME (pctxt, "cTFC");

   stat = asn1PD_TFCS_CTFC (pctxt, &pvalue->cTFC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFC_Beta */

   if (pvalue->m.tFC_BetaPresent) {
      PU_PUSHNAME (pctxt, "tFC_Beta");

      stat = asn1PD_TransportFormatCombination_Beta (pctxt, &pvalue->tFC_Beta);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TFCS_TFCSList_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TFCS_TFCSList                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TFCS_TFCSList (ASN1CTXT* pctxt, TFCS_TFCSList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1024), 0 };
   int stat = 0;
   TFCS_TFCSList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_TFCS_TFCSList: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TFCS_TFCSList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TFCS_TFCSList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TFCS_TFCSList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TFCS_tFCSvalues                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TFCS_tFCSvalues (ASN1CTXT* pctxt, TFCS_tFCSvalues* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TFCS_tFCSvalues: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* no_Split_in_TFCI */
         case 0:
            PU_PUSHNAME (pctxt, "u.no_Split_in_TFCI");

            pvalue->u.no_Split_in_TFCI = rtMemAllocTypeZ (pctxt, TFCS_TFCSList);
            if (pvalue->u.no_Split_in_TFCI == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_TFCS_TFCSList (pctxt, pvalue->u.no_Split_in_TFCI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* not_Used_split_in_TFCI */
         case 1:
            PU_PUSHNAME (pctxt, "u.not_Used_split_in_TFCI");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TFCS_tFCSvalues: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TFCS                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TFCS (ASN1CTXT* pctxt, TFCS* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TFCS: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode tFCSvalues */

   PU_PUSHNAME (pctxt, "tFCSvalues");

   stat = asn1PD_TFCS_tFCSvalues (pctxt, &pvalue->tFCSvalues);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TFCS: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecondaryCCPCH_SlotFormat                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SecondaryCCPCH_SlotFormat (ASN1CTXT* pctxt, SecondaryCCPCH_SlotFormat* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryCCPCH_SlotFormat: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(17));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryCCPCH_SlotFormat: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TFCI_Presence                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TFCI_Presence (ASN1CTXT* pctxt, TFCI_Presence* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_TFCI_Presence: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = present; break;
      case 1: *pvalue = not_present; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TFCI_Presence: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexingPosition                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MultiplexingPosition (ASN1CTXT* pctxt, MultiplexingPosition* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_MultiplexingPosition: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = fixed; break;
      case 1: *pvalue = flexible; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MultiplexingPosition: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PowerOffset                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PowerOffset (ASN1CTXT* pctxt, PowerOffset* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerOffset: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(24));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerOffset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  STTD_Indicator                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_STTD_Indicator (ASN1CTXT* pctxt, STTD_Indicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_STTD_Indicator: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = active_3; break;
         case 1: *pvalue = inactive_3; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_STTD_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScramblingCodeNumber                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ScramblingCodeNumber (ASN1CTXT* pctxt, ScramblingCodeNumber* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ScramblingCodeNumber: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_ScramblingCodeNumber: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PreambleSignatures                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PreambleSignatures (ASN1CTXT* pctxt, PreambleSignatures* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PreambleSignatures: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PreambleSignatures: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RACH_SlotFormat                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RACH_SlotFormat (ASN1CTXT* pctxt, RACH_SlotFormat* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_SlotFormat: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = v0_2; break;
         case 1: *pvalue = v1_3; break;
         case 2: *pvalue = v2_6; break;
         case 3: *pvalue = v3_1; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_SlotFormat: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RACH_SubChannelNumbers                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RACH_SubChannelNumbers (ASN1CTXT* pctxt, RACH_SubChannelNumbers* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(12), OSUINTCONST(12), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_SubChannelNumbers: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_RACH_SubChannelNumbers: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PunctureLimit                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PunctureLimit (ASN1CTXT* pctxt, PunctureLimit* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PunctureLimit: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PunctureLimit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PreambleThreshold                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PreambleThreshold (ASN1CTXT* pctxt, PreambleThreshold* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PreambleThreshold: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(72));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PreambleThreshold: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AICH_TransmissionTiming                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AICH_TransmissionTiming (ASN1CTXT* pctxt, AICH_TransmissionTiming* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_AICH_TransmissionTiming: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = v0; break;
      case 1: *pvalue = v1; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AICH_TransmissionTiming: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AICH_Power                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AICH_Power (ASN1CTXT* pctxt, AICH_Power* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AICH_Power: start\n");

   stat = pd_ConsInt8 (pctxt, pvalue, OSINTCONST(-22), OSINTCONST(5));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_AICH_Power: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonTransportChannelID                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonTransportChannelID (ASN1CTXT* pctxt, CommonTransportChannelID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannelID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_NrOfTransportBlocks                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatSet_NrOfTransportBlocks (ASN1CTXT* pctxt, TransportFormatSet_NrOfTransportBlocks* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_NrOfTransportBlocks: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(512));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_NrOfTransportBlocks: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_TransportBlockSize                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatSet_TransportBlockSize (ASN1CTXT* pctxt, TransportFormatSet_TransportBlockSize* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_TransportBlockSize: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(5000));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_TransportBlockSize: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_TransmissionTimeIntervalDynamic        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatSet_TransmissionTimeIntervalDynamic (ASN1CTXT* pctxt, TransportFormatSet_TransmissionTimeIntervalDynamic* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_TransmissionTimeIntervalDynamic: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = msec_10; break;
         case 1: *pvalue = msec_20; break;
         case 2: *pvalue = msec_40; break;
         case 3: *pvalue = msec_80; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_TransmissionTimeIntervalDynamic: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransmissionTimeIntervalInformation_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransmissionTimeIntervalInformation_element (ASN1CTXT* pctxt, TransmissionTimeIntervalInformation_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransmissionTimeIntervalInformation_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode transmissionTimeInterval */

   PU_PUSHNAME (pctxt, "transmissionTimeInterval");

   stat = asn1PD_TransportFormatSet_TransmissionTimeIntervalDynamic (pctxt, &pvalue->transmissionTimeInterval);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransmissionTimeIntervalInformation_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransmissionTimeIntervalInformation                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransmissionTimeIntervalInformation (ASN1CTXT* pctxt, TransmissionTimeIntervalInformation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(4), 0 };
   int stat = 0;
   TransmissionTimeIntervalInformation_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransmissionTimeIntervalInformation: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TransmissionTimeIntervalInformation_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TransmissionTimeIntervalInformation_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransmissionTimeIntervalInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_TransportFormatSet_ModeDP                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_TransportFormatSet_ModeDP (ASN1CTXT* pctxt, TDD_TransportFormatSet_ModeDP* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_TransportFormatSet_ModeDP: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "transmissionTimeIntervalInformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transmissionTimeIntervalInformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode transmissionTimeIntervalInformation */

   if (pvalue->m.transmissionTimeIntervalInformationPresent) {
      PU_PUSHNAME (pctxt, "transmissionTimeIntervalInformation");

      stat = asn1PD_TransmissionTimeIntervalInformation (pctxt, &pvalue->transmissionTimeIntervalInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_TransportFormatSet_ModeDP: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_ModeDP                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatSet_ModeDP (ASN1CTXT* pctxt, TransportFormatSet_ModeDP* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_ModeDP: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* tdd */
         case 0:
            PU_PUSHNAME (pctxt, "u.tdd");

            pvalue->u.tdd = rtMemAllocTypeZ (pctxt, TDD_TransportFormatSet_ModeDP);
            if (pvalue->u.tdd == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_TDD_TransportFormatSet_ModeDP (pctxt, pvalue->u.tdd);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* notApplicable */
         case 1:
            PU_PUSHNAME (pctxt, "u.notApplicable");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_ModeDP: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_DynamicPartList_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatSet_DynamicPartList_element (ASN1CTXT* pctxt, TransportFormatSet_DynamicPartList_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_DynamicPartList_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "transportBlockSizePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportBlockSizePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode nrOfTransportBlocks */

   PU_PUSHNAME (pctxt, "nrOfTransportBlocks");

   stat = asn1PD_TransportFormatSet_NrOfTransportBlocks (pctxt, &pvalue->nrOfTransportBlocks);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode transportBlockSize */

   if (pvalue->m.transportBlockSizePresent) {
      PU_PUSHNAME (pctxt, "transportBlockSize");

      stat = asn1PD_TransportFormatSet_TransportBlockSize (pctxt, &pvalue->transportBlockSize);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode mode */

   PU_PUSHNAME (pctxt, "mode");

   stat = asn1PD_TransportFormatSet_ModeDP (pctxt, &pvalue->mode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_DynamicPartList_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_DynamicPartList                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatSet_DynamicPartList (ASN1CTXT* pctxt, TransportFormatSet_DynamicPartList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   TransportFormatSet_DynamicPartList_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_DynamicPartList: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TransportFormatSet_DynamicPartList_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TransportFormatSet_DynamicPartList_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_DynamicPartList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_TransmissionTimeIntervalSemiStatic     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatSet_TransmissionTimeIntervalSemiStatic (ASN1CTXT* pctxt, TransportFormatSet_TransmissionTimeIntervalSemiStatic* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_TransmissionTimeIntervalSemiStatic: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      switch (ui) {
         case 0: *pvalue = msec_5; break;
         default: *pvalue = ui;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = msec_10_1; break;
         case 1: *pvalue = msec_20_1; break;
         case 2: *pvalue = msec_40_1; break;
         case 3: *pvalue = msec_80_1; break;
         case 4: *pvalue = dynamic; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_TransmissionTimeIntervalSemiStatic: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_ChannelCodingType                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatSet_ChannelCodingType (ASN1CTXT* pctxt, TransportFormatSet_ChannelCodingType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_ChannelCodingType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = no_codingTDD; break;
         case 1: *pvalue = convolutional_coding; break;
         case 2: *pvalue = turbo_coding; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_ChannelCodingType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_CodingRate                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatSet_CodingRate (ASN1CTXT* pctxt, TransportFormatSet_CodingRate* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_CodingRate: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = half; break;
         case 1: *pvalue = third; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_CodingRate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_RateMatchingAttribute                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatSet_RateMatchingAttribute (ASN1CTXT* pctxt, TransportFormatSet_RateMatchingAttribute* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_RateMatchingAttribute: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(256));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_RateMatchingAttribute: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_CRC_Size                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatSet_CRC_Size (ASN1CTXT* pctxt, TransportFormatSet_CRC_Size* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_CRC_Size: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = v0_4; break;
         case 1: *pvalue = v8_12; break;
         case 2: *pvalue = v12_2; break;
         case 3: *pvalue = v16_8; break;
         case 4: *pvalue = v24_1; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_CRC_Size: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_SecondInterleavingMode                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatSet_SecondInterleavingMode (ASN1CTXT* pctxt, TransportFormatSet_SecondInterleavingMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_SecondInterleavingMode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = frame_related; break;
         case 1: *pvalue = timeSlot_related; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_SecondInterleavingMode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_ModeSSP                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatSet_ModeSSP (ASN1CTXT* pctxt, TransportFormatSet_ModeSSP* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_ModeSSP: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* tdd */
         case 0:
            PU_PUSHNAME (pctxt, "u.tdd");

            stat = asn1PD_TransportFormatSet_SecondInterleavingMode (pctxt, &pvalue->u.tdd);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* notApplicable */
         case 1:
            PU_PUSHNAME (pctxt, "u.notApplicable");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_ModeSSP: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet_Semi_staticPart                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatSet_Semi_staticPart (ASN1CTXT* pctxt, TransportFormatSet_Semi_staticPart* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_Semi_staticPart: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "codingRatePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.codingRatePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode transmissionTimeInterval */

   PU_PUSHNAME (pctxt, "transmissionTimeInterval");

   stat = asn1PD_TransportFormatSet_TransmissionTimeIntervalSemiStatic (pctxt, &pvalue->transmissionTimeInterval);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode channelCoding */

   PU_PUSHNAME (pctxt, "channelCoding");

   stat = asn1PD_TransportFormatSet_ChannelCodingType (pctxt, &pvalue->channelCoding);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode codingRate */

   if (pvalue->m.codingRatePresent) {
      PU_PUSHNAME (pctxt, "codingRate");

      stat = asn1PD_TransportFormatSet_CodingRate (pctxt, &pvalue->codingRate);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode rateMatchingAttribute */

   PU_PUSHNAME (pctxt, "rateMatchingAttribute");

   stat = asn1PD_TransportFormatSet_RateMatchingAttribute (pctxt, &pvalue->rateMatchingAttribute);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cRC_Size */

   PU_PUSHNAME (pctxt, "cRC_Size");

   stat = asn1PD_TransportFormatSet_CRC_Size (pctxt, &pvalue->cRC_Size);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode mode */

   PU_PUSHNAME (pctxt, "mode");

   stat = asn1PD_TransportFormatSet_ModeSSP (pctxt, &pvalue->mode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet_Semi_staticPart: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportFormatSet                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportFormatSet (ASN1CTXT* pctxt, TransportFormatSet* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dynamicParts */

   PU_PUSHNAME (pctxt, "dynamicParts");

   stat = asn1PD_TransportFormatSet_DynamicPartList (pctxt, &pvalue->dynamicParts);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode semi_staticPart */

   PU_PUSHNAME (pctxt, "semi_staticPart");

   stat = asn1PD_TransportFormatSet_Semi_staticPart (pctxt, &pvalue->semi_staticPart);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportFormatSet: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ToAWS                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ToAWS (ASN1CTXT* pctxt, ToAWS* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ToAWS: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(1279));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_ToAWS: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ToAWE                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ToAWE (ASN1CTXT* pctxt, ToAWE* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ToAWE: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(2559));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_ToAWE: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Power                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Power (ASN1CTXT* pctxt, DL_Power* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Power: start\n");

   stat = pd_ConsInt16 (pctxt, pvalue, OSINTCONST(-350), OSINTCONST(150));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Power: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PICH_Power                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PICH_Power (ASN1CTXT* pctxt, PICH_Power* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_Power: start\n");

   stat = pd_ConsInt8 (pctxt, pvalue, OSINTCONST(-10), OSINTCONST(5));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_Power: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PICH_Mode                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PICH_Mode (ASN1CTXT* pctxt, PICH_Mode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_Mode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = v18_1; break;
         case 1: *pvalue = v36_1; break;
         case 2: *pvalue = v72_1; break;
         case 3: *pvalue = v144_1; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PICH_Mode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MICH_Mode                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MICH_Mode (ASN1CTXT* pctxt, MICH_Mode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MICH_Mode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = v18; break;
         case 1: *pvalue = v36; break;
         case 2: *pvalue = v72; break;
         case 3: *pvalue = v144; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MICH_Mode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CCTrCH_ID                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CCTrCH_ID (ASN1CTXT* pctxt, CCTrCH_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_ID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_CCTrCH_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TFCI_Coding                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TFCI_Coding (ASN1CTXT* pctxt, TFCI_Coding* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TFCI_Coding: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = v4_12; break;
         case 1: *pvalue = v8_11; break;
         case 2: *pvalue = v16_7; break;
         case 3: *pvalue = v32_5; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TFCI_Coding: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_ChannelisationCode                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_ChannelisationCode (ASN1CTXT* pctxt, TDD_ChannelisationCode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_ChannelisationCode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(30));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = chCode1div1; break;
         case 1: *pvalue = chCode2div1; break;
         case 2: *pvalue = chCode2div2; break;
         case 3: *pvalue = chCode4div1; break;
         case 4: *pvalue = chCode4div2; break;
         case 5: *pvalue = chCode4div3; break;
         case 6: *pvalue = chCode4div4; break;
         case 7: *pvalue = chCode8div1; break;
         case 8: *pvalue = chCode8div2; break;
         case 9: *pvalue = chCode8div3; break;
         case 10: *pvalue = chCode8div4; break;
         case 11: *pvalue = chCode8div5; break;
         case 12: *pvalue = chCode8div6; break;
         case 13: *pvalue = chCode8div7; break;
         case 14: *pvalue = chCode8div8; break;
         case 15: *pvalue = chCode16div1; break;
         case 16: *pvalue = chCode16div2; break;
         case 17: *pvalue = chCode16div3; break;
         case 18: *pvalue = chCode16div4; break;
         case 19: *pvalue = chCode16div5; break;
         case 20: *pvalue = chCode16div6; break;
         case 21: *pvalue = chCode16div7; break;
         case 22: *pvalue = chCode16div8; break;
         case 23: *pvalue = chCode16div9; break;
         case 24: *pvalue = chCode16div10; break;
         case 25: *pvalue = chCode16div11; break;
         case 26: *pvalue = chCode16div12; break;
         case 27: *pvalue = chCode16div13; break;
         case 28: *pvalue = chCode16div14; break;
         case 29: *pvalue = chCode16div15; break;
         case 30: *pvalue = chCode16div16; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_ChannelisationCode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeSlot                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TimeSlot (ASN1CTXT* pctxt, TimeSlot* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlot: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(14));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlot: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleConfigurationBurstType1And3                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MidambleConfigurationBurstType1And3 (ASN1CTXT* pctxt, MidambleConfigurationBurstType1And3* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleConfigurationBurstType1And3: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = v4_4; break;
      case 1: *pvalue = v8_3; break;
      case 2: *pvalue = v16_2; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleConfigurationBurstType1And3: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftLong                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MidambleShiftLong (ASN1CTXT* pctxt, MidambleShiftLong* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftLong: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftLong: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftAndBurstType_type1_midambleAllocationMode    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MidambleShiftAndBurstType_type1_midambleAllocationMode (ASN1CTXT* pctxt, MidambleShiftAndBurstType_type1_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftAndBurstType_type1_midambleAllocationMode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* defaultMidamble */
         case 0:
            PU_PUSHNAME (pctxt, "u.defaultMidamble");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         /* commonMidamble */
         case 1:
            PU_PUSHNAME (pctxt, "u.commonMidamble");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         /* ueSpecificMidamble */
         case 2:
            PU_PUSHNAME (pctxt, "u.ueSpecificMidamble");

            stat = asn1PD_MidambleShiftLong (pctxt, &pvalue->u.ueSpecificMidamble);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftAndBurstType_type1_midambleAllocationMode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftAndBurstType_type1                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MidambleShiftAndBurstType_type1 (ASN1CTXT* pctxt, MidambleShiftAndBurstType_type1* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftAndBurstType_type1: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtDListInit (&pvalue->extElem1);

   /* decode midambleConfigurationBurstType1And3 */

   PU_PUSHNAME (pctxt, "midambleConfigurationBurstType1And3");

   stat = asn1PD_MidambleConfigurationBurstType1And3 (pctxt, &pvalue->midambleConfigurationBurstType1And3);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleAllocationMode */

   PU_PUSHNAME (pctxt, "midambleAllocationMode");

   stat = asn1PD_MidambleShiftAndBurstType_type1_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftAndBurstType_type1: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleConfigurationBurstType2                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MidambleConfigurationBurstType2 (ASN1CTXT* pctxt, MidambleConfigurationBurstType2* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleConfigurationBurstType2: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = v3; break;
      case 1: *pvalue = v6_2; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleConfigurationBurstType2: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftShort                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MidambleShiftShort (ASN1CTXT* pctxt, MidambleShiftShort* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftShort: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(5));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftShort: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftAndBurstType_type2_midambleAllocationMode    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MidambleShiftAndBurstType_type2_midambleAllocationMode (ASN1CTXT* pctxt, MidambleShiftAndBurstType_type2_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftAndBurstType_type2_midambleAllocationMode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* defaultMidamble */
         case 0:
            PU_PUSHNAME (pctxt, "u.defaultMidamble");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         /* commonMidamble */
         case 1:
            PU_PUSHNAME (pctxt, "u.commonMidamble");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         /* ueSpecificMidamble */
         case 2:
            PU_PUSHNAME (pctxt, "u.ueSpecificMidamble");

            stat = asn1PD_MidambleShiftShort (pctxt, &pvalue->u.ueSpecificMidamble);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftAndBurstType_type2_midambleAllocationMode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftAndBurstType_type2                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MidambleShiftAndBurstType_type2 (ASN1CTXT* pctxt, MidambleShiftAndBurstType_type2* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftAndBurstType_type2: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtDListInit (&pvalue->extElem1);

   /* decode midambleConfigurationBurstType2 */

   PU_PUSHNAME (pctxt, "midambleConfigurationBurstType2");

   stat = asn1PD_MidambleConfigurationBurstType2 (pctxt, &pvalue->midambleConfigurationBurstType2);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleAllocationMode */

   PU_PUSHNAME (pctxt, "midambleAllocationMode");

   stat = asn1PD_MidambleShiftAndBurstType_type2_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftAndBurstType_type2: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftAndBurstType_type3_midambleAllocationMode    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MidambleShiftAndBurstType_type3_midambleAllocationMode (ASN1CTXT* pctxt, MidambleShiftAndBurstType_type3_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftAndBurstType_type3_midambleAllocationMode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* defaultMidamble */
         case 0:
            PU_PUSHNAME (pctxt, "u.defaultMidamble");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         /* ueSpecificMidamble */
         case 1:
            PU_PUSHNAME (pctxt, "u.ueSpecificMidamble");

            stat = asn1PD_MidambleShiftLong (pctxt, &pvalue->u.ueSpecificMidamble);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftAndBurstType_type3_midambleAllocationMode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftAndBurstType_type3                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MidambleShiftAndBurstType_type3 (ASN1CTXT* pctxt, MidambleShiftAndBurstType_type3* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftAndBurstType_type3: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtDListInit (&pvalue->extElem1);

   /* decode midambleConfigurationBurstType1And3 */

   PU_PUSHNAME (pctxt, "midambleConfigurationBurstType1And3");

   stat = asn1PD_MidambleConfigurationBurstType1And3 (pctxt, &pvalue->midambleConfigurationBurstType1And3);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleAllocationMode */

   PU_PUSHNAME (pctxt, "midambleAllocationMode");

   stat = asn1PD_MidambleShiftAndBurstType_type3_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftAndBurstType_type3: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftAndBurstType                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MidambleShiftAndBurstType (ASN1CTXT* pctxt, MidambleShiftAndBurstType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftAndBurstType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* type1 */
         case 0:
            PU_PUSHNAME (pctxt, "u.type1");

            pvalue->u.type1 = rtMemAllocTypeZ (pctxt, MidambleShiftAndBurstType_type1);
            if (pvalue->u.type1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_MidambleShiftAndBurstType_type1 (pctxt, pvalue->u.type1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* type2 */
         case 1:
            PU_PUSHNAME (pctxt, "u.type2");

            pvalue->u.type2 = rtMemAllocTypeZ (pctxt, MidambleShiftAndBurstType_type2);
            if (pvalue->u.type2 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_MidambleShiftAndBurstType_type2 (pctxt, pvalue->u.type2);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* type3 */
         case 2:
            PU_PUSHNAME (pctxt, "u.type3");

            pvalue->u.type3 = rtMemAllocTypeZ (pctxt, MidambleShiftAndBurstType_type3);
            if (pvalue->u.type3 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_MidambleShiftAndBurstType_type3 (pctxt, pvalue->u.type3);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftAndBurstType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_PhysicalChannelOffset                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_PhysicalChannelOffset (ASN1CTXT* pctxt, TDD_PhysicalChannelOffset* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_PhysicalChannelOffset: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_PhysicalChannelOffset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RepetitionPeriod                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RepetitionPeriod (ASN1CTXT* pctxt, RepetitionPeriod* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RepetitionPeriod: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(6));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = v1_4; break;
         case 1: *pvalue = v2_7; break;
         case 2: *pvalue = v4_10; break;
         case 3: *pvalue = v8_9; break;
         case 4: *pvalue = v16_6; break;
         case 5: *pvalue = v32_4; break;
         case 6: *pvalue = v64_3; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RepetitionPeriod: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RepetitionLength                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RepetitionLength (ASN1CTXT* pctxt, RepetitionLength* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RepetitionLength: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(63));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_RepetitionLength: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PagingIndicatorLength                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PagingIndicatorLength (ASN1CTXT* pctxt, PagingIndicatorLength* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PagingIndicatorLength: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = v2_5; break;
         case 1: *pvalue = v4_9; break;
         case 2: *pvalue = v8_8; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PagingIndicatorLength: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Modulation                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Modulation (ASN1CTXT* pctxt, Modulation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Modulation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = qPSK; break;
         case 1: *pvalue = eightPSK; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Modulation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_ChannelisationCodeLCR                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_ChannelisationCodeLCR (ASN1CTXT* pctxt, TDD_ChannelisationCodeLCR* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_ChannelisationCodeLCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode tDD_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tDD_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tDD_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode modulation */

   PU_PUSHNAME (pctxt, "modulation");

   stat = asn1PD_Modulation (pctxt, &pvalue->modulation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_ChannelisationCodeLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeSlotLCR                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TimeSlotLCR (ASN1CTXT* pctxt, TimeSlotLCR* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotLCR: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(6));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleAllocationMode                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MidambleAllocationMode (ASN1CTXT* pctxt, MidambleAllocationMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleAllocationMode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = defaultMidamble; break;
         case 1: *pvalue = commonMidamble; break;
         case 2: *pvalue = uESpecificMidamble; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleAllocationMode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleConfigurationLCR                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MidambleConfigurationLCR (ASN1CTXT* pctxt, MidambleConfigurationLCR* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleConfigurationLCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = v2_2; break;
         case 1: *pvalue = v4_3; break;
         case 2: *pvalue = v6_1; break;
         case 3: *pvalue = v8_2; break;
         case 4: *pvalue = v10_1; break;
         case 5: *pvalue = v12_1; break;
         case 6: *pvalue = v14; break;
         case 7: *pvalue = v16_1; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleConfigurationLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MidambleShiftLCR                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MidambleShiftLCR (ASN1CTXT* pctxt, MidambleShiftLCR* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftLCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "midambleShiftPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.midambleShiftPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode midambleAllocationMode */

   PU_PUSHNAME (pctxt, "midambleAllocationMode");

   stat = asn1PD_MidambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShift */

   if (pvalue->m.midambleShiftPresent) {
      PU_PUSHNAME (pctxt, "midambleShift");

      stat = asn1PD_MidambleShiftLong (pctxt, &pvalue->midambleShift);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode midambleConfigurationLCR */

   PU_PUSHNAME (pctxt, "midambleConfigurationLCR");

   stat = asn1PD_MidambleConfigurationLCR (pctxt, &pvalue->midambleConfigurationLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MidambleShiftLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QPSK_DL_DPCH_TimeSlotFormatTDD_LCR                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_QPSK_DL_DPCH_TimeSlotFormatTDD_LCR (ASN1CTXT* pctxt, QPSK_DL_DPCH_TimeSlotFormatTDD_LCR* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_QPSK_DL_DPCH_TimeSlotFormatTDD_LCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(24));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QPSK_DL_DPCH_TimeSlotFormatTDD_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EightPSK_DL_DPCH_TimeSlotFormatTDD_LCR                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_EightPSK_DL_DPCH_TimeSlotFormatTDD_LCR (ASN1CTXT* pctxt, EightPSK_DL_DPCH_TimeSlotFormatTDD_LCR* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_EightPSK_DL_DPCH_TimeSlotFormatTDD_LCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(24));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EightPSK_DL_DPCH_TimeSlotFormatTDD_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_DL_DPCH_TimeSlotFormat_LCR                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_DL_DPCH_TimeSlotFormat_LCR (ASN1CTXT* pctxt, TDD_DL_DPCH_TimeSlotFormat_LCR* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_DL_DPCH_TimeSlotFormat_LCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* qPSK */
         case 0:
            PU_PUSHNAME (pctxt, "u.qPSK");

            stat = asn1PD_QPSK_DL_DPCH_TimeSlotFormatTDD_LCR (pctxt, &pvalue->u.qPSK);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* eightPSK */
         case 1:
            PU_PUSHNAME (pctxt, "u.eightPSK");

            stat = asn1PD_EightPSK_DL_DPCH_TimeSlotFormatTDD_LCR (pctxt, &pvalue->u.eightPSK);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_DL_DPCH_TimeSlotFormat_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotificationIndicatorLength                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NotificationIndicatorLength (ASN1CTXT* pctxt, NotificationIndicatorLength* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_NotificationIndicatorLength: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = v2_4; break;
         case 1: *pvalue = v4_8; break;
         case 2: *pvalue = v8_7; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NotificationIndicatorLength: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TSTD_Indicator                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TSTD_Indicator (ASN1CTXT* pctxt, TSTD_Indicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_TSTD_Indicator: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = active_6; break;
      case 1: *pvalue = inactive_5; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TSTD_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaxPRACH_MidambleShifts                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MaxPRACH_MidambleShifts (ASN1CTXT* pctxt, MaxPRACH_MidambleShifts* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MaxPRACH_MidambleShifts: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = shift4; break;
         case 1: *pvalue = shift8; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MaxPRACH_MidambleShifts: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PRACH_Midamble                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PRACH_Midamble (ASN1CTXT* pctxt, PRACH_Midamble* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_Midamble: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = inverted; break;
         case 1: *pvalue = direct; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PRACH_Midamble: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FPACH_Power                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FPACH_Power (ASN1CTXT* pctxt, FPACH_Power* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_FPACH_Power: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(-150), OSINTCONST(400));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FPACH_Power: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BindingID                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BindingID (ASN1CTXT* pctxt, BindingID* pvalue)
{
   static Asn1SizeCnst lsize2 = { 1, OSUINTCONST(0), OSUINT32_MAX, 0 };
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(4), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_BindingID: start\n");

   lsize1.next = &lsize2;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_DynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_BindingID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportLayerAddress                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportLayerAddress (ASN1CTXT* pctxt, TransportLayerAddress* pvalue)
{
   static Asn1SizeCnst lsize2 = { 1, OSUINTCONST(0), OSUINT32_MAX, 0 };
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(160), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportLayerAddress: start\n");

   lsize1.next = &lsize2;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_DynBitString (pctxt, (ASN1DynBitStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportLayerAddress: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonTransportChannel_InformationResponse                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonTransportChannel_InformationResponse (ASN1CTXT* pctxt, CommonTransportChannel_InformationResponse* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannel_InformationResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bindingIDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportLayerAddressPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonTransportChannelID */

   PU_PUSHNAME (pctxt, "commonTransportChannelID");

   stat = asn1PD_CommonTransportChannelID (pctxt, &pvalue->commonTransportChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PD_BindingID (pctxt, &pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonTransportChannel_InformationResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  C_ID                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_C_ID (ASN1CTXT* pctxt, C_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_C_ID: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_C_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConfigurationGenerationID                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ConfigurationGenerationID (ASN1CTXT* pctxt, ConfigurationGenerationID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ConfigurationGenerationID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_ConfigurationGenerationID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResourceOperationalState                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ResourceOperationalState (ASN1CTXT* pctxt, ResourceOperationalState* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_ResourceOperationalState: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = enabled; break;
      case 1: *pvalue = disabled; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ResourceOperationalState: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AvailabilityStatus                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AvailabilityStatus (ASN1CTXT* pctxt, AvailabilityStatus* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_AvailabilityStatus: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(9));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = empty; break;
         case 1: *pvalue = in_test; break;
         case 2: *pvalue = failed; break;
         case 3: *pvalue = power_off; break;
         case 4: *pvalue = off_line; break;
         case 5: *pvalue = off_duty; break;
         case 6: *pvalue = dependency; break;
         case 7: *pvalue = degraded; break;
         case 8: *pvalue = not_installed; break;
         case 9: *pvalue = log_full; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AvailabilityStatus: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Local_Cell_ID                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Local_Cell_ID (ASN1CTXT* pctxt, Local_Cell_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_ID: start\n");

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(268435455));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Local_Cell_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommunicationControlPortID                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommunicationControlPortID (ASN1CTXT* pctxt, CommunicationControlPortID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommunicationControlPortID: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_CommunicationControlPortID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_or_Global_CapacityCredit                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_or_Global_CapacityCredit (ASN1CTXT* pctxt, DL_or_Global_CapacityCredit* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_or_Global_CapacityCredit: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_or_Global_CapacityCredit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_CapacityCredit                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_CapacityCredit (ASN1CTXT* pctxt, UL_CapacityCredit* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CapacityCredit: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_CapacityCredit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonChannelsCapacityConsumptionLaw_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonChannelsCapacityConsumptionLaw_element (ASN1CTXT* pctxt, CommonChannelsCapacityConsumptionLaw_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonChannelsCapacityConsumptionLaw_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dl_Cost */

   PU_PUSHNAME (pctxt, "dl_Cost");

   stat = pd_ConsUInt16 (pctxt, &pvalue->dl_Cost, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_Cost */

   PU_PUSHNAME (pctxt, "ul_Cost");

   stat = pd_ConsUInt16 (pctxt, &pvalue->ul_Cost, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonChannelsCapacityConsumptionLaw_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonChannelsCapacityConsumptionLaw                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonChannelsCapacityConsumptionLaw (ASN1CTXT* pctxt, CommonChannelsCapacityConsumptionLaw* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   CommonChannelsCapacityConsumptionLaw_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonChannelsCapacityConsumptionLaw: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CommonChannelsCapacityConsumptionLaw_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CommonChannelsCapacityConsumptionLaw_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonChannelsCapacityConsumptionLaw: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedChannelsCapacityConsumptionLaw_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DedicatedChannelsCapacityConsumptionLaw_element (ASN1CTXT* pctxt, DedicatedChannelsCapacityConsumptionLaw_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedChannelsCapacityConsumptionLaw_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dl_Cost_1 */

   PU_PUSHNAME (pctxt, "dl_Cost_1");

   stat = pd_ConsUInt16 (pctxt, &pvalue->dl_Cost_1, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_Cost_2 */

   PU_PUSHNAME (pctxt, "dl_Cost_2");

   stat = pd_ConsUInt16 (pctxt, &pvalue->dl_Cost_2, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_Cost_1 */

   PU_PUSHNAME (pctxt, "ul_Cost_1");

   stat = pd_ConsUInt16 (pctxt, &pvalue->ul_Cost_1, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_Cost_2 */

   PU_PUSHNAME (pctxt, "ul_Cost_2");

   stat = pd_ConsUInt16 (pctxt, &pvalue->ul_Cost_2, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedChannelsCapacityConsumptionLaw_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedChannelsCapacityConsumptionLaw                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DedicatedChannelsCapacityConsumptionLaw (ASN1CTXT* pctxt, DedicatedChannelsCapacityConsumptionLaw* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   DedicatedChannelsCapacityConsumptionLaw_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedChannelsCapacityConsumptionLaw: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DedicatedChannelsCapacityConsumptionLaw_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DedicatedChannelsCapacityConsumptionLaw_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedChannelsCapacityConsumptionLaw: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaximumDL_PowerCapability                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MaximumDL_PowerCapability (ASN1CTXT* pctxt, MaximumDL_PowerCapability* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MaximumDL_PowerCapability: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(500));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_MaximumDL_PowerCapability: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MinSpreadingFactor                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MinSpreadingFactor (ASN1CTXT* pctxt, MinSpreadingFactor* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_MinSpreadingFactor: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = v4_5; break;
      case 1: *pvalue = v8_4; break;
      case 2: *pvalue = v16_3; break;
      case 3: *pvalue = v32_1; break;
      case 4: *pvalue = v64; break;
      case 5: *pvalue = v128; break;
      case 6: *pvalue = v256; break;
      case 7: *pvalue = v512; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MinSpreadingFactor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MinimumDL_PowerCapability                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MinimumDL_PowerCapability (ASN1CTXT* pctxt, MinimumDL_PowerCapability* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MinimumDL_PowerCapability: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(800));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_MinimumDL_PowerCapability: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transmitted_Carrier_Power_Value                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Transmitted_Carrier_Power_Value (ASN1CTXT* pctxt, Transmitted_Carrier_Power_Value* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Transmitted_Carrier_Power_Value: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(100));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Transmitted_Carrier_Power_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Received_total_wide_band_power_Value                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Received_total_wide_band_power_Value (ASN1CTXT* pctxt, Received_total_wide_band_power_Value* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Received_total_wide_band_power_Value: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(621));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Received_total_wide_band_power_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Acknowledged_PRACH_preambles_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Acknowledged_PRACH_preambles_Value (ASN1CTXT* pctxt, Acknowledged_PRACH_preambles_Value* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Acknowledged_PRACH_preambles_Value: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(240));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Acknowledged_PRACH_preambles_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_TimeslotISCP_Value                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_TimeslotISCP_Value (ASN1CTXT* pctxt, UL_TimeslotISCP_Value* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_TimeslotISCP_Value: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_TimeslotISCP_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Extension_CommonMeasurementValue                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Extension_CommonMeasurementValue (ASN1CTXT* pctxt, Extension_CommonMeasurementValue* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Extension_CommonMeasurementValue: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Extension_CommonMeasurementValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementValue                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonMeasurementValue (ASN1CTXT* pctxt, CommonMeasurementValue* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;
   ASN1CTXT lctxt;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementValue: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* transmitted_carrier_power */
         case 0:
            PU_PUSHNAME (pctxt, "u.transmitted_carrier_power");

            stat = asn1PD_Transmitted_Carrier_Power_Value (pctxt, &pvalue->u.transmitted_carrier_power);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* received_total_wide_band_power */
         case 1:
            PU_PUSHNAME (pctxt, "u.received_total_wide_band_power");

            stat = asn1PD_Received_total_wide_band_power_Value (pctxt, &pvalue->u.received_total_wide_band_power);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* acknowledged_prach_preambles */
         case 2:
            PU_PUSHNAME (pctxt, "u.acknowledged_prach_preambles");

            stat = asn1PD_Acknowledged_PRACH_preambles_Value (pctxt, &pvalue->u.acknowledged_prach_preambles);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* uL_TimeslotISCP */
         case 3:
            PU_PUSHNAME (pctxt, "u.uL_TimeslotISCP");

            stat = asn1PD_UL_TimeslotISCP_Value (pctxt, &pvalue->u.uL_TimeslotISCP);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* notUsed_1_acknowledged_PCPCH_access_preambles */
         case 4:
            PU_PUSHNAME (pctxt, "u.notUsed_1_acknowledged_PCPCH_access_preambles");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         /* notUsed_2_detected_PCPCH_access_preambles */
         case 5:
            PU_PUSHNAME (pctxt, "u.notUsed_2_detected_PCPCH_access_preambles");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 7;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      rtCopyContext (&lctxt, pctxt);
      rtInitContextBuffer (pctxt, openType.data, openType.numocts);
      pu_setTrace (pctxt, FALSE);

      switch (pvalue->t) {
         /* extension_CommonMeasurementValue */
         case 7:
            PU_PUSHNAME (pctxt, "u.extension_CommonMeasurementValue");

            pvalue->u.extension_CommonMeasurementValue = rtMemAllocTypeZ (pctxt, Extension_CommonMeasurementValue);
            if (pvalue->u.extension_CommonMeasurementValue == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Extension_CommonMeasurementValue (pctxt, pvalue->u.extension_CommonMeasurementValue);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            PU_PUSHNAME (pctxt, "extension");

            pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

            PU_POPNAME (pctxt);

      }

      rtCopyContext (pctxt, &lctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementAvailable                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonMeasurementAvailable (ASN1CTXT* pctxt, CommonMeasurementAvailable* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementAvailable: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ie_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonmeasurementValue */

   PU_PUSHNAME (pctxt, "commonmeasurementValue");

   stat = asn1PD_CommonMeasurementValue (pctxt, &pvalue->commonmeasurementValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementAvailable: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementnotAvailable                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonMeasurementnotAvailable_ (ASN1CTXT* pctxt, void* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementnotAvailable: start\n");

   /* NULL */

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementnotAvailable: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementValueInformation                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonMeasurementValueInformation (ASN1CTXT* pctxt, CommonMeasurementValueInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementValueInformation: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* measurementAvailable */
      case 0:
         PU_PUSHNAME (pctxt, "u.measurementAvailable");

         pvalue->u.measurementAvailable = rtMemAllocTypeZ (pctxt, CommonMeasurementAvailable);
         if (pvalue->u.measurementAvailable == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_CommonMeasurementAvailable (pctxt, pvalue->u.measurementAvailable);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* measurementnotAvailable */
      case 1:
         PU_PUSHNAME (pctxt, "u.measurementnotAvailable");

         stat = asn1PD_CommonMeasurementnotAvailable (pctxt);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementValueInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  N_INSYNC_IND                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_N_INSYNC_IND (ASN1CTXT* pctxt, N_INSYNC_IND* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_N_INSYNC_IND: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(256));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_N_INSYNC_IND: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  N_OUTSYNC_IND                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_N_OUTSYNC_IND (ASN1CTXT* pctxt, N_OUTSYNC_IND* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_N_OUTSYNC_IND: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(256));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_N_OUTSYNC_IND: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  T_RLFAILURE                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_T_RLFAILURE (ASN1CTXT* pctxt, T_RLFAILURE* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_T_RLFAILURE: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_T_RLFAILURE: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrimaryCPICH_Power                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PrimaryCPICH_Power (ASN1CTXT* pctxt, PrimaryCPICH_Power* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimaryCPICH_Power: start\n");

   stat = pd_ConsInt16 (pctxt, pvalue, OSINTCONST(-100), OSINTCONST(500));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimaryCPICH_Power: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransmitDiversityIndicator                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransmitDiversityIndicator (ASN1CTXT* pctxt, TransmitDiversityIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransmitDiversityIndicator: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = active_5; break;
      case 1: *pvalue = inactive_4; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransmitDiversityIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PowerRaiseLimit                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PowerRaiseLimit (ASN1CTXT* pctxt, PowerRaiseLimit* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerRaiseLimit: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(10));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerRaiseLimit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DLPowerAveragingWindowSize                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DLPowerAveragingWindowSize (ASN1CTXT* pctxt, DLPowerAveragingWindowSize* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DLPowerAveragingWindowSize: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(60));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DLPowerAveragingWindowSize: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_FDD_Parameters_iP_SpacingFDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IPDL_FDD_Parameters_iP_SpacingFDD (ASN1CTXT* pctxt, IPDL_FDD_Parameters_iP_SpacingFDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_FDD_Parameters_iP_SpacingFDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = sp5; break;
         case 1: *pvalue = sp7; break;
         case 2: *pvalue = sp10; break;
         case 3: *pvalue = sp15; break;
         case 4: *pvalue = sp20; break;
         case 5: *pvalue = sp30; break;
         case 6: *pvalue = sp40; break;
         case 7: *pvalue = sp50; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_FDD_Parameters_iP_SpacingFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_FDD_Parameters_iP_Length                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IPDL_FDD_Parameters_iP_Length (ASN1CTXT* pctxt, IPDL_FDD_Parameters_iP_Length* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_FDD_Parameters_iP_Length: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = len5; break;
      case 1: *pvalue = len10; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_FDD_Parameters_iP_Length: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BurstModeParams                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BurstModeParams (ASN1CTXT* pctxt, BurstModeParams* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_BurstModeParams: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtDListInit (&pvalue->extElem1);

   /* decode burstStart */

   PU_PUSHNAME (pctxt, "burstStart");

   stat = pd_ConsUInt8 (pctxt, &pvalue->burstStart, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode burstLength */

   PU_PUSHNAME (pctxt, "burstLength");

   stat = pd_ConsUInt8 (pctxt, &pvalue->burstLength, OSUINTCONST(10), OSUINTCONST(25));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode burstFreq */

   PU_PUSHNAME (pctxt, "burstFreq");

   stat = pd_ConsUInt8 (pctxt, &pvalue->burstFreq, OSUINTCONST(1), OSUINTCONST(16));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BurstModeParams: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_FDD_Parameters                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IPDL_FDD_Parameters (ASN1CTXT* pctxt, IPDL_FDD_Parameters* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_FDD_Parameters: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "burstModeParamsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.burstModeParamsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode iP_SpacingFDD */

   PU_PUSHNAME (pctxt, "iP_SpacingFDD");

   stat = asn1PD_IPDL_FDD_Parameters_iP_SpacingFDD (pctxt, &pvalue->iP_SpacingFDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iP_Length */

   PU_PUSHNAME (pctxt, "iP_Length");

   stat = asn1PD_IPDL_FDD_Parameters_iP_Length (pctxt, &pvalue->iP_Length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode seed */

   PU_PUSHNAME (pctxt, "seed");

   stat = pd_ConsUInt8 (pctxt, &pvalue->seed, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode burstModeParams */

   if (pvalue->m.burstModeParamsPresent) {
      PU_PUSHNAME (pctxt, "burstModeParams");

      stat = asn1PD_BurstModeParams (pctxt, &pvalue->burstModeParams);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iP_Offset */

   PU_PUSHNAME (pctxt, "iP_Offset");

   stat = pd_ConsUInt8 (pctxt, &pvalue->iP_Offset, OSUINTCONST(0), OSUINTCONST(9));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_FDD_Parameters: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_Indicator                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IPDL_Indicator (ASN1CTXT* pctxt, IPDL_Indicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_Indicator: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = active_2; break;
      case 1: *pvalue = inactive_2; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellPortionID                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellPortionID (ASN1CTXT* pctxt, CellPortionID* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellPortionID: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(63));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellPortionID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SCH_TimeSlot                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SCH_TimeSlot (ASN1CTXT* pctxt, SCH_TimeSlot* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SCH_TimeSlot: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(6));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SCH_TimeSlot: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PCCPCH_Power                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PCCPCH_Power (ASN1CTXT* pctxt, PCCPCH_Power* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PCCPCH_Power: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(-150), OSINTCONST(400));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PCCPCH_Power: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SCTD_Indicator                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SCTD_Indicator (ASN1CTXT* pctxt, SCTD_Indicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_SCTD_Indicator: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = active; break;
      case 1: *pvalue = inactive; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SCTD_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeSlotStatus                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TimeSlotStatus (ASN1CTXT* pctxt, TimeSlotStatus* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotStatus: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = active_4; break;
         case 1: *pvalue = not_active; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotStatus: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeSlotDirection                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TimeSlotDirection (ASN1CTXT* pctxt, TimeSlotDirection* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotDirection: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ul; break;
         case 1: *pvalue = dl; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeSlotDirection: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DwPCH_Power                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DwPCH_Power (ASN1CTXT* pctxt, DwPCH_Power* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DwPCH_Power: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(-150), OSINTCONST(400));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DwPCH_Power: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_TDD_Parameters_iP_SpacingTDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IPDL_TDD_Parameters_iP_SpacingTDD (ASN1CTXT* pctxt, IPDL_TDD_Parameters_iP_SpacingTDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_TDD_Parameters_iP_SpacingTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = sp30_1; break;
         case 1: *pvalue = sp40_1; break;
         case 2: *pvalue = sp50_1; break;
         case 3: *pvalue = sp70; break;
         case 4: *pvalue = sp100; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_TDD_Parameters_iP_SpacingTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_TDD_Parameters_iP_PCCPCH                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IPDL_TDD_Parameters_iP_PCCPCH (ASN1CTXT* pctxt, IPDL_TDD_Parameters_iP_PCCPCH* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_TDD_Parameters_iP_PCCPCH: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = switchOff_1_Frame; break;
      case 1: *pvalue = switchOff_2_Frames; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_TDD_Parameters_iP_PCCPCH: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_TDD_Parameters                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IPDL_TDD_Parameters (ASN1CTXT* pctxt, IPDL_TDD_Parameters* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_TDD_Parameters: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "burstModeParamsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.burstModeParamsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode iP_SpacingTDD */

   PU_PUSHNAME (pctxt, "iP_SpacingTDD");

   stat = asn1PD_IPDL_TDD_Parameters_iP_SpacingTDD (pctxt, &pvalue->iP_SpacingTDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iP_Start */

   PU_PUSHNAME (pctxt, "iP_Start");

   stat = pd_ConsUInt16 (pctxt, &pvalue->iP_Start, OSUINTCONST(0), OSUINTCONST(4095));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iP_Slot */

   PU_PUSHNAME (pctxt, "iP_Slot");

   stat = pd_ConsUInt8 (pctxt, &pvalue->iP_Slot, OSUINTCONST(0), OSUINTCONST(14));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iP_PCCPCH */

   PU_PUSHNAME (pctxt, "iP_PCCPCH");

   stat = asn1PD_IPDL_TDD_Parameters_iP_PCCPCH (pctxt, &pvalue->iP_PCCPCH);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode burstModeParams */

   if (pvalue->m.burstModeParamsPresent) {
      PU_PUSHNAME (pctxt, "burstModeParams");

      stat = asn1PD_BurstModeParams (pctxt, &pvalue->burstModeParams);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_TDD_Parameters: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_TDD_Parameters_LCR_iP_SpacingTDD                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IPDL_TDD_Parameters_LCR_iP_SpacingTDD (ASN1CTXT* pctxt, IPDL_TDD_Parameters_LCR_iP_SpacingTDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_TDD_Parameters_LCR_iP_SpacingTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = sp30_2; break;
         case 1: *pvalue = sp40_2; break;
         case 2: *pvalue = sp50_2; break;
         case 3: *pvalue = sp70_1; break;
         case 4: *pvalue = sp100_1; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_TDD_Parameters_LCR_iP_SpacingTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_TDD_Parameters_LCR_iP_Sub                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IPDL_TDD_Parameters_LCR_iP_Sub (ASN1CTXT* pctxt, IPDL_TDD_Parameters_LCR_iP_Sub* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_TDD_Parameters_LCR_iP_Sub: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = first; break;
      case 1: *pvalue = second; break;
      case 2: *pvalue = both; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_TDD_Parameters_LCR_iP_Sub: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPDL_TDD_Parameters_LCR                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IPDL_TDD_Parameters_LCR (ASN1CTXT* pctxt, IPDL_TDD_Parameters_LCR* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_TDD_Parameters_LCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "burstModeParamsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.burstModeParamsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode iP_SpacingTDD */

   PU_PUSHNAME (pctxt, "iP_SpacingTDD");

   stat = asn1PD_IPDL_TDD_Parameters_LCR_iP_SpacingTDD (pctxt, &pvalue->iP_SpacingTDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iP_Start */

   PU_PUSHNAME (pctxt, "iP_Start");

   stat = pd_ConsUInt16 (pctxt, &pvalue->iP_Start, OSUINTCONST(0), OSUINTCONST(4095));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iP_Sub */

   PU_PUSHNAME (pctxt, "iP_Sub");

   stat = asn1PD_IPDL_TDD_Parameters_LCR_iP_Sub (pctxt, &pvalue->iP_Sub);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode burstModeParams */

   if (pvalue->m.burstModeParamsPresent) {
      PU_PUSHNAME (pctxt, "burstModeParams");

      stat = asn1PD_BurstModeParams (pctxt, &pvalue->burstModeParams);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IPDL_TDD_Parameters_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AddorDeleteIndicator                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AddorDeleteIndicator (ASN1CTXT* pctxt, AddorDeleteIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_AddorDeleteIndicator: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = add; break;
      case 1: *pvalue = delete_; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AddorDeleteIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IB_Type                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IB_Type (ASN1CTXT* pctxt, IB_Type* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_IB_Type: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      switch (ui) {
         case 0: *pvalue = sIB17; break;
         case 1: *pvalue = sIB15dot4; break;
         case 2: *pvalue = sIB18; break;
         case 3: *pvalue = sIB15dot5; break;
         case 4: *pvalue = sIB5bis; break;
         default: *pvalue = ui;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(25));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = mIB; break;
         case 1: *pvalue = sB1; break;
         case 2: *pvalue = sB2; break;
         case 3: *pvalue = sIB1; break;
         case 4: *pvalue = sIB2; break;
         case 5: *pvalue = sIB3; break;
         case 6: *pvalue = sIB4; break;
         case 7: *pvalue = sIB5; break;
         case 8: *pvalue = sIB6; break;
         case 9: *pvalue = sIB7; break;
         case 10: *pvalue = sIB8; break;
         case 11: *pvalue = sIB9; break;
         case 12: *pvalue = sIB10; break;
         case 13: *pvalue = sIB11; break;
         case 14: *pvalue = sIB12; break;
         case 15: *pvalue = sIB13; break;
         case 16: *pvalue = sIB13dot1; break;
         case 17: *pvalue = sIB13dot2; break;
         case 18: *pvalue = sIB13dot3; break;
         case 19: *pvalue = sIB13dot4; break;
         case 20: *pvalue = sIB14; break;
         case 21: *pvalue = sIB15; break;
         case 22: *pvalue = sIB15dot1; break;
         case 23: *pvalue = sIB15dot2; break;
         case 24: *pvalue = sIB15dot3; break;
         case 25: *pvalue = sIB16; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IB_Type: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IB_OC_ID                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IB_OC_ID (ASN1CTXT* pctxt, IB_OC_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_IB_OC_ID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(16));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_IB_OC_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SIB_Originator                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SIB_Originator (ASN1CTXT* pctxt, SIB_Originator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SIB_Originator: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = nodeB; break;
         case 1: *pvalue = cRNC; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SIB_Originator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IB_SG_REP                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IB_SG_REP (ASN1CTXT* pctxt, IB_SG_REP* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_IB_SG_REP: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(10));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = rep4; break;
      case 1: *pvalue = rep8; break;
      case 2: *pvalue = rep16; break;
      case 3: *pvalue = rep32; break;
      case 4: *pvalue = rep64; break;
      case 5: *pvalue = rep128; break;
      case 6: *pvalue = rep256; break;
      case 7: *pvalue = rep512; break;
      case 8: *pvalue = rep1024; break;
      case 9: *pvalue = rep2048; break;
      case 10: *pvalue = rep4096; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IB_SG_REP: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IB_SG_POS                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IB_SG_POS (ASN1CTXT* pctxt, IB_SG_POS* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_IB_SG_POS: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(4094));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_IB_SG_POS: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Segment_Type                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Segment_Type (ASN1CTXT* pctxt, Segment_Type* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Segment_Type: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(6));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = first_segment; break;
         case 1: *pvalue = first_segment_short; break;
         case 2: *pvalue = subsequent_segment; break;
         case 3: *pvalue = last_segment; break;
         case 4: *pvalue = last_segment_short; break;
         case 5: *pvalue = complete_SIB; break;
         case 6: *pvalue = complete_SIB_short; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Segment_Type: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IB_SG_DATA                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_IB_SG_DATA (ASN1CTXT* pctxt, IB_SG_DATA* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_IB_SG_DATA: start\n");

   stat = pd_DynBitString (pctxt, (ASN1DynBitStr*)pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_IB_SG_DATA: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_ScramblingCodeNumber                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_ScramblingCodeNumber (ASN1CTXT* pctxt, UL_ScramblingCodeNumber* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_ScramblingCodeNumber: start\n");

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(16777215));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_ScramblingCodeNumber: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_ScramblingCodeLength                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_ScramblingCodeLength (ASN1CTXT* pctxt, UL_ScramblingCodeLength* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_ScramblingCodeLength: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = short_; break;
      case 1: *pvalue = long_; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_ScramblingCodeLength: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_ScramblingCode                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_ScramblingCode (ASN1CTXT* pctxt, UL_ScramblingCode* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_ScramblingCode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode uL_ScramblingCodeNumber */

   PU_PUSHNAME (pctxt, "uL_ScramblingCodeNumber");

   stat = asn1PD_UL_ScramblingCodeNumber (pctxt, &pvalue->uL_ScramblingCodeNumber);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_ScramblingCodeLength */

   PU_PUSHNAME (pctxt, "uL_ScramblingCodeLength");

   stat = asn1PD_UL_ScramblingCodeLength (pctxt, &pvalue->uL_ScramblingCodeLength);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_ScramblingCode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MinUL_ChannelisationCodeLength                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MinUL_ChannelisationCodeLength (ASN1CTXT* pctxt, MinUL_ChannelisationCodeLength* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MinUL_ChannelisationCodeLength: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(6));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = v4_6; break;
         case 1: *pvalue = v8_5; break;
         case 2: *pvalue = v16_4; break;
         case 3: *pvalue = v32_2; break;
         case 4: *pvalue = v64_1; break;
         case 5: *pvalue = v128_1; break;
         case 6: *pvalue = v256_1; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MinUL_ChannelisationCodeLength: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaxNrOfUL_DPDCHs                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MaxNrOfUL_DPDCHs (ASN1CTXT* pctxt, MaxNrOfUL_DPDCHs* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MaxNrOfUL_DPDCHs: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(6));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_MaxNrOfUL_DPDCHs: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPCCH_SlotFormat                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPCCH_SlotFormat (ASN1CTXT* pctxt, UL_DPCCH_SlotFormat* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCCH_SlotFormat: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(5));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPCCH_SlotFormat: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_SIR                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_SIR (ASN1CTXT* pctxt, UL_SIR* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_SIR: start\n");

   stat = pd_ConsInt16 (pctxt, pvalue, OSINTCONST(-82), OSINTCONST(173));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_SIR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DiversityMode                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DiversityMode (ASN1CTXT* pctxt, DiversityMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DiversityMode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = none; break;
         case 1: *pvalue = sTTD; break;
         case 2: *pvalue = closed_loop_mode1; break;
         case 3: *pvalue = not_used_closed_loop_mode2; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DiversityMode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_SlotFormat                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_SlotFormat (ASN1CTXT* pctxt, DL_DPCH_SlotFormat* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_SlotFormat: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(16));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_SlotFormat: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TFCI_SignallingMode_TFCI_SignallingOption                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TFCI_SignallingMode_TFCI_SignallingOption (ASN1CTXT* pctxt, TFCI_SignallingMode_TFCI_SignallingOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_TFCI_SignallingMode_TFCI_SignallingOption: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = normal_1; break;
      case 1: *pvalue = not_Used_split; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TFCI_SignallingMode_TFCI_SignallingOption: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TFCI_SignallingMode                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TFCI_SignallingMode (ASN1CTXT* pctxt, TFCI_SignallingMode* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TFCI_SignallingMode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "not_Used_splitTypePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_Used_splitTypePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_Used_lengthOfTFCI2Present");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_Used_lengthOfTFCI2Present = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode tFCI_SignallingOption */

   PU_PUSHNAME (pctxt, "tFCI_SignallingOption");

   stat = asn1PD_TFCI_SignallingMode_TFCI_SignallingOption (pctxt, &pvalue->tFCI_SignallingOption);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode not_Used_splitType */

   if (pvalue->m.not_Used_splitTypePresent) {
      PU_PUSHNAME (pctxt, "not_Used_splitType");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode not_Used_lengthOfTFCI2 */

   if (pvalue->m.not_Used_lengthOfTFCI2Present) {
      PU_PUSHNAME (pctxt, "not_Used_lengthOfTFCI2");

      /* NULL */

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TFCI_SignallingMode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FDD_TPC_DownlinkStepSize                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FDD_TPC_DownlinkStepSize (ASN1CTXT* pctxt, FDD_TPC_DownlinkStepSize* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_FDD_TPC_DownlinkStepSize: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = step_size0_5; break;
         case 1: *pvalue = step_size1; break;
         case 2: *pvalue = step_size1_5; break;
         case 3: *pvalue = step_size2; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FDD_TPC_DownlinkStepSize: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LimitedPowerIncrease                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_LimitedPowerIncrease (ASN1CTXT* pctxt, LimitedPowerIncrease* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_LimitedPowerIncrease: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = used; break;
      case 1: *pvalue = not_used; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LimitedPowerIncrease: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InnerLoopDLPCStatus                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InnerLoopDLPCStatus (ASN1CTXT* pctxt, InnerLoopDLPCStatus* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_InnerLoopDLPCStatus: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = active_1; break;
      case 1: *pvalue = inactive_1; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InnerLoopDLPCStatus: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_ID                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_ID (ASN1CTXT* pctxt, RL_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_ID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(31));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FirstRLS_Indicator                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FirstRLS_Indicator (ASN1CTXT* pctxt, FirstRLS_Indicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_FirstRLS_Indicator: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = first_RLS; break;
         case 1: *pvalue = not_first_RLS; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FirstRLS_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FrameOffset                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FrameOffset (ASN1CTXT* pctxt, FrameOffset* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_FrameOffset: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_FrameOffset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ChipOffset                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ChipOffset (ASN1CTXT* pctxt, ChipOffset* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ChipOffset: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(38399));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_ChipOffset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PropagationDelay                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PropagationDelay (ASN1CTXT* pctxt, PropagationDelay* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PropagationDelay: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PropagationDelay: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DiversityControlField                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DiversityControlField (ASN1CTXT* pctxt, DiversityControlField* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DiversityControlField: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = may; break;
         case 1: *pvalue = must; break;
         case 2: *pvalue = must_not; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DiversityControlField: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransmissionGapPatternSequenceCodeInformation             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransmissionGapPatternSequenceCodeInformation (ASN1CTXT* pctxt, TransmissionGapPatternSequenceCodeInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransmissionGapPatternSequenceCodeInformation: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = code_change; break;
      case 1: *pvalue = nocode_change; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransmissionGapPatternSequenceCodeInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FDD_DL_CodeInformationItem                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FDD_DL_CodeInformationItem (ASN1CTXT* pctxt, FDD_DL_CodeInformationItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_FDD_DL_CodeInformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "transmissionGapPatternSequenceCodeInformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transmissionGapPatternSequenceCodeInformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dl_ScramblingCode */

   PU_PUSHNAME (pctxt, "dl_ScramblingCode");

   stat = asn1PD_DL_ScramblingCode (pctxt, &pvalue->dl_ScramblingCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode fdd_DL_ChannelisationCodeNumber */

   PU_PUSHNAME (pctxt, "fdd_DL_ChannelisationCodeNumber");

   stat = asn1PD_FDD_DL_ChannelisationCodeNumber (pctxt, &pvalue->fdd_DL_ChannelisationCodeNumber);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode transmissionGapPatternSequenceCodeInformation */

   if (pvalue->m.transmissionGapPatternSequenceCodeInformationPresent) {
      PU_PUSHNAME (pctxt, "transmissionGapPatternSequenceCodeInformation");

      stat = asn1PD_TransmissionGapPatternSequenceCodeInformation (pctxt, &pvalue->transmissionGapPatternSequenceCodeInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FDD_DL_CodeInformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FDD_DL_CodeInformation                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FDD_DL_CodeInformation (ASN1CTXT* pctxt, FDD_DL_CodeInformation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(10), 0 };
   int stat = 0;
   FDD_DL_CodeInformationItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_FDD_DL_CodeInformation: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, FDD_DL_CodeInformationItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_FDD_DL_CodeInformationItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FDD_DL_CodeInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Max_Set_E_DPDCHs                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Max_Set_E_DPDCHs (ASN1CTXT* pctxt, Max_Set_E_DPDCHs* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Max_Set_E_DPDCHs: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(6));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = vN64; break;
         case 1: *pvalue = vN32; break;
         case 2: *pvalue = vN16; break;
         case 3: *pvalue = vN8; break;
         case 4: *pvalue = v2xN4; break;
         case 5: *pvalue = v2xN2; break;
         case 6: *pvalue = v2xN2plus2xN4; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Max_Set_E_DPDCHs: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_TFCS_Index                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_TFCS_Index (ASN1CTXT* pctxt, E_DCH_TFCS_Index* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_TFCS_Index: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(1), OSINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_TFCS_Index: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_TFCI                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_TFCI (ASN1CTXT* pctxt, E_TFCI* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_TFCI: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_E_TFCI: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reference_E_TFCI_PO                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Reference_E_TFCI_PO (ASN1CTXT* pctxt, Reference_E_TFCI_PO* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Reference_E_TFCI_PO: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(8));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Reference_E_TFCI_PO: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reference_E_TFCI_Information_Item                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Reference_E_TFCI_Information_Item (ASN1CTXT* pctxt, Reference_E_TFCI_Information_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Reference_E_TFCI_Information_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode reference_E_TFCI */

   PU_PUSHNAME (pctxt, "reference_E_TFCI");

   stat = asn1PD_E_TFCI (pctxt, &pvalue->reference_E_TFCI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode reference_E_TFCI_PO */

   PU_PUSHNAME (pctxt, "reference_E_TFCI_PO");

   stat = asn1PD_Reference_E_TFCI_PO (pctxt, &pvalue->reference_E_TFCI_PO);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Reference_E_TFCI_Information_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reference_E_TFCI_Information                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Reference_E_TFCI_Information (ASN1CTXT* pctxt, Reference_E_TFCI_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Reference_E_TFCI_Information_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Reference_E_TFCI_Information: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Reference_E_TFCI_Information_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Reference_E_TFCI_Information_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Reference_E_TFCI_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_TFCS_Information                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_TFCS_Information (ASN1CTXT* pctxt, E_TFCS_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_TFCS_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode e_DCH_TFCS_Index */

   PU_PUSHNAME (pctxt, "e_DCH_TFCS_Index");

   stat = asn1PD_E_DCH_TFCS_Index (pctxt, &pvalue->e_DCH_TFCS_Index);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode e_DCH_Min_Set_E_TFCI */

   PU_PUSHNAME (pctxt, "e_DCH_Min_Set_E_TFCI");

   stat = asn1PD_E_TFCI (pctxt, &pvalue->e_DCH_Min_Set_E_TFCI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode reference_E_TFCI_Information */

   PU_PUSHNAME (pctxt, "reference_E_TFCI_Information");

   stat = asn1PD_Reference_E_TFCI_Information (pctxt, &pvalue->reference_E_TFCI_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_TFCS_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_TTI                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_TTI (ASN1CTXT* pctxt, E_TTI* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_TTI: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = e_TTI_2ms; break;
      case 1: *pvalue = e_TTI_10ms; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_TTI: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DPCCH_PO                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DPCCH_PO (ASN1CTXT* pctxt, E_DPCCH_PO* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DPCCH_PO: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(8));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DPCCH_PO: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_DPCHOffset                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_DPCHOffset (ASN1CTXT* pctxt, TDD_DPCHOffset* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_DPCHOffset: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* initialOffset */
      case 0:
         PU_PUSHNAME (pctxt, "u.initialOffset");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.initialOffset, OSUINTCONST(0), OSUINTCONST(255));
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* noinitialOffset */
      case 1:
         PU_PUSHNAME (pctxt, "u.noinitialOffset");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.noinitialOffset, OSUINTCONST(0), OSUINTCONST(63));
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_DPCHOffset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DPCH_ID                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DPCH_ID (ASN1CTXT* pctxt, DPCH_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DPCH_ID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(239));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DPCH_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_UL_Code_InformationItem                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_UL_Code_InformationItem (ASN1CTXT* pctxt, TDD_UL_Code_InformationItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_UL_Code_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dPCH_ID */

   PU_PUSHNAME (pctxt, "dPCH_ID");

   stat = asn1PD_DPCH_ID (pctxt, &pvalue->dPCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tdd_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_UL_Code_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_UL_Code_Information                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_UL_Code_Information (ASN1CTXT* pctxt, TDD_UL_Code_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(240), 0 };
   int stat = 0;
   TDD_UL_Code_InformationItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_UL_Code_Information: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TDD_UL_Code_InformationItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TDD_UL_Code_InformationItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_UL_Code_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Timeslot_InformationItem                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Timeslot_InformationItem (ASN1CTXT* pctxt, UL_Timeslot_InformationItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftAndBurstType */

   PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCI_Presence */

   PU_PUSHNAME (pctxt, "tFCI_Presence");

   stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_Code_InformationList */

   PU_PUSHNAME (pctxt, "uL_Code_InformationList");

   stat = asn1PD_TDD_UL_Code_Information (pctxt, &pvalue->uL_Code_InformationList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Timeslot_Information                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Timeslot_Information (ASN1CTXT* pctxt, UL_Timeslot_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   UL_Timeslot_InformationItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_Information: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_Timeslot_InformationItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_Timeslot_InformationItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Timeslot_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QPSK_UL_DPCH_TimeSlotFormatTDD_LCR                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_QPSK_UL_DPCH_TimeSlotFormatTDD_LCR (ASN1CTXT* pctxt, QPSK_UL_DPCH_TimeSlotFormatTDD_LCR* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_QPSK_UL_DPCH_TimeSlotFormatTDD_LCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(69));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QPSK_UL_DPCH_TimeSlotFormatTDD_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EightPSK_UL_DPCH_TimeSlotFormatTDD_LCR                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_EightPSK_UL_DPCH_TimeSlotFormatTDD_LCR (ASN1CTXT* pctxt, EightPSK_UL_DPCH_TimeSlotFormatTDD_LCR* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_EightPSK_UL_DPCH_TimeSlotFormatTDD_LCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(24));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EightPSK_UL_DPCH_TimeSlotFormatTDD_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_UL_DPCH_TimeSlotFormat_LCR                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_UL_DPCH_TimeSlotFormat_LCR (ASN1CTXT* pctxt, TDD_UL_DPCH_TimeSlotFormat_LCR* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_UL_DPCH_TimeSlotFormat_LCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* qPSK */
         case 0:
            PU_PUSHNAME (pctxt, "u.qPSK");

            stat = asn1PD_QPSK_UL_DPCH_TimeSlotFormatTDD_LCR (pctxt, &pvalue->u.qPSK);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* eightPSK */
         case 1:
            PU_PUSHNAME (pctxt, "u.eightPSK");

            stat = asn1PD_EightPSK_UL_DPCH_TimeSlotFormatTDD_LCR (pctxt, &pvalue->u.eightPSK);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_UL_DPCH_TimeSlotFormat_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_UL_Code_LCR_InformationItem                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_UL_Code_LCR_InformationItem (ASN1CTXT* pctxt, TDD_UL_Code_LCR_InformationItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_UL_Code_LCR_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dPCH_ID */

   PU_PUSHNAME (pctxt, "dPCH_ID");

   stat = asn1PD_DPCH_ID (pctxt, &pvalue->dPCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCodeLCR */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCodeLCR");

   stat = asn1PD_TDD_ChannelisationCodeLCR (pctxt, &pvalue->tdd_ChannelisationCodeLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_UL_DPCH_TimeSlotFormat_LCR */

   PU_PUSHNAME (pctxt, "tdd_UL_DPCH_TimeSlotFormat_LCR");

   stat = asn1PD_TDD_UL_DPCH_TimeSlotFormat_LCR (pctxt, &pvalue->tdd_UL_DPCH_TimeSlotFormat_LCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_UL_Code_LCR_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_UL_Code_LCR_Information                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_UL_Code_LCR_Information (ASN1CTXT* pctxt, TDD_UL_Code_LCR_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(240), 0 };
   int stat = 0;
   TDD_UL_Code_LCR_InformationItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_UL_Code_LCR_Information: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TDD_UL_Code_LCR_InformationItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TDD_UL_Code_LCR_InformationItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_UL_Code_LCR_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_TimeslotLCR_InformationItem                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_TimeslotLCR_InformationItem (ASN1CTXT* pctxt, UL_TimeslotLCR_InformationItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_TimeslotLCR_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftLCR */

   PU_PUSHNAME (pctxt, "midambleShiftLCR");

   stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCI_Presence */

   PU_PUSHNAME (pctxt, "tFCI_Presence");

   stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_Code_InformationList */

   PU_PUSHNAME (pctxt, "uL_Code_InformationList");

   stat = asn1PD_TDD_UL_Code_LCR_Information (pctxt, &pvalue->uL_Code_InformationList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_TimeslotLCR_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_TimeslotLCR_Information                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_TimeslotLCR_Information (ASN1CTXT* pctxt, UL_TimeslotLCR_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(6), 0 };
   int stat = 0;
   UL_TimeslotLCR_InformationItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_TimeslotLCR_Information: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_TimeslotLCR_InformationItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_TimeslotLCR_InformationItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_TimeslotLCR_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_TPC_DownlinkStepSize                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_TPC_DownlinkStepSize (ASN1CTXT* pctxt, TDD_TPC_DownlinkStepSize* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_TPC_DownlinkStepSize: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = step_size1_1; break;
         case 1: *pvalue = step_size2_1; break;
         case 2: *pvalue = step_size3; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_TPC_DownlinkStepSize: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_DL_Code_InformationItem                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_DL_Code_InformationItem (ASN1CTXT* pctxt, TDD_DL_Code_InformationItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_DL_Code_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dPCH_ID */

   PU_PUSHNAME (pctxt, "dPCH_ID");

   stat = asn1PD_DPCH_ID (pctxt, &pvalue->dPCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tdd_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_DL_Code_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_DL_Code_Information                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_DL_Code_Information (ASN1CTXT* pctxt, TDD_DL_Code_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(240), 0 };
   int stat = 0;
   TDD_DL_Code_InformationItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_DL_Code_Information: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TDD_DL_Code_InformationItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TDD_DL_Code_InformationItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_DL_Code_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Timeslot_InformationItem                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Timeslot_InformationItem (ASN1CTXT* pctxt, DL_Timeslot_InformationItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftAndBurstType */

   PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCI_Presence */

   PU_PUSHNAME (pctxt, "tFCI_Presence");

   stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dL_Code_Information */

   PU_PUSHNAME (pctxt, "dL_Code_Information");

   stat = asn1PD_TDD_DL_Code_Information (pctxt, &pvalue->dL_Code_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_Timeslot_Information                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_Timeslot_Information (ASN1CTXT* pctxt, DL_Timeslot_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   DL_Timeslot_InformationItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_Information: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_Timeslot_InformationItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_Timeslot_InformationItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_Timeslot_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_DL_Code_LCR_InformationItem                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_DL_Code_LCR_InformationItem (ASN1CTXT* pctxt, TDD_DL_Code_LCR_InformationItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_DL_Code_LCR_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dPCH_ID */

   PU_PUSHNAME (pctxt, "dPCH_ID");

   stat = asn1PD_DPCH_ID (pctxt, &pvalue->dPCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_ChannelisationCodeLCR */

   PU_PUSHNAME (pctxt, "tdd_ChannelisationCodeLCR");

   stat = asn1PD_TDD_ChannelisationCodeLCR (pctxt, &pvalue->tdd_ChannelisationCodeLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tdd_DL_DPCH_TimeSlotFormat_LCR */

   PU_PUSHNAME (pctxt, "tdd_DL_DPCH_TimeSlotFormat_LCR");

   stat = asn1PD_TDD_DL_DPCH_TimeSlotFormat_LCR (pctxt, &pvalue->tdd_DL_DPCH_TimeSlotFormat_LCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_DL_Code_LCR_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_DL_Code_LCR_Information                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_DL_Code_LCR_Information (ASN1CTXT* pctxt, TDD_DL_Code_LCR_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(240), 0 };
   int stat = 0;
   TDD_DL_Code_LCR_InformationItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_DL_Code_LCR_Information: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TDD_DL_Code_LCR_InformationItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TDD_DL_Code_LCR_InformationItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_DL_Code_LCR_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_TimeslotLCR_InformationItem                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_TimeslotLCR_InformationItem (ASN1CTXT* pctxt, DL_TimeslotLCR_InformationItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_TimeslotLCR_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftLCR */

   PU_PUSHNAME (pctxt, "midambleShiftLCR");

   stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tFCI_Presence */

   PU_PUSHNAME (pctxt, "tFCI_Presence");

   stat = asn1PD_TFCI_Presence (pctxt, &pvalue->tFCI_Presence);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dL_Code_LCR_Information */

   PU_PUSHNAME (pctxt, "dL_Code_LCR_Information");

   stat = asn1PD_TDD_DL_Code_LCR_Information (pctxt, &pvalue->dL_Code_LCR_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_TimeslotLCR_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_TimeslotLCR_Information                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_TimeslotLCR_Information (ASN1CTXT* pctxt, DL_TimeslotLCR_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(6), 0 };
   int stat = 0;
   DL_TimeslotLCR_InformationItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_TimeslotLCR_Information: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_TimeslotLCR_InformationItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_TimeslotLCR_InformationItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_TimeslotLCR_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SpecialBurstScheduling                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SpecialBurstScheduling (ASN1CTXT* pctxt, SpecialBurstScheduling* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SpecialBurstScheduling: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(256));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SpecialBurstScheduling: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_TimeslotISCP                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_TimeslotISCP (ASN1CTXT* pctxt, DL_TimeslotISCP* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_TimeslotISCP: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(91));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_TimeslotISCP: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_TimeslotISCPInfoItem                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_TimeslotISCPInfoItem (ASN1CTXT* pctxt, DL_TimeslotISCPInfoItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_TimeslotISCPInfoItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dL_TimeslotISCP */

   PU_PUSHNAME (pctxt, "dL_TimeslotISCP");

   stat = asn1PD_DL_TimeslotISCP (pctxt, &pvalue->dL_TimeslotISCP);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_TimeslotISCPInfoItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_TimeslotISCPInfo                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_TimeslotISCPInfo (ASN1CTXT* pctxt, DL_TimeslotISCPInfo* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   DL_TimeslotISCPInfoItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_TimeslotISCPInfo: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_TimeslotISCPInfoItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_TimeslotISCPInfoItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_TimeslotISCPInfo: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Set_ID                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Set_ID (ASN1CTXT* pctxt, RL_Set_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_ID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(31));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Set_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_ID (ASN1CTXT* pctxt, DCH_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_ID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_InformationResponseItem                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_InformationResponseItem (ASN1CTXT* pctxt, DCH_InformationResponseItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_InformationResponseItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bindingIDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportLayerAddressPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dCH_ID */

   PU_PUSHNAME (pctxt, "dCH_ID");

   stat = asn1PD_DCH_ID (pctxt, &pvalue->dCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PD_BindingID (pctxt, &pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_InformationResponseItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_InformationResponse                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_InformationResponse (ASN1CTXT* pctxt, DCH_InformationResponse* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   DCH_InformationResponseItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_InformationResponse: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DCH_InformationResponseItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DCH_InformationResponseItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_InformationResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SSDT_SupportIndicator                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SSDT_SupportIndicator (ASN1CTXT* pctxt, SSDT_SupportIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_SSDT_SupportIndicator: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = not_Used_sSDT_Supported; break;
      case 1: *pvalue = sSDT_not_supported; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SSDT_SupportIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_TimeSlot_ISCP_InfoItem                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_TimeSlot_ISCP_InfoItem (ASN1CTXT* pctxt, UL_TimeSlot_ISCP_InfoItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_TimeSlot_ISCP_InfoItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iSCP */

   PU_PUSHNAME (pctxt, "iSCP");

   stat = asn1PD_UL_TimeslotISCP_Value (pctxt, &pvalue->iSCP);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_TimeSlot_ISCP_InfoItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_TimeSlot_ISCP_Info                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_TimeSlot_ISCP_Info (ASN1CTXT* pctxt, UL_TimeSlot_ISCP_Info* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   UL_TimeSlot_ISCP_InfoItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_TimeSlot_ISCP_Info: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_TimeSlot_ISCP_InfoItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_TimeSlot_ISCP_InfoItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_TimeSlot_ISCP_Info: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_PhysCH_SF_Variation                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_PhysCH_SF_Variation (ASN1CTXT* pctxt, UL_PhysCH_SF_Variation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_PhysCH_SF_Variation: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = sf_variation_supported; break;
      case 1: *pvalue = sf_variation_not_supported; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_PhysCH_SF_Variation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_TimeSlot_ISCP_LCR_InfoItem                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_TimeSlot_ISCP_LCR_InfoItem (ASN1CTXT* pctxt, UL_TimeSlot_ISCP_LCR_InfoItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_TimeSlot_ISCP_LCR_InfoItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iSCP */

   PU_PUSHNAME (pctxt, "iSCP");

   stat = asn1PD_UL_TimeslotISCP_Value (pctxt, &pvalue->iSCP);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_TimeSlot_ISCP_LCR_InfoItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_TimeSlot_ISCP_LCR_Info                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_TimeSlot_ISCP_LCR_Info (ASN1CTXT* pctxt, UL_TimeSlot_ISCP_LCR_Info* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(6), 0 };
   int stat = 0;
   UL_TimeSlot_ISCP_LCR_InfoItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_TimeSlot_ISCP_LCR_Info: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, UL_TimeSlot_ISCP_LCR_InfoItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_UL_TimeSlot_ISCP_LCR_InfoItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_TimeSlot_ISCP_LCR_Info: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseRadioNetwork                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseRadioNetwork (ASN1CTXT* pctxt, CauseRadioNetwork* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseRadioNetwork: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      switch (ui) {
         case 0: *pvalue = number_of_UL_codes_not_supported; break;
         case 1: *pvalue = information_temporarily_not_available; break;
         case 2: *pvalue = information_provision_not_supported_for_the_object; break;
         case 3: *pvalue = cell_synchronisation_not_supported; break;
         case 4: *pvalue = cell_synchronisation_adjustment_not_supported; break;
         case 5: *pvalue = dpc_mode_change_not_supported; break;
         case 6: *pvalue = iPDL_already_activated; break;
         case 7: *pvalue = iPDL_not_supported; break;
         case 8: *pvalue = iPDL_parameters_not_available; break;
         case 9: *pvalue = frequency_acquisition_not_supported; break;
         case 10: *pvalue = power_balancing_status_not_compatible; break;
         case 11: *pvalue = requested_typeofbearer_re_arrangement_not_supported; break;
         case 12: *pvalue = signalling_Bearer_Re_arrangement_not_supported; break;
         case 13: *pvalue = bearer_Re_arrangement_needed; break;
         case 14: *pvalue = delayed_activation_not_supported; break;
         case 15: *pvalue = rl_timing_adjustment_not_supported; break;
         case 16: *pvalue = mich_not_supported; break;
         case 17: *pvalue = f_DPCH_not_supported; break;
         default: *pvalue = ui;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(30));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = unknown_C_ID; break;
         case 1: *pvalue = cell_not_available; break;
         case 2: *pvalue = power_level_not_supported; break;
         case 3: *pvalue = dl_radio_resources_not_available; break;
         case 4: *pvalue = ul_radio_resources_not_available; break;
         case 5: *pvalue = rl_already_ActivatedOrAllocated; break;
         case 6: *pvalue = nodeB_Resources_unavailable; break;
         case 7: *pvalue = measurement_not_supported_for_the_object; break;
         case 8: *pvalue = combining_resources_not_available; break;
         case 9: *pvalue = requested_configuration_not_supported; break;
         case 10: *pvalue = synchronisation_failure; break;
         case 11: *pvalue = priority_transport_channel_established; break;
         case 12: *pvalue = sIB_Origination_in_Node_B_not_Supported; break;
         case 13: *pvalue = requested_tx_diversity_mode_not_supported; break;
         case 14: *pvalue = unspecified_2; break;
         case 15: *pvalue = bCCH_scheduling_error; break;
         case 16: *pvalue = measurement_temporarily_not_available; break;
         case 17: *pvalue = invalid_CM_settings; break;
         case 18: *pvalue = reconfiguration_CFN_not_elapsed; break;
         case 19: *pvalue = number_of_DL_codes_not_supported; break;
         case 20: *pvalue = s_cipch_not_supported; break;
         case 21: *pvalue = combining_not_supported; break;
         case 22: *pvalue = ul_sf_not_supported; break;
         case 23: *pvalue = dl_SF_not_supported; break;
         case 24: *pvalue = common_transport_channel_type_not_supported; break;
         case 25: *pvalue = dedicated_transport_channel_type_not_supported; break;
         case 26: *pvalue = downlink_shared_channel_type_not_supported; break;
         case 27: *pvalue = uplink_shared_channel_type_not_supported; break;
         case 28: *pvalue = cm_not_supported; break;
         case 29: *pvalue = tx_diversity_no_longer_supported; break;
         case 30: *pvalue = unknown_Local_Cell_ID; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseRadioNetwork: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseTransport                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseTransport (ASN1CTXT* pctxt, CauseTransport* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseTransport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = transport_resource_unavailable; break;
         case 1: *pvalue = unspecified_3; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseTransport: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseProtocol                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseProtocol (ASN1CTXT* pctxt, CauseProtocol* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseProtocol: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(6));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = transfer_syntax_error; break;
         case 1: *pvalue = abstract_syntax_error_reject; break;
         case 2: *pvalue = abstract_syntax_error_ignore_and_notify; break;
         case 3: *pvalue = message_not_compatible_with_receiver_state; break;
         case 4: *pvalue = semantic_error; break;
         case 5: *pvalue = unspecified_1; break;
         case 6: *pvalue = abstract_syntax_error_falsely_constructed_message; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseProtocol: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseMisc                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CauseMisc (ASN1CTXT* pctxt, CauseMisc* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseMisc: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = control_processing_overload; break;
         case 1: *pvalue = hardware_failure; break;
         case 2: *pvalue = oam_intervention; break;
         case 3: *pvalue = not_enough_user_plane_processing_resources; break;
         case 4: *pvalue = unspecified; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseMisc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cause                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Cause (ASN1CTXT* pctxt, Cause* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Cause: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* radioNetwork */
         case 0:
            PU_PUSHNAME (pctxt, "u.radioNetwork");

            stat = asn1PD_CauseRadioNetwork (pctxt, &pvalue->u.radioNetwork);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* transport */
         case 1:
            PU_PUSHNAME (pctxt, "u.transport");

            stat = asn1PD_CauseTransport (pctxt, &pvalue->u.transport);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* protocol */
         case 2:
            PU_PUSHNAME (pctxt, "u.protocol");

            stat = asn1PD_CauseProtocol (pctxt, &pvalue->u.protocol);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* misc */
         case 3:
            PU_PUSHNAME (pctxt, "u.misc");

            stat = asn1PD_CauseMisc (pctxt, &pvalue->u.misc);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Cause: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_TPC_UplinkStepSize_LCR                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_TPC_UplinkStepSize_LCR (ASN1CTXT* pctxt, TDD_TPC_UplinkStepSize_LCR* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_TPC_UplinkStepSize_LCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = step_size1_2; break;
         case 1: *pvalue = step_size2_2; break;
         case 2: *pvalue = step_size3_1; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_TPC_UplinkStepSize_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_ID                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DSCH_ID (ASN1CTXT* pctxt, DSCH_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_ID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityLevel                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PriorityLevel (ASN1CTXT* pctxt, PriorityLevel* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityLevel: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityLevel: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Pre_emptionCapability                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Pre_emptionCapability (ASN1CTXT* pctxt, Pre_emptionCapability* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_Pre_emptionCapability: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = shall_not_trigger_pre_emption; break;
      case 1: *pvalue = may_trigger_pre_emption; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Pre_emptionCapability: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Pre_emptionVulnerability                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Pre_emptionVulnerability (ASN1CTXT* pctxt, Pre_emptionVulnerability* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_Pre_emptionVulnerability: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = not_pre_emptable; break;
      case 1: *pvalue = pre_emptable; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Pre_emptionVulnerability: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AllocationRetentionPriority                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AllocationRetentionPriority (ASN1CTXT* pctxt, AllocationRetentionPriority* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_AllocationRetentionPriority: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode priorityLevel */

   PU_PUSHNAME (pctxt, "priorityLevel");

   stat = asn1PD_PriorityLevel (pctxt, &pvalue->priorityLevel);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pre_emptionCapability */

   PU_PUSHNAME (pctxt, "pre_emptionCapability");

   stat = asn1PD_Pre_emptionCapability (pctxt, &pvalue->pre_emptionCapability);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode pre_emptionVulnerability */

   PU_PUSHNAME (pctxt, "pre_emptionVulnerability");

   stat = asn1PD_Pre_emptionVulnerability (pctxt, &pvalue->pre_emptionVulnerability);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AllocationRetentionPriority: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FrameHandlingPriority                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FrameHandlingPriority (ASN1CTXT* pctxt, FrameHandlingPriority* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_FrameHandlingPriority: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_FrameHandlingPriority: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportBearerRequestIndicator                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransportBearerRequestIndicator (ASN1CTXT* pctxt, TransportBearerRequestIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportBearerRequestIndicator: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = bearerRequested_1; break;
         case 1: *pvalue = bearerNotRequested; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportBearerRequestIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_ID                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_USCH_ID (ASN1CTXT* pctxt, USCH_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_ID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCH_ID                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PUSCH_ID (ASN1CTXT* pctxt, PUSCH_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_ID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCH_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SICH_ID                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SICH_ID (ASN1CTXT* pctxt, HS_SICH_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_ID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(31));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SIR_Value                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SIR_Value (ASN1CTXT* pctxt, SIR_Value* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SIR_Value: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SIR_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SIR_Error_Value                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SIR_Error_Value (ASN1CTXT* pctxt, SIR_Error_Value* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SIR_Error_Value: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(125));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SIR_Error_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transmitted_Code_Power_Value                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Transmitted_Code_Power_Value (ASN1CTXT* pctxt, Transmitted_Code_Power_Value* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Transmitted_Code_Power_Value: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Transmitted_Code_Power_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RSCP_Value                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RSCP_Value (ASN1CTXT* pctxt, RSCP_Value* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RSCP_Value: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_RSCP_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Rx_Timing_Deviation_Value                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Rx_Timing_Deviation_Value (ASN1CTXT* pctxt, Rx_Timing_Deviation_Value* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Rx_Timing_Deviation_Value: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(8191));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Rx_Timing_Deviation_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Round_Trip_Time_Value                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Round_Trip_Time_Value (ASN1CTXT* pctxt, Round_Trip_Time_Value* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Round_Trip_Time_Value: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(32767));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Round_Trip_Time_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Extension_DedicatedMeasurementValue                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Extension_DedicatedMeasurementValue (ASN1CTXT* pctxt, Extension_DedicatedMeasurementValue* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Extension_DedicatedMeasurementValue: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Extension_DedicatedMeasurementValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementValue                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DedicatedMeasurementValue (ASN1CTXT* pctxt, DedicatedMeasurementValue* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;
   ASN1CTXT lctxt;

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementValue: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* sIR_Value */
         case 0:
            PU_PUSHNAME (pctxt, "u.sIR_Value");

            stat = asn1PD_SIR_Value (pctxt, &pvalue->u.sIR_Value);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* sIR_ErrorValue */
         case 1:
            PU_PUSHNAME (pctxt, "u.sIR_ErrorValue");

            stat = asn1PD_SIR_Error_Value (pctxt, &pvalue->u.sIR_ErrorValue);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* transmittedCodePowerValue */
         case 2:
            PU_PUSHNAME (pctxt, "u.transmittedCodePowerValue");

            stat = asn1PD_Transmitted_Code_Power_Value (pctxt, &pvalue->u.transmittedCodePowerValue);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* rSCP */
         case 3:
            PU_PUSHNAME (pctxt, "u.rSCP");

            stat = asn1PD_RSCP_Value (pctxt, &pvalue->u.rSCP);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* rxTimingDeviationValue */
         case 4:
            PU_PUSHNAME (pctxt, "u.rxTimingDeviationValue");

            stat = asn1PD_Rx_Timing_Deviation_Value (pctxt, &pvalue->u.rxTimingDeviationValue);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* roundTripTime */
         case 5:
            PU_PUSHNAME (pctxt, "u.roundTripTime");

            stat = asn1PD_Round_Trip_Time_Value (pctxt, &pvalue->u.roundTripTime);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 7;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      rtCopyContext (&lctxt, pctxt);
      rtInitContextBuffer (pctxt, openType.data, openType.numocts);
      pu_setTrace (pctxt, FALSE);

      switch (pvalue->t) {
         /* extension_DedicatedMeasurementValue */
         case 7:
            PU_PUSHNAME (pctxt, "u.extension_DedicatedMeasurementValue");

            pvalue->u.extension_DedicatedMeasurementValue = rtMemAllocTypeZ (pctxt, Extension_DedicatedMeasurementValue);
            if (pvalue->u.extension_DedicatedMeasurementValue == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Extension_DedicatedMeasurementValue (pctxt, pvalue->u.extension_DedicatedMeasurementValue);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            PU_PUSHNAME (pctxt, "extension");

            pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

            PU_POPNAME (pctxt);

      }

      rtCopyContext (pctxt, &lctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CFN                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CFN (ASN1CTXT* pctxt, CFN* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CFN: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_CFN: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementAvailable                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DedicatedMeasurementAvailable (ASN1CTXT* pctxt, DedicatedMeasurementAvailable* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementAvailable: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "cFNPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cFNPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ie_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dedicatedmeasurementValue */

   PU_PUSHNAME (pctxt, "dedicatedmeasurementValue");

   stat = asn1PD_DedicatedMeasurementValue (pctxt, &pvalue->dedicatedmeasurementValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cFN */

   if (pvalue->m.cFNPresent) {
      PU_PUSHNAME (pctxt, "cFN");

      stat = asn1PD_CFN (pctxt, &pvalue->cFN);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementAvailable: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementnotAvailable                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DedicatedMeasurementnotAvailable_ (ASN1CTXT* pctxt, void* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementnotAvailable: start\n");

   /* NULL */

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementnotAvailable: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementValueInformation                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DedicatedMeasurementValueInformation (ASN1CTXT* pctxt, DedicatedMeasurementValueInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementValueInformation: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* measurementAvailable */
      case 0:
         PU_PUSHNAME (pctxt, "u.measurementAvailable");

         pvalue->u.measurementAvailable = rtMemAllocTypeZ (pctxt, DedicatedMeasurementAvailable);
         if (pvalue->u.measurementAvailable == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_DedicatedMeasurementAvailable (pctxt, pvalue->u.measurementAvailable);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* measurementnotAvailable */
      case 1:
         PU_PUSHNAME (pctxt, "u.measurementnotAvailable");

         stat = asn1PD_DedicatedMeasurementnotAvailable (pctxt);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementValueInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_PDSCH_Start_code_number                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_PDSCH_Start_code_number (ASN1CTXT* pctxt, HS_PDSCH_Start_code_number* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_PDSCH_Start_code_number: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_PDSCH_Start_code_number: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_PDSCH_FDD_Code_Information                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_PDSCH_FDD_Code_Information (ASN1CTXT* pctxt, HS_PDSCH_FDD_Code_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_PDSCH_FDD_Code_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "hS_PDSCH_Start_code_numberPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hS_PDSCH_Start_code_numberPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode number_of_HS_PDSCH_codes */

   PU_PUSHNAME (pctxt, "number_of_HS_PDSCH_codes");

   stat = pd_ConsUInt8 (pctxt, &pvalue->number_of_HS_PDSCH_codes, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode hS_PDSCH_Start_code_number */

   if (pvalue->m.hS_PDSCH_Start_code_numberPresent) {
      PU_PUSHNAME (pctxt, "hS_PDSCH_Start_code_number");

      stat = asn1PD_HS_PDSCH_Start_code_number (pctxt, &pvalue->hS_PDSCH_Start_code_number);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_PDSCH_FDD_Code_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SCCH_FDD_Code_Information_Item                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SCCH_FDD_Code_Information_Item (ASN1CTXT* pctxt, HS_SCCH_FDD_Code_Information_Item* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_FDD_Code_Information_Item: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_FDD_Code_Information_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SCCH_FDD_Code_List                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SCCH_FDD_Code_List (ASN1CTXT* pctxt, HS_SCCH_FDD_Code_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_FDD_Code_List: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   if (32 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PD_HS_SCCH_FDD_Code_Information_Item (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_FDD_Code_List: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SCCH_FDD_Code_Information                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SCCH_FDD_Code_Information (ASN1CTXT* pctxt, HS_SCCH_FDD_Code_Information* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_FDD_Code_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* replace */
         case 0:
            PU_PUSHNAME (pctxt, "u.replace");

            pvalue->u.replace = rtMemAllocTypeZ (pctxt, HS_SCCH_FDD_Code_List);
            if (pvalue->u.replace == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_HS_SCCH_FDD_Code_List (pctxt, pvalue->u.replace);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* remove_ */
         case 1:
            PU_PUSHNAME (pctxt, "u.remove_");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_FDD_Code_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDSCHSet_ID                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PDSCHSet_ID (ASN1CTXT* pctxt, PDSCHSet_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCHSet_ID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCHSet_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDSCH_ID                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PDSCH_ID (ASN1CTXT* pctxt, PDSCH_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCH_ID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDSCH_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PUSCHSet_ID                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PUSCHSet_ID (ASN1CTXT* pctxt, PUSCHSet_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCHSet_ID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PUSCHSet_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaximumTransmissionPower                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MaximumTransmissionPower (ASN1CTXT* pctxt, MaximumTransmissionPower* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MaximumTransmissionPower: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(500));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_MaximumTransmissionPower: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SCCH_ID                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SCCH_ID (ASN1CTXT* pctxt, HS_SCCH_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_ID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(31));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SCCH_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CRNC_CommunicationContextID                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CRNC_CommunicationContextID (ASN1CTXT* pctxt, CRNC_CommunicationContextID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CRNC_CommunicationContextID: start\n");

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(1048575));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_CRNC_CommunicationContextID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NodeB_CommunicationContextID                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NodeB_CommunicationContextID (ASN1CTXT* pctxt, NodeB_CommunicationContextID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeB_CommunicationContextID: start\n");

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(1048575));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeB_CommunicationContextID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPSTOW                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPSTOW (ASN1CTXT* pctxt, GPSTOW* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPSTOW: start\n");

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(604799));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPSTOW: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Status_Health                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_Status_Health (ASN1CTXT* pctxt, GPS_Status_Health* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Status_Health: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = udre_scale_1dot0; break;
      case 1: *pvalue = udre_scale_0dot75; break;
      case 2: *pvalue = udre_scale_0dot5; break;
      case 3: *pvalue = udre_scale_0dot3; break;
      case 4: *pvalue = udre_scale_0dot1; break;
      case 5: *pvalue = no_data; break;
      case 6: *pvalue = invalid_data; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Status_Health: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_ID (ASN1CTXT* pctxt, SAT_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_ID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_DGPSCorrections_Item_iode_dgps                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_DGPSCorrections_Item_iode_dgps (ASN1CTXT* pctxt, SAT_Info_DGPSCorrections_Item_iode_dgps* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_DGPSCorrections_Item_iode_dgps: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_DGPSCorrections_Item_iode_dgps: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UDRE                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UDRE (ASN1CTXT* pctxt, UDRE* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_UDRE: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = udre_minusequal_one_m; break;
      case 1: *pvalue = udre_betweenoneandfour_m; break;
      case 2: *pvalue = udre_betweenfourandeight_m; break;
      case 3: *pvalue = udre_greaterequaleight_m; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UDRE: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PRC                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PRC (ASN1CTXT* pctxt, PRC* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PRC: start\n");

   stat = pd_ConsInt16 (pctxt, pvalue, OSINTCONST(-2047), OSINTCONST(2047));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PRC: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Range_Correction_Rate                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Range_Correction_Rate (ASN1CTXT* pctxt, Range_Correction_Rate* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Range_Correction_Rate: start\n");

   stat = pd_ConsInt8 (pctxt, pvalue, OSINTCONST(-127), OSINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Range_Correction_Rate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_DGPSCorrections_Item                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_DGPSCorrections_Item (ASN1CTXT* pctxt, SAT_Info_DGPSCorrections_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_DGPSCorrections_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ie_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode sat_id */

   PU_PUSHNAME (pctxt, "sat_id");

   stat = asn1PD_SAT_ID (pctxt, &pvalue->sat_id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iode_dgps */

   PU_PUSHNAME (pctxt, "iode_dgps");

   stat = asn1PD_SAT_Info_DGPSCorrections_Item_iode_dgps (pctxt, &pvalue->iode_dgps);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode udre */

   PU_PUSHNAME (pctxt, "udre");

   stat = asn1PD_UDRE (pctxt, &pvalue->udre);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode prc */

   PU_PUSHNAME (pctxt, "prc");

   stat = asn1PD_PRC (pctxt, &pvalue->prc);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode range_correction_rate */

   PU_PUSHNAME (pctxt, "range_correction_rate");

   stat = asn1PD_Range_Correction_Rate (pctxt, &pvalue->range_correction_rate);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_DGPSCorrections_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_DGPSCorrections                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_DGPSCorrections (ASN1CTXT* pctxt, SAT_Info_DGPSCorrections* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   SAT_Info_DGPSCorrections_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_DGPSCorrections: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SAT_Info_DGPSCorrections_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SAT_Info_DGPSCorrections_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_DGPSCorrections: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DGPSCorrections                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DGPSCorrections (ASN1CTXT* pctxt, DGPSCorrections* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DGPSCorrections: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ie_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode gpstow */

   PU_PUSHNAME (pctxt, "gpstow");

   stat = asn1PD_GPSTOW (pctxt, &pvalue->gpstow);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode status_health */

   PU_PUSHNAME (pctxt, "status_health");

   stat = asn1PD_GPS_Status_Health (pctxt, &pvalue->status_health);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode satelliteinfo */

   PU_PUSHNAME (pctxt, "satelliteinfo");

   stat = asn1PD_SAT_Info_DGPSCorrections (pctxt, &pvalue->satelliteinfo);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DGPSCorrections: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_tlm_message_nav                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_tlm_message_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_tlm_message_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(14), OSUINTCONST(14), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_tlm_message_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_tlm_message_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_tlm_revd_c_nav                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_tlm_revd_c_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_tlm_revd_c_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_tlm_revd_c_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_tlm_revd_c_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_ho_word_nav                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_ho_word_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_ho_word_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(22), OSUINTCONST(22), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_ho_word_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_ho_word_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_w_n_nav                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_w_n_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_w_n_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(10), OSUINTCONST(10), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_w_n_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_w_n_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_ca_or_p_on_l2_nav                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_ca_or_p_on_l2_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_ca_or_p_on_l2_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_ca_or_p_on_l2_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_ca_or_p_on_l2_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_user_range_accuracy_index_nav     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_user_range_accuracy_index_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_user_range_accuracy_index_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_user_range_accuracy_index_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_user_range_accuracy_index_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_sv_health_nav                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_sv_health_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_sv_health_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(6), OSUINTCONST(6), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_sv_health_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_sv_health_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_iodc_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_iodc_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_iodc_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(10), OSUINTCONST(10), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_iodc_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_iodc_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_l2_p_dataflag_nav                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_l2_p_dataflag_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_l2_p_dataflag_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_l2_p_dataflag_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_l2_p_dataflag_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_sf1_reserved_nav                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_sf1_reserved_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_sf1_reserved_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(87), OSUINTCONST(87), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_sf1_reserved_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_sf1_reserved_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_t_gd_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_t_gd_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_t_gd_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_t_gd_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_t_gd_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_t_oc_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_t_oc_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_t_oc_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_t_oc_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_t_oc_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_a_f_2_nav                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_a_f_2_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_a_f_2_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_a_f_2_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_a_f_2_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_a_f_1_nav                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_a_f_1_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_a_f_1_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_a_f_1_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_a_f_1_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_a_f_zero_nav                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_a_f_zero_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_a_f_zero_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(22), OSUINTCONST(22), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_a_f_zero_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_a_f_zero_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_c_rs_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_c_rs_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_c_rs_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_c_rs_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_c_rs_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_delta_n_nav                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_delta_n_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_delta_n_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_delta_n_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_delta_n_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_m_zero_nav                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_m_zero_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_m_zero_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_m_zero_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_m_zero_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_c_uc_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_c_uc_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_c_uc_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_c_uc_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_c_uc_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_gps_e_nav                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_gps_e_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_gps_e_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_gps_e_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_gps_e_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_c_us_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_c_us_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_c_us_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_c_us_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_c_us_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_a_sqrt_nav                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_a_sqrt_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_a_sqrt_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_a_sqrt_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_a_sqrt_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_t_oe_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_t_oe_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_t_oe_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_t_oe_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_t_oe_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_fit_interval_flag_nav             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_fit_interval_flag_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_fit_interval_flag_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_fit_interval_flag_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_fit_interval_flag_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_aodo_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_aodo_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_aodo_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(5), OSUINTCONST(5), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_aodo_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_aodo_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_c_ic_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_c_ic_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_c_ic_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_c_ic_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_c_ic_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_omega_zero_nav                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_omega_zero_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_omega_zero_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_omega_zero_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_omega_zero_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_c_is_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_c_is_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_c_is_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_c_is_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_c_is_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_i_zero_nav                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_i_zero_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_i_zero_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_i_zero_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_i_zero_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_c_rc_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_c_rc_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_c_rc_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_c_rc_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_c_rc_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_gps_omega_nav                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_gps_omega_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_gps_omega_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_gps_omega_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_gps_omega_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_omegadot_nav                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_omegadot_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_omegadot_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_omegadot_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_omegadot_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_idot_nav                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_idot_nav (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_idot_nav* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(14), OSUINTCONST(14), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_idot_nav: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_idot_nav: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item_spare_zero_fill                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item_spare_zero_fill (ASN1CTXT* pctxt, GPS_NavandRecovery_Item_spare_zero_fill* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(20), OSUINTCONST(20), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_spare_zero_fill: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item_spare_zero_fill: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavandRecovery_Item                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavandRecovery_Item (ASN1CTXT* pctxt, GPS_NavandRecovery_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ie_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode tx_tow_nav */

   PU_PUSHNAME (pctxt, "tx_tow_nav");

   stat = pd_ConsUnsigned (pctxt, &pvalue->tx_tow_nav, OSUINTCONST(0), OSUINTCONST(1048575));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sat_id_nav */

   PU_PUSHNAME (pctxt, "sat_id_nav");

   stat = asn1PD_SAT_ID (pctxt, &pvalue->sat_id_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tlm_message_nav */

   PU_PUSHNAME (pctxt, "tlm_message_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_tlm_message_nav (pctxt, &pvalue->tlm_message_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tlm_revd_c_nav */

   PU_PUSHNAME (pctxt, "tlm_revd_c_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_tlm_revd_c_nav (pctxt, &pvalue->tlm_revd_c_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ho_word_nav */

   PU_PUSHNAME (pctxt, "ho_word_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_ho_word_nav (pctxt, &pvalue->ho_word_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode w_n_nav */

   PU_PUSHNAME (pctxt, "w_n_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_w_n_nav (pctxt, &pvalue->w_n_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ca_or_p_on_l2_nav */

   PU_PUSHNAME (pctxt, "ca_or_p_on_l2_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_ca_or_p_on_l2_nav (pctxt, &pvalue->ca_or_p_on_l2_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode user_range_accuracy_index_nav */

   PU_PUSHNAME (pctxt, "user_range_accuracy_index_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_user_range_accuracy_index_nav (pctxt, &pvalue->user_range_accuracy_index_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sv_health_nav */

   PU_PUSHNAME (pctxt, "sv_health_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_sv_health_nav (pctxt, &pvalue->sv_health_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iodc_nav */

   PU_PUSHNAME (pctxt, "iodc_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_iodc_nav (pctxt, &pvalue->iodc_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode l2_p_dataflag_nav */

   PU_PUSHNAME (pctxt, "l2_p_dataflag_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_l2_p_dataflag_nav (pctxt, &pvalue->l2_p_dataflag_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sf1_reserved_nav */

   PU_PUSHNAME (pctxt, "sf1_reserved_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_sf1_reserved_nav (pctxt, &pvalue->sf1_reserved_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode t_gd_nav */

   PU_PUSHNAME (pctxt, "t_gd_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_t_gd_nav (pctxt, &pvalue->t_gd_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode t_oc_nav */

   PU_PUSHNAME (pctxt, "t_oc_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_t_oc_nav (pctxt, &pvalue->t_oc_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode a_f_2_nav */

   PU_PUSHNAME (pctxt, "a_f_2_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_a_f_2_nav (pctxt, &pvalue->a_f_2_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode a_f_1_nav */

   PU_PUSHNAME (pctxt, "a_f_1_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_a_f_1_nav (pctxt, &pvalue->a_f_1_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode a_f_zero_nav */

   PU_PUSHNAME (pctxt, "a_f_zero_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_a_f_zero_nav (pctxt, &pvalue->a_f_zero_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode c_rs_nav */

   PU_PUSHNAME (pctxt, "c_rs_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_c_rs_nav (pctxt, &pvalue->c_rs_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode delta_n_nav */

   PU_PUSHNAME (pctxt, "delta_n_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_delta_n_nav (pctxt, &pvalue->delta_n_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode m_zero_nav */

   PU_PUSHNAME (pctxt, "m_zero_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_m_zero_nav (pctxt, &pvalue->m_zero_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode c_uc_nav */

   PU_PUSHNAME (pctxt, "c_uc_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_c_uc_nav (pctxt, &pvalue->c_uc_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode gps_e_nav */

   PU_PUSHNAME (pctxt, "gps_e_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_gps_e_nav (pctxt, &pvalue->gps_e_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode c_us_nav */

   PU_PUSHNAME (pctxt, "c_us_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_c_us_nav (pctxt, &pvalue->c_us_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode a_sqrt_nav */

   PU_PUSHNAME (pctxt, "a_sqrt_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_a_sqrt_nav (pctxt, &pvalue->a_sqrt_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode t_oe_nav */

   PU_PUSHNAME (pctxt, "t_oe_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_t_oe_nav (pctxt, &pvalue->t_oe_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode fit_interval_flag_nav */

   PU_PUSHNAME (pctxt, "fit_interval_flag_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_fit_interval_flag_nav (pctxt, &pvalue->fit_interval_flag_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode aodo_nav */

   PU_PUSHNAME (pctxt, "aodo_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_aodo_nav (pctxt, &pvalue->aodo_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode c_ic_nav */

   PU_PUSHNAME (pctxt, "c_ic_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_c_ic_nav (pctxt, &pvalue->c_ic_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode omega_zero_nav */

   PU_PUSHNAME (pctxt, "omega_zero_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_omega_zero_nav (pctxt, &pvalue->omega_zero_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode c_is_nav */

   PU_PUSHNAME (pctxt, "c_is_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_c_is_nav (pctxt, &pvalue->c_is_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode i_zero_nav */

   PU_PUSHNAME (pctxt, "i_zero_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_i_zero_nav (pctxt, &pvalue->i_zero_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode c_rc_nav */

   PU_PUSHNAME (pctxt, "c_rc_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_c_rc_nav (pctxt, &pvalue->c_rc_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode gps_omega_nav */

   PU_PUSHNAME (pctxt, "gps_omega_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_gps_omega_nav (pctxt, &pvalue->gps_omega_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode omegadot_nav */

   PU_PUSHNAME (pctxt, "omegadot_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_omegadot_nav (pctxt, &pvalue->omegadot_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode idot_nav */

   PU_PUSHNAME (pctxt, "idot_nav");

   stat = asn1PD_GPS_NavandRecovery_Item_idot_nav (pctxt, &pvalue->idot_nav);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode spare_zero_fill */

   PU_PUSHNAME (pctxt, "spare_zero_fill");

   stat = asn1PD_GPS_NavandRecovery_Item_spare_zero_fill (pctxt, &pvalue->spare_zero_fill);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavandRecovery_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_NavigationModel_and_TimeRecovery                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_NavigationModel_and_TimeRecovery (ASN1CTXT* pctxt, GPS_NavigationModel_and_TimeRecovery* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   GPS_NavandRecovery_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavigationModel_and_TimeRecovery: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, GPS_NavandRecovery_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_GPS_NavandRecovery_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_NavigationModel_and_TimeRecovery: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Ionospheric_Model_alpha_zero_ionos                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_Ionospheric_Model_alpha_zero_ionos (ASN1CTXT* pctxt, GPS_Ionospheric_Model_alpha_zero_ionos* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Ionospheric_Model_alpha_zero_ionos: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Ionospheric_Model_alpha_zero_ionos: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Ionospheric_Model_alpha_one_ionos                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_Ionospheric_Model_alpha_one_ionos (ASN1CTXT* pctxt, GPS_Ionospheric_Model_alpha_one_ionos* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Ionospheric_Model_alpha_one_ionos: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Ionospheric_Model_alpha_one_ionos: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Ionospheric_Model_alpha_two_ionos                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_Ionospheric_Model_alpha_two_ionos (ASN1CTXT* pctxt, GPS_Ionospheric_Model_alpha_two_ionos* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Ionospheric_Model_alpha_two_ionos: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Ionospheric_Model_alpha_two_ionos: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Ionospheric_Model_alpha_three_ionos                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_Ionospheric_Model_alpha_three_ionos (ASN1CTXT* pctxt, GPS_Ionospheric_Model_alpha_three_ionos* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Ionospheric_Model_alpha_three_ionos: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Ionospheric_Model_alpha_three_ionos: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Ionospheric_Model_beta_zero_ionos                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_Ionospheric_Model_beta_zero_ionos (ASN1CTXT* pctxt, GPS_Ionospheric_Model_beta_zero_ionos* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Ionospheric_Model_beta_zero_ionos: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Ionospheric_Model_beta_zero_ionos: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Ionospheric_Model_beta_one_ionos                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_Ionospheric_Model_beta_one_ionos (ASN1CTXT* pctxt, GPS_Ionospheric_Model_beta_one_ionos* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Ionospheric_Model_beta_one_ionos: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Ionospheric_Model_beta_one_ionos: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Ionospheric_Model_beta_two_ionos                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_Ionospheric_Model_beta_two_ionos (ASN1CTXT* pctxt, GPS_Ionospheric_Model_beta_two_ionos* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Ionospheric_Model_beta_two_ionos: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Ionospheric_Model_beta_two_ionos: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Ionospheric_Model_beta_three_ionos                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_Ionospheric_Model_beta_three_ionos (ASN1CTXT* pctxt, GPS_Ionospheric_Model_beta_three_ionos* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Ionospheric_Model_beta_three_ionos: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Ionospheric_Model_beta_three_ionos: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Ionospheric_Model                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_Ionospheric_Model (ASN1CTXT* pctxt, GPS_Ionospheric_Model* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Ionospheric_Model: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ie_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode alpha_zero_ionos */

   PU_PUSHNAME (pctxt, "alpha_zero_ionos");

   stat = asn1PD_GPS_Ionospheric_Model_alpha_zero_ionos (pctxt, &pvalue->alpha_zero_ionos);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode alpha_one_ionos */

   PU_PUSHNAME (pctxt, "alpha_one_ionos");

   stat = asn1PD_GPS_Ionospheric_Model_alpha_one_ionos (pctxt, &pvalue->alpha_one_ionos);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode alpha_two_ionos */

   PU_PUSHNAME (pctxt, "alpha_two_ionos");

   stat = asn1PD_GPS_Ionospheric_Model_alpha_two_ionos (pctxt, &pvalue->alpha_two_ionos);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode alpha_three_ionos */

   PU_PUSHNAME (pctxt, "alpha_three_ionos");

   stat = asn1PD_GPS_Ionospheric_Model_alpha_three_ionos (pctxt, &pvalue->alpha_three_ionos);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode beta_zero_ionos */

   PU_PUSHNAME (pctxt, "beta_zero_ionos");

   stat = asn1PD_GPS_Ionospheric_Model_beta_zero_ionos (pctxt, &pvalue->beta_zero_ionos);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode beta_one_ionos */

   PU_PUSHNAME (pctxt, "beta_one_ionos");

   stat = asn1PD_GPS_Ionospheric_Model_beta_one_ionos (pctxt, &pvalue->beta_one_ionos);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode beta_two_ionos */

   PU_PUSHNAME (pctxt, "beta_two_ionos");

   stat = asn1PD_GPS_Ionospheric_Model_beta_two_ionos (pctxt, &pvalue->beta_two_ionos);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode beta_three_ionos */

   PU_PUSHNAME (pctxt, "beta_three_ionos");

   stat = asn1PD_GPS_Ionospheric_Model_beta_three_ionos (pctxt, &pvalue->beta_three_ionos);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Ionospheric_Model: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_UTC_Model_a_one_utc                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_UTC_Model_a_one_utc (ASN1CTXT* pctxt, GPS_UTC_Model_a_one_utc* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_UTC_Model_a_one_utc: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_UTC_Model_a_one_utc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_UTC_Model_a_zero_utc                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_UTC_Model_a_zero_utc (ASN1CTXT* pctxt, GPS_UTC_Model_a_zero_utc* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_UTC_Model_a_zero_utc: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_UTC_Model_a_zero_utc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_UTC_Model_t_ot_utc                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_UTC_Model_t_ot_utc (ASN1CTXT* pctxt, GPS_UTC_Model_t_ot_utc* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_UTC_Model_t_ot_utc: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_UTC_Model_t_ot_utc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_UTC_Model_delta_t_ls_utc                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_UTC_Model_delta_t_ls_utc (ASN1CTXT* pctxt, GPS_UTC_Model_delta_t_ls_utc* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_UTC_Model_delta_t_ls_utc: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_UTC_Model_delta_t_ls_utc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_UTC_Model_w_n_t_utc                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_UTC_Model_w_n_t_utc (ASN1CTXT* pctxt, GPS_UTC_Model_w_n_t_utc* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_UTC_Model_w_n_t_utc: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_UTC_Model_w_n_t_utc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_UTC_Model_w_n_lsf_utc                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_UTC_Model_w_n_lsf_utc (ASN1CTXT* pctxt, GPS_UTC_Model_w_n_lsf_utc* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_UTC_Model_w_n_lsf_utc: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_UTC_Model_w_n_lsf_utc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_UTC_Model_dn_utc                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_UTC_Model_dn_utc (ASN1CTXT* pctxt, GPS_UTC_Model_dn_utc* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_UTC_Model_dn_utc: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_UTC_Model_dn_utc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_UTC_Model_delta_t_lsf_utc                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_UTC_Model_delta_t_lsf_utc (ASN1CTXT* pctxt, GPS_UTC_Model_delta_t_lsf_utc* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_UTC_Model_delta_t_lsf_utc: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_UTC_Model_delta_t_lsf_utc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_UTC_Model                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_UTC_Model (ASN1CTXT* pctxt, GPS_UTC_Model* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_UTC_Model: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ie_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode a_one_utc */

   PU_PUSHNAME (pctxt, "a_one_utc");

   stat = asn1PD_GPS_UTC_Model_a_one_utc (pctxt, &pvalue->a_one_utc);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode a_zero_utc */

   PU_PUSHNAME (pctxt, "a_zero_utc");

   stat = asn1PD_GPS_UTC_Model_a_zero_utc (pctxt, &pvalue->a_zero_utc);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode t_ot_utc */

   PU_PUSHNAME (pctxt, "t_ot_utc");

   stat = asn1PD_GPS_UTC_Model_t_ot_utc (pctxt, &pvalue->t_ot_utc);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode delta_t_ls_utc */

   PU_PUSHNAME (pctxt, "delta_t_ls_utc");

   stat = asn1PD_GPS_UTC_Model_delta_t_ls_utc (pctxt, &pvalue->delta_t_ls_utc);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode w_n_t_utc */

   PU_PUSHNAME (pctxt, "w_n_t_utc");

   stat = asn1PD_GPS_UTC_Model_w_n_t_utc (pctxt, &pvalue->w_n_t_utc);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode w_n_lsf_utc */

   PU_PUSHNAME (pctxt, "w_n_lsf_utc");

   stat = asn1PD_GPS_UTC_Model_w_n_lsf_utc (pctxt, &pvalue->w_n_lsf_utc);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dn_utc */

   PU_PUSHNAME (pctxt, "dn_utc");

   stat = asn1PD_GPS_UTC_Model_dn_utc (pctxt, &pvalue->dn_utc);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode delta_t_lsf_utc */

   PU_PUSHNAME (pctxt, "delta_t_lsf_utc");

   stat = asn1PD_GPS_UTC_Model_delta_t_lsf_utc (pctxt, &pvalue->delta_t_lsf_utc);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_UTC_Model: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Almanac_wna_alm                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_Almanac_wna_alm (ASN1CTXT* pctxt, GPS_Almanac_wna_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Almanac_wna_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Almanac_wna_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DATA_ID                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DATA_ID (ASN1CTXT* pctxt, DATA_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DATA_ID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(3));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DATA_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_gps_e_alm                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_Item_gps_e_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_gps_e_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_gps_e_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_gps_e_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_gps_toa_alm                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_Item_gps_toa_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_gps_toa_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_gps_toa_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_gps_toa_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_gps_delta_I_alm                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_Item_gps_delta_I_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_gps_delta_I_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_gps_delta_I_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_gps_delta_I_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_omegadot_alm                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_Item_omegadot_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_omegadot_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_omegadot_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_omegadot_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_svhealth_alm                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_Item_svhealth_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_svhealth_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_svhealth_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_svhealth_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_gps_a_sqrt_alm                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_Item_gps_a_sqrt_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_gps_a_sqrt_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_gps_a_sqrt_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_gps_a_sqrt_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_omegazero_alm                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_Item_omegazero_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_omegazero_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_omegazero_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_omegazero_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_m_zero_alm                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_Item_m_zero_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_m_zero_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_m_zero_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_m_zero_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_gps_omega_alm                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_Item_gps_omega_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_gps_omega_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_gps_omega_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_gps_omega_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_gps_af_zero_alm                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_Item_gps_af_zero_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_gps_af_zero_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(11), OSUINTCONST(11), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_gps_af_zero_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_gps_af_zero_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item_gps_af_one_alm                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_Item_gps_af_one_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_Item_gps_af_one_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(11), OSUINTCONST(11), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_gps_af_one_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item_gps_af_one_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_Item                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_Item (ASN1CTXT* pctxt, SAT_Info_Almanac_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ie_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode data_id */

   PU_PUSHNAME (pctxt, "data_id");

   stat = asn1PD_DATA_ID (pctxt, &pvalue->data_id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sat_id */

   PU_PUSHNAME (pctxt, "sat_id");

   stat = asn1PD_SAT_ID (pctxt, &pvalue->sat_id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode gps_e_alm */

   PU_PUSHNAME (pctxt, "gps_e_alm");

   stat = asn1PD_SAT_Info_Almanac_Item_gps_e_alm (pctxt, &pvalue->gps_e_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode gps_toa_alm */

   PU_PUSHNAME (pctxt, "gps_toa_alm");

   stat = asn1PD_SAT_Info_Almanac_Item_gps_toa_alm (pctxt, &pvalue->gps_toa_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode gps_delta_I_alm */

   PU_PUSHNAME (pctxt, "gps_delta_I_alm");

   stat = asn1PD_SAT_Info_Almanac_Item_gps_delta_I_alm (pctxt, &pvalue->gps_delta_I_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode omegadot_alm */

   PU_PUSHNAME (pctxt, "omegadot_alm");

   stat = asn1PD_SAT_Info_Almanac_Item_omegadot_alm (pctxt, &pvalue->omegadot_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode svhealth_alm */

   PU_PUSHNAME (pctxt, "svhealth_alm");

   stat = asn1PD_SAT_Info_Almanac_Item_svhealth_alm (pctxt, &pvalue->svhealth_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode gps_a_sqrt_alm */

   PU_PUSHNAME (pctxt, "gps_a_sqrt_alm");

   stat = asn1PD_SAT_Info_Almanac_Item_gps_a_sqrt_alm (pctxt, &pvalue->gps_a_sqrt_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode omegazero_alm */

   PU_PUSHNAME (pctxt, "omegazero_alm");

   stat = asn1PD_SAT_Info_Almanac_Item_omegazero_alm (pctxt, &pvalue->omegazero_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode m_zero_alm */

   PU_PUSHNAME (pctxt, "m_zero_alm");

   stat = asn1PD_SAT_Info_Almanac_Item_m_zero_alm (pctxt, &pvalue->m_zero_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode gps_omega_alm */

   PU_PUSHNAME (pctxt, "gps_omega_alm");

   stat = asn1PD_SAT_Info_Almanac_Item_gps_omega_alm (pctxt, &pvalue->gps_omega_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode gps_af_zero_alm */

   PU_PUSHNAME (pctxt, "gps_af_zero_alm");

   stat = asn1PD_SAT_Info_Almanac_Item_gps_af_zero_alm (pctxt, &pvalue->gps_af_zero_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode gps_af_one_alm */

   PU_PUSHNAME (pctxt, "gps_af_one_alm");

   stat = asn1PD_SAT_Info_Almanac_Item_gps_af_one_alm (pctxt, &pvalue->gps_af_one_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac (ASN1CTXT* pctxt, SAT_Info_Almanac* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   SAT_Info_Almanac_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SAT_Info_Almanac_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SAT_Info_Almanac_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Almanac_sVGlobalHealth_alm                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_Almanac_sVGlobalHealth_alm (ASN1CTXT* pctxt, GPS_Almanac_sVGlobalHealth_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(364), OSUINTCONST(364), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Almanac_sVGlobalHealth_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Almanac_sVGlobalHealth_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Almanac                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_Almanac (ASN1CTXT* pctxt, GPS_Almanac* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Almanac: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "sVGlobalHealth_almPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sVGlobalHealth_almPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ie_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode wna_alm */

   PU_PUSHNAME (pctxt, "wna_alm");

   stat = asn1PD_GPS_Almanac_wna_alm (pctxt, &pvalue->wna_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sat_info_almanac */

   PU_PUSHNAME (pctxt, "sat_info_almanac");

   stat = asn1PD_SAT_Info_Almanac (pctxt, &pvalue->sat_info_almanac);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sVGlobalHealth_alm */

   if (pvalue->m.sVGlobalHealth_almPresent) {
      PU_PUSHNAME (pctxt, "sVGlobalHealth_alm");

      stat = asn1PD_GPS_Almanac_sVGlobalHealth_alm (pctxt, &pvalue->sVGlobalHealth_alm);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Almanac: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_RealTime_Integrity_Item                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_RealTime_Integrity_Item (ASN1CTXT* pctxt, SAT_Info_RealTime_Integrity_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_RealTime_Integrity_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ie_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode bad_sat_id */

   PU_PUSHNAME (pctxt, "bad_sat_id");

   stat = asn1PD_SAT_ID (pctxt, &pvalue->bad_sat_id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_RealTime_Integrity_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SATInfo_RealTime_Integrity                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SATInfo_RealTime_Integrity (ASN1CTXT* pctxt, SATInfo_RealTime_Integrity* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   SAT_Info_RealTime_Integrity_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_SATInfo_RealTime_Integrity: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SAT_Info_RealTime_Integrity_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SAT_Info_RealTime_Integrity_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SATInfo_RealTime_Integrity: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPSBadSat_Info_RealTime_Integrity                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPSBadSat_Info_RealTime_Integrity (ASN1CTXT* pctxt, GPSBadSat_Info_RealTime_Integrity* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPSBadSat_Info_RealTime_Integrity: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ie_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode sat_info */

   PU_PUSHNAME (pctxt, "sat_info");

   stat = asn1PD_SATInfo_RealTime_Integrity (pctxt, &pvalue->sat_info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GPSBadSat_Info_RealTime_Integrity: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_RealTime_Integrity                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_RealTime_Integrity (ASN1CTXT* pctxt, GPS_RealTime_Integrity* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_RealTime_Integrity: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* bad_satellites */
      case 0:
         PU_PUSHNAME (pctxt, "u.bad_satellites");

         pvalue->u.bad_satellites = rtMemAllocTypeZ (pctxt, GPSBadSat_Info_RealTime_Integrity);
         if (pvalue->u.bad_satellites == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_GPSBadSat_Info_RealTime_Integrity (pctxt, pvalue->u.bad_satellites);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* no_bad_satellites */
      case 1:
         PU_PUSHNAME (pctxt, "u.no_bad_satellites");

         /* NULL */

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_RealTime_Integrity: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_RX_POS_latitudeSign                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_RX_POS_latitudeSign (ASN1CTXT* pctxt, GPS_RX_POS_latitudeSign* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_RX_POS_latitudeSign: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = north; break;
      case 1: *pvalue = south; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_RX_POS_latitudeSign: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_RX_POS_directionOfAltitude                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_RX_POS_directionOfAltitude (ASN1CTXT* pctxt, GPS_RX_POS_directionOfAltitude* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_RX_POS_directionOfAltitude: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = height; break;
      case 1: *pvalue = depth; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_RX_POS_directionOfAltitude: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_RX_POS                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_RX_POS (ASN1CTXT* pctxt, GPS_RX_POS* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_RX_POS: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode latitudeSign */

   PU_PUSHNAME (pctxt, "latitudeSign");

   stat = asn1PD_GPS_RX_POS_latitudeSign (pctxt, &pvalue->latitudeSign);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode latitude */

   PU_PUSHNAME (pctxt, "latitude");

   stat = pd_ConsUnsigned (pctxt, &pvalue->latitude, OSUINTCONST(0), OSUINTCONST(8388607));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode longitude */

   PU_PUSHNAME (pctxt, "longitude");

   stat = pd_ConsInteger (pctxt, &pvalue->longitude, OSINTCONST(-8388608), OSINTCONST(8388607));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode directionOfAltitude */

   PU_PUSHNAME (pctxt, "directionOfAltitude");

   stat = asn1PD_GPS_RX_POS_directionOfAltitude (pctxt, &pvalue->directionOfAltitude);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode altitude */

   PU_PUSHNAME (pctxt, "altitude");

   stat = pd_ConsUInt16 (pctxt, &pvalue->altitude, OSUINTCONST(0), OSUINTCONST(32767));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_RX_POS: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestedDataValue                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RequestedDataValue (ASN1CTXT* pctxt, RequestedDataValue* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RequestedDataValue: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dgps_correctionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dgps_correctionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "gps_navandrecoveryPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.gps_navandrecoveryPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "gps_ionos_modelPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.gps_ionos_modelPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "gps_utc_modelPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.gps_utc_modelPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "gps_almanacPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.gps_almanacPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "gps_rt_integrityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.gps_rt_integrityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "gpsrxposPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.gpsrxposPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dgps_corrections */

   if (pvalue->m.dgps_correctionsPresent) {
      PU_PUSHNAME (pctxt, "dgps_corrections");

      stat = asn1PD_DGPSCorrections (pctxt, &pvalue->dgps_corrections);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode gps_navandrecovery */

   if (pvalue->m.gps_navandrecoveryPresent) {
      PU_PUSHNAME (pctxt, "gps_navandrecovery");

      stat = asn1PD_GPS_NavigationModel_and_TimeRecovery (pctxt, &pvalue->gps_navandrecovery);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode gps_ionos_model */

   if (pvalue->m.gps_ionos_modelPresent) {
      PU_PUSHNAME (pctxt, "gps_ionos_model");

      stat = asn1PD_GPS_Ionospheric_Model (pctxt, &pvalue->gps_ionos_model);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode gps_utc_model */

   if (pvalue->m.gps_utc_modelPresent) {
      PU_PUSHNAME (pctxt, "gps_utc_model");

      stat = asn1PD_GPS_UTC_Model (pctxt, &pvalue->gps_utc_model);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode gps_almanac */

   if (pvalue->m.gps_almanacPresent) {
      PU_PUSHNAME (pctxt, "gps_almanac");

      stat = asn1PD_GPS_Almanac (pctxt, &pvalue->gps_almanac);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode gps_rt_integrity */

   if (pvalue->m.gps_rt_integrityPresent) {
      PU_PUSHNAME (pctxt, "gps_rt_integrity");

      stat = asn1PD_GPS_RealTime_Integrity (pctxt, &pvalue->gps_rt_integrity);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode gpsrxpos */

   if (pvalue->m.gpsrxposPresent) {
      PU_PUSHNAME (pctxt, "gpsrxpos");

      stat = asn1PD_GPS_RX_POS (pctxt, &pvalue->gpsrxpos);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RequestedDataValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationAvailable                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationAvailable (ASN1CTXT* pctxt, InformationAvailable* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationAvailable: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ie_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode requesteddataValue */

   PU_PUSHNAME (pctxt, "requesteddataValue");

   stat = asn1PD_RequestedDataValue (pctxt, &pvalue->requesteddataValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationAvailable: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationnotAvailable                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationnotAvailable_ (ASN1CTXT* pctxt, void* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationnotAvailable: start\n");

   /* NULL */

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationnotAvailable: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestedDataValueInformation                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RequestedDataValueInformation (ASN1CTXT* pctxt, RequestedDataValueInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_RequestedDataValueInformation: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* informationAvailable */
      case 0:
         PU_PUSHNAME (pctxt, "u.informationAvailable");

         pvalue->u.informationAvailable = rtMemAllocTypeZ (pctxt, InformationAvailable);
         if (pvalue->u.informationAvailable == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_InformationAvailable (pctxt, pvalue->u.informationAvailable);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* informationnotAvailable */
      case 1:
         PU_PUSHNAME (pctxt, "u.informationnotAvailable");

         stat = asn1PD_InformationnotAvailable (pctxt);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RequestedDataValueInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CSBTransmissionID                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CSBTransmissionID (ASN1CTXT* pctxt, CSBTransmissionID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CSBTransmissionID: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_CSBTransmissionID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFN                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SFN (ASN1CTXT* pctxt, SFN* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SFN: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(4095));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SFN: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstCode                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstCode (ASN1CTXT* pctxt, CellSyncBurstCode* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstCode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstCode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstCodeShift                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstCodeShift (ASN1CTXT* pctxt, CellSyncBurstCodeShift* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstCodeShift: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstCodeShift: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CSBMeasurementID                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CSBMeasurementID (ASN1CTXT* pctxt, CSBMeasurementID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CSBMeasurementID: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_CSBMeasurementID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynchronisationReportType                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SynchronisationReportType (ASN1CTXT* pctxt, SynchronisationReportType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationReportType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = initialPhase; break;
         case 1: *pvalue = steadyStatePhase; break;
         case 2: *pvalue = lateEntrantCell; break;
         case 3: *pvalue = frequencyAcquisition; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationReportType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynchronisationReportCharacteristicsType                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SynchronisationReportCharacteristicsType (ASN1CTXT* pctxt, SynchronisationReportCharacteristicsType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationReportCharacteristicsType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = frameRelated; break;
         case 1: *pvalue = sFNperiodRelated; break;
         case 2: *pvalue = cycleLengthRelated; break;
         case 3: *pvalue = thresholdExceeding; break;
         case 4: *pvalue = frequencyAcquisitionCompleted; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationReportCharacteristicsType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncFrameNumber                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SyncFrameNumber (ASN1CTXT* pctxt, SyncFrameNumber* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncFrameNumber: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(10));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncFrameNumber: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstTiming                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstTiming (ASN1CTXT* pctxt, CellSyncBurstTiming* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstTiming: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* initialPhase */
      case 0:
         PU_PUSHNAME (pctxt, "u.initialPhase");

         /* extension bit */

         PU_NEWFIELD (pctxt, "extension marker");

         stat = PD_BIT (pctxt, &extbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_SETBITCOUNT (pctxt);

         if (extbit == 0) {
            stat = pd_ConsInteger (pctxt, &pvalue->u.initialPhase, OSINTCONST(0), OSINTCONST(1048575));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else {
            stat = pd_UnconsInteger (pctxt, &pvalue->u.initialPhase);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }

         PU_POPNAME (pctxt);

         break;

      /* steadyStatePhase */
      case 1:
         PU_PUSHNAME (pctxt, "u.steadyStatePhase");

         /* extension bit */

         PU_NEWFIELD (pctxt, "extension marker");

         stat = PD_BIT (pctxt, &extbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_SETBITCOUNT (pctxt);

         if (extbit == 0) {
            stat = pd_ConsInteger (pctxt, &pvalue->u.steadyStatePhase, OSINTCONST(0), OSINTCONST(255));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else {
            stat = pd_UnconsInteger (pctxt, &pvalue->u.steadyStatePhase);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstTiming: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstTimingThreshold                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstTimingThreshold (ASN1CTXT* pctxt, CellSyncBurstTimingThreshold* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstTimingThreshold: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(254));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstTimingThreshold: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynchronisationReportCharactCellSyncBurstInfoItem         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SynchronisationReportCharactCellSyncBurstInfoItem (ASN1CTXT* pctxt, SynchronisationReportCharactCellSyncBurstInfoItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationReportCharactCellSyncBurstInfoItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "cellSyncBurstTimingPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cellSyncBurstTimingPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cellSyncBurstTimingThresholdPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cellSyncBurstTimingThresholdPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cellSyncBurstCode */

   PU_PUSHNAME (pctxt, "cellSyncBurstCode");

   stat = asn1PD_CellSyncBurstCode (pctxt, &pvalue->cellSyncBurstCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cellSyncBurstCodeShift */

   PU_PUSHNAME (pctxt, "cellSyncBurstCodeShift");

   stat = asn1PD_CellSyncBurstCodeShift (pctxt, &pvalue->cellSyncBurstCodeShift);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cellSyncBurstTiming */

   if (pvalue->m.cellSyncBurstTimingPresent) {
      PU_PUSHNAME (pctxt, "cellSyncBurstTiming");

      stat = asn1PD_CellSyncBurstTiming (pctxt, &pvalue->cellSyncBurstTiming);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode cellSyncBurstTimingThreshold */

   if (pvalue->m.cellSyncBurstTimingThresholdPresent) {
      PU_PUSHNAME (pctxt, "cellSyncBurstTimingThreshold");

      stat = asn1PD_CellSyncBurstTimingThreshold (pctxt, &pvalue->cellSyncBurstTimingThreshold);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationReportCharactCellSyncBurstInfoItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynchronisationReportCharactThreInfoItem_cellSyncBurstIn  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SynchronisationReportCharactThreInfoItem_cellSyncBurstInformation (ASN1CTXT* pctxt, SynchronisationReportCharactThreInfoItem_cellSyncBurstInformation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   SynchronisationReportCharactCellSyncBurstInfoItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationReportCharactThreInfoItem_cellSyncBurstInformation: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SynchronisationReportCharactCellSyncBurstInfoItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SynchronisationReportCharactCellSyncBurstInfoItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationReportCharactThreInfoItem_cellSyncBurstInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynchronisationReportCharactThreInfoItem                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SynchronisationReportCharactThreInfoItem (ASN1CTXT* pctxt, SynchronisationReportCharactThreInfoItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationReportCharactThreInfoItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode syncFrameNumber */

   PU_PUSHNAME (pctxt, "syncFrameNumber");

   stat = asn1PD_SyncFrameNumber (pctxt, &pvalue->syncFrameNumber);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cellSyncBurstInformation */

   PU_PUSHNAME (pctxt, "cellSyncBurstInformation");

   stat = asn1PD_SynchronisationReportCharactThreInfoItem_cellSyncBurstInformation (pctxt, &pvalue->cellSyncBurstInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationReportCharactThreInfoItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynchronisationReportCharactThreExc                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SynchronisationReportCharactThreExc (ASN1CTXT* pctxt, SynchronisationReportCharactThreExc* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(10), 0 };
   int stat = 0;
   SynchronisationReportCharactThreInfoItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationReportCharactThreExc: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SynchronisationReportCharactThreInfoItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SynchronisationReportCharactThreInfoItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationReportCharactThreExc: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynchronisationReportCharacteristics                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SynchronisationReportCharacteristics (ASN1CTXT* pctxt, SynchronisationReportCharacteristics* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationReportCharacteristics: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "synchronisationReportCharactThreExcPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.synchronisationReportCharactThreExcPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode synchronisationReportCharacteristicsType */

   PU_PUSHNAME (pctxt, "synchronisationReportCharacteristicsType");

   stat = asn1PD_SynchronisationReportCharacteristicsType (pctxt, &pvalue->synchronisationReportCharacteristicsType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode synchronisationReportCharactThreExc */

   if (pvalue->m.synchronisationReportCharactThreExcPresent) {
      PU_PUSHNAME (pctxt, "synchronisationReportCharactThreExc");

      stat = asn1PD_SynchronisationReportCharactThreExc (pctxt, &pvalue->synchronisationReportCharactThreExc);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationReportCharacteristics: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UARFCN                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UARFCN (ASN1CTXT* pctxt, UARFCN* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UARFCN: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(16383));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UARFCN: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SYNCDlCodeId                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SYNCDlCodeId (ASN1CTXT* pctxt, SYNCDlCodeId* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeId: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(1), OSINTCONST(32));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SYNCDlCodeId: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimingAdjustmentValueLCR                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TimingAdjustmentValueLCR (ASN1CTXT* pctxt, TimingAdjustmentValueLCR* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TimingAdjustmentValueLCR: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* initialPhase */
      case 0:
         PU_PUSHNAME (pctxt, "u.initialPhase");

         /* extension bit */

         PU_NEWFIELD (pctxt, "extension marker");

         stat = PD_BIT (pctxt, &extbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_SETBITCOUNT (pctxt);

         if (extbit == 0) {
            stat = pd_ConsInteger (pctxt, &pvalue->u.initialPhase, OSINTCONST(0), OSINTCONST(524287));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else {
            stat = pd_UnconsInteger (pctxt, &pvalue->u.initialPhase);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }

         PU_POPNAME (pctxt);

         break;

      /* steadyStatePhase */
      case 1:
         PU_PUSHNAME (pctxt, "u.steadyStatePhase");

         /* extension bit */

         PU_NEWFIELD (pctxt, "extension marker");

         stat = PD_BIT (pctxt, &extbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_SETBITCOUNT (pctxt);

         if (extbit == 0) {
            stat = pd_ConsInteger (pctxt, &pvalue->u.steadyStatePhase, OSINTCONST(0), OSINTCONST(127));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else {
            stat = pd_UnconsInteger (pctxt, &pvalue->u.steadyStatePhase);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TimingAdjustmentValueLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FrameAdjustmentValue                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FrameAdjustmentValue (ASN1CTXT* pctxt, FrameAdjustmentValue* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_FrameAdjustmentValue: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(4095));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_FrameAdjustmentValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimingAdjustmentValue                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TimingAdjustmentValue (ASN1CTXT* pctxt, TimingAdjustmentValue* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TimingAdjustmentValue: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* initialPhase */
      case 0:
         PU_PUSHNAME (pctxt, "u.initialPhase");

         /* extension bit */

         PU_NEWFIELD (pctxt, "extension marker");

         stat = PD_BIT (pctxt, &extbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_SETBITCOUNT (pctxt);

         if (extbit == 0) {
            stat = pd_ConsInteger (pctxt, &pvalue->u.initialPhase, OSINTCONST(0), OSINTCONST(1048575));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else {
            stat = pd_UnconsInteger (pctxt, &pvalue->u.initialPhase);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }

         PU_POPNAME (pctxt);

         break;

      /* steadyStatePhase */
      case 1:
         PU_PUSHNAME (pctxt, "u.steadyStatePhase");

         /* extension bit */

         PU_NEWFIELD (pctxt, "extension marker");

         stat = PD_BIT (pctxt, &extbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_SETBITCOUNT (pctxt);

         if (extbit == 0) {
            stat = pd_ConsInteger (pctxt, &pvalue->u.steadyStatePhase, OSINTCONST(0), OSINTCONST(255));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else {
            stat = pd_UnconsInteger (pctxt, &pvalue->u.steadyStatePhase);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TimingAdjustmentValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstSIR                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstSIR (ASN1CTXT* pctxt, CellSyncBurstSIR* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstSIR: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(31));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstSIR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstTimingLCR                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstTimingLCR (ASN1CTXT* pctxt, CellSyncBurstTimingLCR* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstTimingLCR: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* initialPhase */
      case 0:
         PU_PUSHNAME (pctxt, "u.initialPhase");

         /* extension bit */

         PU_NEWFIELD (pctxt, "extension marker");

         stat = PD_BIT (pctxt, &extbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_SETBITCOUNT (pctxt);

         if (extbit == 0) {
            stat = pd_ConsInteger (pctxt, &pvalue->u.initialPhase, OSINTCONST(0), OSINTCONST(524287));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else {
            stat = pd_UnconsInteger (pctxt, &pvalue->u.initialPhase);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }

         PU_POPNAME (pctxt);

         break;

      /* steadyStatePhase */
      case 1:
         PU_PUSHNAME (pctxt, "u.steadyStatePhase");

         /* extension bit */

         PU_NEWFIELD (pctxt, "extension marker");

         stat = PD_BIT (pctxt, &extbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_SETBITCOUNT (pctxt);

         if (extbit == 0) {
            stat = pd_ConsInteger (pctxt, &pvalue->u.steadyStatePhase, OSINTCONST(0), OSINTCONST(127));
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }
         else {
            stat = pd_UnconsInteger (pctxt, &pvalue->u.steadyStatePhase);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         }

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstTimingLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlow_ID                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_MACdFlow_ID (ASN1CTXT* pctxt, HSDSCH_MACdFlow_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlow_ID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlow_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Execution_Type                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Execution_Type (ASN1CTXT* pctxt, Execution_Type* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_Execution_Type: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* synchronised */
      case 0:
         PU_PUSHNAME (pctxt, "u.synchronised");

         stat = asn1PD_CFN (pctxt, &pvalue->u.synchronised);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* unsynchronised */
      case 1:
         PU_PUSHNAME (pctxt, "u.unsynchronised");

         /* NULL */

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Execution_Type: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Activate_Info                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Activate_Info (ASN1CTXT* pctxt, Activate_Info* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Activate_Info: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "firstRLS_IndicatorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.firstRLS_IndicatorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "propagation_delayPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.propagation_delayPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode activation_type */

   PU_PUSHNAME (pctxt, "activation_type");

   stat = asn1PD_Execution_Type (pctxt, &pvalue->activation_type);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode initial_dl_tx_power */

   PU_PUSHNAME (pctxt, "initial_dl_tx_power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->initial_dl_tx_power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode firstRLS_Indicator */

   if (pvalue->m.firstRLS_IndicatorPresent) {
      PU_PUSHNAME (pctxt, "firstRLS_Indicator");

      stat = asn1PD_FirstRLS_Indicator (pctxt, &pvalue->firstRLS_Indicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode propagation_delay */

   if (pvalue->m.propagation_delayPresent) {
      PU_PUSHNAME (pctxt, "propagation_delay");

      stat = asn1PD_PropagationDelay (pctxt, &pvalue->propagation_delay);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Activate_Info: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Deactivate_Info                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Deactivate_Info (ASN1CTXT* pctxt, Deactivate_Info* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Deactivate_Info: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode deactivation_type */

   PU_PUSHNAME (pctxt, "deactivation_type");

   stat = asn1PD_Execution_Type (pctxt, &pvalue->deactivation_type);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Deactivate_Info: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DelayedActivationUpdate                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DelayedActivationUpdate (ASN1CTXT* pctxt, DelayedActivationUpdate* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_DelayedActivationUpdate: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* activate */
      case 0:
         PU_PUSHNAME (pctxt, "u.activate");

         pvalue->u.activate = rtMemAllocTypeZ (pctxt, Activate_Info);
         if (pvalue->u.activate == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_Activate_Info (pctxt, pvalue->u.activate);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* deactivate */
      case 1:
         PU_PUSHNAME (pctxt, "u.deactivate");

         pvalue->u.deactivate = rtMemAllocTypeZ (pctxt, Deactivate_Info);
         if (pvalue->u.deactivate == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_Deactivate_Info (pctxt, pvalue->u.deactivate);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DelayedActivationUpdate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AckNack_RepetitionFactor                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AckNack_RepetitionFactor (ASN1CTXT* pctxt, AckNack_RepetitionFactor* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_AckNack_RepetitionFactor: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(1), OSINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AckNack_RepetitionFactor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ack_Power_Offset                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Ack_Power_Offset (ASN1CTXT* pctxt, Ack_Power_Offset* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Ack_Power_Offset: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(8));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Ack_Power_Offset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AOA_LCR                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AOA_LCR (ASN1CTXT* pctxt, AOA_LCR* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AOA_LCR: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(719));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_AOA_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AOA_LCR_Accuracy_Class                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AOA_LCR_Accuracy_Class (ASN1CTXT* pctxt, AOA_LCR_Accuracy_Class* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_AOA_LCR_Accuracy_Class: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = a; break;
         case 1: *pvalue = b; break;
         case 2: *pvalue = c; break;
         case 3: *pvalue = d; break;
         case 4: *pvalue = e; break;
         case 5: *pvalue = f; break;
         case 6: *pvalue = g; break;
         case 7: *pvalue = h; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AOA_LCR_Accuracy_Class: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BCCH_ModificationTime                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BCCH_ModificationTime (ASN1CTXT* pctxt, BCCH_ModificationTime* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_BCCH_ModificationTime: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(511));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_BCCH_ModificationTime: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BlockingPriorityIndicator                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BlockingPriorityIndicator (ASN1CTXT* pctxt, BlockingPriorityIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_BlockingPriorityIndicator: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = high; break;
         case 1: *pvalue = normal; break;
         case 2: *pvalue = low; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BlockingPriorityIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BundlingModeIndicator                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_BundlingModeIndicator (ASN1CTXT* pctxt, BundlingModeIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_BundlingModeIndicator: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = bundling; break;
      case 1: *pvalue = no_bundling; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BundlingModeIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellParameterID                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellParameterID (ASN1CTXT* pctxt, CellParameterID* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellParameterID: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellParameterID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellSyncBurstRepetitionPeriod                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CellSyncBurstRepetitionPeriod (ASN1CTXT* pctxt, CellSyncBurstRepetitionPeriod* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstRepetitionPeriod: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(4095));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSyncBurstRepetitionPeriod: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Closedlooptimingadjustmentmode                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Closedlooptimingadjustmentmode (ASN1CTXT* pctxt, Closedlooptimingadjustmentmode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Closedlooptimingadjustmentmode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = adj_1_slot; break;
         case 1: *pvalue = adj_2_slot; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Closedlooptimingadjustmentmode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonMeasurementType (ASN1CTXT* pctxt, CommonMeasurementType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      switch (ui) {
         case 0: *pvalue = uTRAN_GPS_Timing_of_Cell_Frames_for_UE_Positioning; break;
         case 1: *pvalue = sFN_SFN_Observed_Time_Difference; break;
         case 2: *pvalue = transmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmission; break;
         case 3: *pvalue = hS_DSCH_Required_Power; break;
         case 4: *pvalue = hS_DSCH_Provided_Bit_Rate; break;
         case 5: *pvalue = received_total_wide_band_power_for_cellPortion; break;
         case 6: *pvalue = transmitted_carrier_power_for_cellPortion; break;
         case 7: *pvalue = transmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmission_for_cellPortion; break;
         case 8: *pvalue = upPTS_Interference; break;
         case 9: *pvalue = dLTransmissionBranchLoad; break;
         case 10: *pvalue = hS_DSCH_Required_Power_for_cell_portion; break;
         case 11: *pvalue = hS_DSCH_Provided_Bit_Rate_for_cell_portion; break;
         case 12: *pvalue = e_DCH_Provided_Bit_Rate; break;
         default: *pvalue = ui;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = received_total_wide_band_power; break;
         case 1: *pvalue = transmitted_carrier_power; break;
         case 2: *pvalue = acknowledged_prach_preambles; break;
         case 3: *pvalue = ul_timeslot_iscp; break;
         case 4: *pvalue = notUsed_1_acknowledged_PCPCH_access_preambles; break;
         case 5: *pvalue = notUsed_2_detected_PCPCH_access_preambles; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Compressed_Mode_Deactivation_Flag                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Compressed_Mode_Deactivation_Flag (ASN1CTXT* pctxt, Compressed_Mode_Deactivation_Flag* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_Compressed_Mode_Deactivation_Flag: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = deactivate; break;
      case 1: *pvalue = maintain_Active; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Compressed_Mode_Deactivation_Flag: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConstantValue                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ConstantValue (ASN1CTXT* pctxt, ConstantValue* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ConstantValue: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(-10), OSINTCONST(10));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ConstantValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CQI_Feedback_Cycle                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CQI_Feedback_Cycle (ASN1CTXT* pctxt, CQI_Feedback_Cycle* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CQI_Feedback_Cycle: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(8));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = v0_1; break;
         case 1: *pvalue = v2; break;
         case 2: *pvalue = v4; break;
         case 3: *pvalue = v8; break;
         case 4: *pvalue = v10; break;
         case 5: *pvalue = v20; break;
         case 6: *pvalue = v40; break;
         case 7: *pvalue = v80; break;
         case 8: *pvalue = v160; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CQI_Feedback_Cycle: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CQI_Power_Offset                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CQI_Power_Offset (ASN1CTXT* pctxt, CQI_Power_Offset* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CQI_Power_Offset: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(8));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CQI_Power_Offset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CQI_RepetitionFactor                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CQI_RepetitionFactor (ASN1CTXT* pctxt, CQI_RepetitionFactor* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CQI_RepetitionFactor: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(1), OSINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CQI_RepetitionFactor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DedicatedMeasurementType                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DedicatedMeasurementType (ASN1CTXT* pctxt, DedicatedMeasurementType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      switch (ui) {
         case 0: *pvalue = rx_timing_deviation_LCR; break;
         case 1: *pvalue = angle_Of_Arrival_LCR; break;
         case 2: *pvalue = hs_sich_quality; break;
         case 3: *pvalue = best_Cell_Portions; break;
         default: *pvalue = ui;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = sir; break;
         case 1: *pvalue = sir_error; break;
         case 2: *pvalue = transmitted_code_power; break;
         case 3: *pvalue = rscp; break;
         case 4: *pvalue = rx_timing_deviation; break;
         case 5: *pvalue = round_trip_time; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DedicatedMeasurementType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeltaSIR                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DeltaSIR (ASN1CTXT* pctxt, DeltaSIR* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DeltaSIR: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(30));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DeltaSIR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DiscardTimer                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DiscardTimer (ASN1CTXT* pctxt, DiscardTimer* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DiscardTimer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(26));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = v20_1; break;
         case 1: *pvalue = v40_1; break;
         case 2: *pvalue = v60; break;
         case 3: *pvalue = v80_1; break;
         case 4: *pvalue = v100; break;
         case 5: *pvalue = v120; break;
         case 6: *pvalue = v140; break;
         case 7: *pvalue = v160_1; break;
         case 8: *pvalue = v180; break;
         case 9: *pvalue = v200; break;
         case 10: *pvalue = v250; break;
         case 11: *pvalue = v300; break;
         case 12: *pvalue = v400; break;
         case 13: *pvalue = v500; break;
         case 14: *pvalue = v750; break;
         case 15: *pvalue = v1000; break;
         case 16: *pvalue = v1250; break;
         case 17: *pvalue = v1500; break;
         case 18: *pvalue = v1750; break;
         case 19: *pvalue = v2000; break;
         case 20: *pvalue = v2500; break;
         case 21: *pvalue = v3000; break;
         case 22: *pvalue = v3500; break;
         case 23: *pvalue = v4000; break;
         case 24: *pvalue = v4500; break;
         case 25: *pvalue = v5000; break;
         case 26: *pvalue = v7500; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DiscardTimer: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_DPCH_TimingAdjustment                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_DPCH_TimingAdjustment (ASN1CTXT* pctxt, DL_DPCH_TimingAdjustment* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_TimingAdjustment: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = timing_advance; break;
      case 1: *pvalue = timing_delay; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_DPCH_TimingAdjustment: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_FrameType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_FrameType (ASN1CTXT* pctxt, DL_FrameType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_FrameType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = typeA; break;
         case 1: *pvalue = typeB; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_FrameType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_PowerBalancing_ActivationIndicator                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_PowerBalancing_ActivationIndicator (ASN1CTXT* pctxt, DL_PowerBalancing_ActivationIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_PowerBalancing_ActivationIndicator: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = dL_PowerBalancing_Activated; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_PowerBalancing_ActivationIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_PowerBalancing_UpdatedIndicator                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_PowerBalancing_UpdatedIndicator (ASN1CTXT* pctxt, DL_PowerBalancing_UpdatedIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_PowerBalancing_UpdatedIndicator: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = dL_PowerBalancing_Updated; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_PowerBalancing_UpdatedIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_TPC_Pattern01Count                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_TPC_Pattern01Count (ASN1CTXT* pctxt, DL_TPC_Pattern01Count* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_TPC_Pattern01Count: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(30));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_TPC_Pattern01Count: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DLTransmissionBranchLoadValue                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DLTransmissionBranchLoadValue (ASN1CTXT* pctxt, DLTransmissionBranchLoadValue* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DLTransmissionBranchLoadValue: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(101));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DLTransmissionBranchLoadValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Downlink_Compressed_Mode_Method                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Downlink_Compressed_Mode_Method (ASN1CTXT* pctxt, Downlink_Compressed_Mode_Method* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Downlink_Compressed_Mode_Method: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = not_Used_puncturing; break;
         case 1: *pvalue = sFdiv2; break;
         case 2: *pvalue = higher_layer_scheduling; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Downlink_Compressed_Mode_Method: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DPC_Mode                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DPC_Mode (ASN1CTXT* pctxt, DPC_Mode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DPC_Mode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = mode0; break;
         case 1: *pvalue = mode1; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DPC_Mode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DsField                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DsField (ASN1CTXT* pctxt, DsField* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DsField: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DsField: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_AGCH_FDD_Code_Information_Item                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_AGCH_FDD_Code_Information_Item (ASN1CTXT* pctxt, E_AGCH_FDD_Code_Information_Item* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_AGCH_FDD_Code_Information_Item: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_E_AGCH_FDD_Code_Information_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_Capability                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_Capability (ASN1CTXT* pctxt, E_DCH_Capability* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_Capability: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = e_DCH_capable; break;
      case 1: *pvalue = e_DCH_non_capable; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_Capability: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_DDI_Value                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_DDI_Value (ASN1CTXT* pctxt, E_DCH_DDI_Value* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_DDI_Value: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_DDI_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_HARQ_PO_FDD                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_HARQ_PO_FDD (ASN1CTXT* pctxt, E_DCH_HARQ_PO_FDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_HARQ_PO_FDD: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(6));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_HARQ_PO_FDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlow_ID                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_MACdFlow_ID (ASN1CTXT* pctxt, E_DCH_MACdFlow_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlow_ID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlow_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlow_Multiplexing_List                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_MACdFlow_Multiplexing_List (ASN1CTXT* pctxt, E_DCH_MACdFlow_Multiplexing_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlow_Multiplexing_List: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlow_Multiplexing_List: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCHProvidedBitRateValue                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCHProvidedBitRateValue (ASN1CTXT* pctxt, E_DCHProvidedBitRateValue* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCHProvidedBitRateValue: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(16777215));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCHProvidedBitRateValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Maximum_Target_ReceivedTotalWideBandPower                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Maximum_Target_ReceivedTotalWideBandPower (ASN1CTXT* pctxt, Maximum_Target_ReceivedTotalWideBandPower* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Maximum_Target_ReceivedTotalWideBandPower: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(621));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Maximum_Target_ReceivedTotalWideBandPower: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_RL_Indication                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_RL_Indication (ASN1CTXT* pctxt, E_DCH_RL_Indication* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_RL_Indication: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = e_DCH; break;
      case 1: *pvalue = non_e_DCH; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_RL_Indication: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_HICH_Signature_Sequence                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_HICH_Signature_Sequence (ASN1CTXT* pctxt, E_HICH_Signature_Sequence* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_HICH_Signature_Sequence: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(39));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_E_HICH_Signature_Sequence: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  End_Of_Audit_Sequence_Indicator                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_End_Of_Audit_Sequence_Indicator (ASN1CTXT* pctxt, End_Of_Audit_Sequence_Indicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_End_Of_Audit_Sequence_Indicator: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = end_of_audit_sequence; break;
      case 1: *pvalue = not_end_of_audit_sequence; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_End_Of_Audit_Sequence_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_RGCH_E_HICH_FDD_Code_Information_Item                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_RGCH_E_HICH_FDD_Code_Information_Item (ASN1CTXT* pctxt, E_RGCH_E_HICH_FDD_Code_Information_Item* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RGCH_E_HICH_FDD_Code_Information_Item: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RGCH_E_HICH_FDD_Code_Information_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_RGCH_Signature_Sequence                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_RGCH_Signature_Sequence (ASN1CTXT* pctxt, E_RGCH_Signature_Sequence* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RGCH_Signature_Sequence: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(39));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RGCH_Signature_Sequence: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_RNTI                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_RNTI (ASN1CTXT* pctxt, E_RNTI* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RNTI: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RNTI: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FDD_S_CCPCH_FrameOffset                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FDD_S_CCPCH_FrameOffset (ASN1CTXT* pctxt, FDD_S_CCPCH_FrameOffset* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_FDD_S_CCPCH_FrameOffset: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = v1_1; break;
         case 1: *pvalue = v2_1; break;
         case 2: *pvalue = v4_1; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FDD_S_CCPCH_FrameOffset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FNReportingIndicator                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FNReportingIndicator (ASN1CTXT* pctxt, FNReportingIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_FNReportingIndicator: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = fN_reporting_required; break;
      case 1: *pvalue = fN_reporting_not_required; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FNReportingIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GapLength                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GapLength (ASN1CTXT* pctxt, GapLength* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GapLength: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(14));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GapLength: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GapDuration                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GapDuration (ASN1CTXT* pctxt, GapDuration* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_GapDuration: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(1), OSINTCONST(144));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GapDuration: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GenericTrafficCategory                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GenericTrafficCategory (ASN1CTXT* pctxt, GenericTrafficCategory* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GenericTrafficCategory: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_GenericTrafficCategory: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Information_Item                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_Information_Item (ASN1CTXT* pctxt, GPS_Information_Item* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Information_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = gps_navigation_model_and_time_recovery; break;
         case 1: *pvalue = gps_ionospheric_model; break;
         case 2: *pvalue = gps_utc_model; break;
         case 3: *pvalue = gps_almanac; break;
         case 4: *pvalue = gps_rt_integrity; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Information_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HARQ_Preamble_Mode                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HARQ_Preamble_Mode (ASN1CTXT* pctxt, HARQ_Preamble_Mode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_HARQ_Preamble_Mode: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = mode0_1; break;
      case 1: *pvalue = mode1_1; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HARQ_Preamble_Mode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HARQ_Process_Allocation_2ms_EDCH                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HARQ_Process_Allocation_2ms_EDCH (ASN1CTXT* pctxt, HARQ_Process_Allocation_2ms_EDCH* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HARQ_Process_Allocation_2ms_EDCH: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_HARQ_Process_Allocation_2ms_EDCH: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HARQ_Preamble_Mode_Activation_Indicator                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HARQ_Preamble_Mode_Activation_Indicator (ASN1CTXT* pctxt, HARQ_Preamble_Mode_Activation_Indicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_HARQ_Preamble_Mode_Activation_Indicator: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = harqPreambleModeActivated; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HARQ_Preamble_Mode_Activation_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDPA_Capability                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDPA_Capability (ASN1CTXT* pctxt, HSDPA_Capability* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDPA_Capability: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = hsdpa_capable; break;
      case 1: *pvalue = hsdpa_non_capable; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDPA_Capability: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHProvidedBitRateValue                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_DSCHProvidedBitRateValue (ASN1CTXT* pctxt, HS_DSCHProvidedBitRateValue* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHProvidedBitRateValue: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(16777215));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHProvidedBitRateValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHRequiredPowerValue                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_DSCHRequiredPowerValue (ASN1CTXT* pctxt, HS_DSCHRequiredPowerValue* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHRequiredPowerValue: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(1000));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHRequiredPowerValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHRequiredPowerPerUEWeight                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_DSCHRequiredPowerPerUEWeight (ASN1CTXT* pctxt, HS_DSCHRequiredPowerPerUEWeight* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHRequiredPowerPerUEWeight: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(100));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHRequiredPowerPerUEWeight: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSCCH_PowerOffset                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSSCCH_PowerOffset (ASN1CTXT* pctxt, HSSCCH_PowerOffset* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSCCH_PowerOffset: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSCCH_PowerOffset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_InitialWindowSize                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_InitialWindowSize (ASN1CTXT* pctxt, HSDSCH_InitialWindowSize* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_InitialWindowSize: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_InitialWindowSize: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SICH_failed                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SICH_failed (ASN1CTXT* pctxt, HS_SICH_failed* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_failed: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(20));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_failed: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SICH_missed                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SICH_missed (ASN1CTXT* pctxt, HS_SICH_missed* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_missed: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(20));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_missed: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SICH_total                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SICH_total (ASN1CTXT* pctxt, HS_SICH_total* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_total: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(20));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_total: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SICH_Reception_Quality_Measurement_Value               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SICH_Reception_Quality_Measurement_Value (ASN1CTXT* pctxt, HS_SICH_Reception_Quality_Measurement_Value* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_Reception_Quality_Measurement_Value: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(20));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_Reception_Quality_Measurement_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_RNTI                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_RNTI (ASN1CTXT* pctxt, HSDSCH_RNTI* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_RNTI: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_RNTI: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSCCH_CodeChangeIndicator                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSSCCH_CodeChangeIndicator (ASN1CTXT* pctxt, HSSCCH_CodeChangeIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSCCH_CodeChangeIndicator: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = hsSCCHCodeChangeNeeded; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSCCH_CodeChangeIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSCCH_Code_Change_Grant                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSSCCH_Code_Change_Grant (ASN1CTXT* pctxt, HSSCCH_Code_Change_Grant* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSCCH_Code_Change_Grant: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = changeGranted; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSCCH_Code_Change_Grant: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationExchangeID                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationExchangeID (ASN1CTXT* pctxt, InformationExchangeID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationExchangeID: start\n");

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(1048575));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationExchangeID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Information_Type_Item                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Information_Type_Item (ASN1CTXT* pctxt, Information_Type_Item* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Information_Type_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = gpsinformation; break;
         case 1: *pvalue = dgpscorrections; break;
         case 2: *pvalue = gpsrxpos; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Information_Type_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Initial_DL_DPCH_TimingAdjustment_Allowed                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Initial_DL_DPCH_TimingAdjustment_Allowed (ASN1CTXT* pctxt, Initial_DL_DPCH_TimingAdjustment_Allowed* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_Initial_DL_DPCH_TimingAdjustment_Allowed: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = initial_DL_DPCH_TimingAdjustment_Allowed; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Initial_DL_DPCH_TimingAdjustment_Allowed: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MACdPDU_Size                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MACdPDU_Size (ASN1CTXT* pctxt, MACdPDU_Size* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MACdPDU_Size: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(1), OSINTCONST(5000));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MACdPDU_Size: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MACesGuaranteedBitRate                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MACesGuaranteedBitRate (ASN1CTXT* pctxt, MACesGuaranteedBitRate* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MACesGuaranteedBitRate: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(16777215));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MACesGuaranteedBitRate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MAChsGuaranteedBitRate                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MAChsGuaranteedBitRate (ASN1CTXT* pctxt, MAChsGuaranteedBitRate* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MAChsGuaranteedBitRate: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(16777215));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MAChsGuaranteedBitRate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MAChsReorderingBufferSize_for_RLC_UM                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MAChsReorderingBufferSize_for_RLC_UM (ASN1CTXT* pctxt, MAChsReorderingBufferSize_for_RLC_UM* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MAChsReorderingBufferSize_for_RLC_UM: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(300));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MAChsReorderingBufferSize_for_RLC_UM: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MAC_hsWindowSize                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MAC_hsWindowSize (ASN1CTXT* pctxt, MAC_hsWindowSize* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MAC_hsWindowSize: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(6));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = v4_2; break;
         case 1: *pvalue = v6; break;
         case 2: *pvalue = v8_1; break;
         case 3: *pvalue = v12; break;
         case 4: *pvalue = v16; break;
         case 5: *pvalue = v24; break;
         case 6: *pvalue = v32; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MAC_hsWindowSize: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Max_Bits_MACe_PDU_non_scheduled                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Max_Bits_MACe_PDU_non_scheduled (ASN1CTXT* pctxt, Max_Bits_MACe_PDU_non_scheduled* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Max_Bits_MACe_PDU_non_scheduled: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(19982));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Max_Bits_MACe_PDU_non_scheduled: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Maximum_Number_of_Retransmissions_For_E_DCH               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Maximum_Number_of_Retransmissions_For_E_DCH (ASN1CTXT* pctxt, Maximum_Number_of_Retransmissions_For_E_DCH* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Maximum_Number_of_Retransmissions_For_E_DCH: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Maximum_Number_of_Retransmissions_For_E_DCH: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Maximum_Allowed_UE_UL_Tx_Power                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Maximum_Allowed_UE_UL_Tx_Power (ASN1CTXT* pctxt, Maximum_Allowed_UE_UL_Tx_Power* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Maximum_Allowed_UE_UL_Tx_Power: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(-55), OSINTCONST(33));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Maximum_Allowed_UE_UL_Tx_Power: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasurementFilterCoefficient                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MeasurementFilterCoefficient (ASN1CTXT* pctxt, MeasurementFilterCoefficient* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MeasurementFilterCoefficient: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(14));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = k0; break;
         case 1: *pvalue = k1; break;
         case 2: *pvalue = k2; break;
         case 3: *pvalue = k3; break;
         case 4: *pvalue = k4; break;
         case 5: *pvalue = k5; break;
         case 6: *pvalue = k6; break;
         case 7: *pvalue = k7; break;
         case 8: *pvalue = k8; break;
         case 9: *pvalue = k9; break;
         case 10: *pvalue = k11; break;
         case 11: *pvalue = k13; break;
         case 12: *pvalue = k15; break;
         case 13: *pvalue = k17; break;
         case 14: *pvalue = k19; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MeasurementFilterCoefficient: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasurementID                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MeasurementID (ASN1CTXT* pctxt, MeasurementID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MeasurementID: start\n");

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(1048575));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_MeasurementID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Measurement_Power_Offset                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Measurement_Power_Offset (ASN1CTXT* pctxt, Measurement_Power_Offset* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Measurement_Power_Offset: start\n");

   stat = pd_ConsInt8 (pctxt, pvalue, OSINTCONST(-12), OSINTCONST(26));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Measurement_Power_Offset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasurementRecoveryBehavior                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MeasurementRecoveryBehavior_ (ASN1CTXT* pctxt, void* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MeasurementRecoveryBehavior: start\n");

   /* NULL */

   RTDIAGSTRM2 (pctxt,"asn1PD_MeasurementRecoveryBehavior: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasurementRecoveryReportingIndicator                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MeasurementRecoveryReportingIndicator_ (ASN1CTXT* pctxt, void* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MeasurementRecoveryReportingIndicator: start\n");

   /* NULL */

   RTDIAGSTRM2 (pctxt,"asn1PD_MeasurementRecoveryReportingIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasurementRecoverySupportIndicator                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MeasurementRecoverySupportIndicator_ (ASN1CTXT* pctxt, void* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MeasurementRecoverySupportIndicator: start\n");

   /* NULL */

   RTDIAGSTRM2 (pctxt,"asn1PD_MeasurementRecoverySupportIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MICH_CFN                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MICH_CFN (ASN1CTXT* pctxt, MICH_CFN* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MICH_CFN: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(4095));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_MICH_CFN: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Modification_Period                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Modification_Period (ASN1CTXT* pctxt, Modification_Period* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Modification_Period: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = v5120; break;
         case 1: *pvalue = v10240; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Modification_Period: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Nack_Power_Offset                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Nack_Power_Offset (ASN1CTXT* pctxt, Nack_Power_Offset* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Nack_Power_Offset: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(8));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Nack_Power_Offset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NCyclesPerSFNperiod                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NCyclesPerSFNperiod (ASN1CTXT* pctxt, NCyclesPerSFNperiod* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_NCyclesPerSFNperiod: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      switch (ui) {
         case 0: *pvalue = v16_5; break;
         case 1: *pvalue = v32_3; break;
         case 2: *pvalue = v64_2; break;
         default: *pvalue = ui;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = v1_2; break;
         case 1: *pvalue = v2_3; break;
         case 2: *pvalue = v4_7; break;
         case 3: *pvalue = v8_6; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NCyclesPerSFNperiod: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NRepetitionsPerCyclePeriod                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NRepetitionsPerCyclePeriod (ASN1CTXT* pctxt, NRepetitionsPerCyclePeriod* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NRepetitionsPerCyclePeriod: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(2), OSUINTCONST(10));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_NRepetitionsPerCyclePeriod: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Extension_neighbouringCellMeasurementInformation          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Extension_neighbouringCellMeasurementInformation (ASN1CTXT* pctxt, Extension_neighbouringCellMeasurementInformation* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Extension_neighbouringCellMeasurementInformation: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Extension_neighbouringCellMeasurementInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Notification_Indicator                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Notification_Indicator (ASN1CTXT* pctxt, Notification_Indicator* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Notification_Indicator: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Notification_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NumberOfReportedCellPortions                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NumberOfReportedCellPortions (ASN1CTXT* pctxt, NumberOfReportedCellPortions* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_NumberOfReportedCellPortions: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(1), OSINTCONST(64));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NumberOfReportedCellPortions: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NSubCyclesPerCyclePeriod                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NSubCyclesPerCyclePeriod (ASN1CTXT* pctxt, NSubCyclesPerCyclePeriod* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_NSubCyclesPerCyclePeriod: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(1), OSINTCONST(16));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NSubCyclesPerCyclePeriod: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PayloadCRC_PresenceIndicator                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PayloadCRC_PresenceIndicator (ASN1CTXT* pctxt, PayloadCRC_PresenceIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PayloadCRC_PresenceIndicator: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = cRC_Included; break;
         case 1: *pvalue = cRC_NotIncluded; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PayloadCRC_PresenceIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PowerAdjustmentType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PowerAdjustmentType (ASN1CTXT* pctxt, PowerAdjustmentType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerAdjustmentType: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = none_1; break;
      case 1: *pvalue = common; break;
      case 2: *pvalue = individual; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PowerAdjustmentType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PRCDeviation                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PRCDeviation (ASN1CTXT* pctxt, PRCDeviation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PRCDeviation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = one; break;
         case 1: *pvalue = two; break;
         case 2: *pvalue = five; break;
         case 3: *pvalue = ten; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PRCDeviation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PredictedSFNSFNDeviationLimit                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PredictedSFNSFNDeviationLimit (ASN1CTXT* pctxt, PredictedSFNSFNDeviationLimit* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PredictedSFNSFNDeviationLimit: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(256));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PredictedSFNSFNDeviationLimit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PredictedTUTRANGPSDeviationLimit                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PredictedTUTRANGPSDeviationLimit (ASN1CTXT* pctxt, PredictedTUTRANGPSDeviationLimit* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PredictedTUTRANGPSDeviationLimit: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(256));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PredictedTUTRANGPSDeviationLimit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Primary_CPICH_Usage_for_Channel_Estimation                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Primary_CPICH_Usage_for_Channel_Estimation (ASN1CTXT* pctxt, Primary_CPICH_Usage_for_Channel_Estimation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_Primary_CPICH_Usage_for_Channel_Estimation: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = primary_CPICH_may_be_used; break;
      case 1: *pvalue = primary_CPICH_shall_not_be_used; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Primary_CPICH_Usage_for_Channel_Estimation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrimaryScramblingCode                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PrimaryScramblingCode (ASN1CTXT* pctxt, PrimaryScramblingCode* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimaryScramblingCode: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(511));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimaryScramblingCode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityQueue_Id                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PriorityQueue_Id (ASN1CTXT* pctxt, PriorityQueue_Id* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityQueue_Id: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityQueue_Id: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrimaryCCPCH_RSCP                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PrimaryCCPCH_RSCP (ASN1CTXT* pctxt, PrimaryCCPCH_RSCP* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimaryCCPCH_RSCP: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(91));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimaryCCPCH_RSCP: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrimaryCCPCH_RSCP_Delta                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PrimaryCCPCH_RSCP_Delta (ASN1CTXT* pctxt, PrimaryCCPCH_RSCP_Delta* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimaryCCPCH_RSCP_Delta: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(-5), OSINTCONST(-1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PrimaryCCPCH_RSCP_Delta: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QE_Selector                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_QE_Selector (ASN1CTXT* pctxt, QE_Selector* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_QE_Selector: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = selected; break;
      case 1: *pvalue = non_selected; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QE_Selector: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReferenceClockAvailability                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReferenceClockAvailability (ASN1CTXT* pctxt, ReferenceClockAvailability* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_ReferenceClockAvailability: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = available; break;
      case 1: *pvalue = notAvailable; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReferenceClockAvailability: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReferenceSFNoffset                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReferenceSFNoffset (ASN1CTXT* pctxt, ReferenceSFNoffset* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ReferenceSFNoffset: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_ReferenceSFNoffset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RepetitionNumber0                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RepetitionNumber0 (ASN1CTXT* pctxt, RepetitionNumber0* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RepetitionNumber0: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_RepetitionNumber0: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RepetitionNumber1                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RepetitionNumber1 (ASN1CTXT* pctxt, RepetitionNumber1* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RepetitionNumber1: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(256));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_RepetitionNumber1: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Extension_ReportCharacteristics                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Extension_ReportCharacteristics (ASN1CTXT* pctxt, Extension_ReportCharacteristics* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Extension_ReportCharacteristics: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Extension_ReportCharacteristics: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Extension_ReportCharacteristicsType_MeasurementIncreaseD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Extension_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold (ASN1CTXT* pctxt, Extension_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Extension_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Extension_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Extension_ReportCharacteristicsType_MeasurementThreshold  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Extension_ReportCharacteristicsType_MeasurementThreshold (ASN1CTXT* pctxt, Extension_ReportCharacteristicsType_MeasurementThreshold* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Extension_ReportCharacteristicsType_MeasurementThreshold: start\n");

   stat = asn1PD_ProtocolIE_Single_Container (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Extension_ReportCharacteristicsType_MeasurementThreshold: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasurementChangeTime_Scaledmsec                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MeasurementChangeTime_Scaledmsec (ASN1CTXT* pctxt, MeasurementChangeTime_Scaledmsec* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MeasurementChangeTime_Scaledmsec: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(1), OSINTCONST(6000));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MeasurementChangeTime_Scaledmsec: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasurementHysteresisTime_Scaledmsec                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MeasurementHysteresisTime_Scaledmsec (ASN1CTXT* pctxt, MeasurementHysteresisTime_Scaledmsec* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MeasurementHysteresisTime_Scaledmsec: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(1), OSINTCONST(6000));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MeasurementHysteresisTime_Scaledmsec: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportPeriodicity_Scaledmsec                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReportPeriodicity_Scaledmsec (ASN1CTXT* pctxt, ReportPeriodicity_Scaledmsec* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportPeriodicity_Scaledmsec: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(1), OSINTCONST(6000));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportPeriodicity_Scaledmsec: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportPeriodicity_Scaledmin                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReportPeriodicity_Scaledmin (ASN1CTXT* pctxt, ReportPeriodicity_Scaledmin* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportPeriodicity_Scaledmin: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(1), OSINTCONST(60));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportPeriodicity_Scaledmin: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportPeriodicity_Scaledhour                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReportPeriodicity_Scaledhour (ASN1CTXT* pctxt, ReportPeriodicity_Scaledhour* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportPeriodicity_Scaledhour: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(1), OSINTCONST(24));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportPeriodicity_Scaledhour: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RLC_Mode                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RLC_Mode (ASN1CTXT* pctxt, RLC_Mode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RLC_Mode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = rLC_AM; break;
         case 1: *pvalue = rLC_UM; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RLC_Mode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Round_Trip_Time_IncrDecrThres                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Round_Trip_Time_IncrDecrThres (ASN1CTXT* pctxt, Round_Trip_Time_IncrDecrThres* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Round_Trip_Time_IncrDecrThres: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(32766));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Round_Trip_Time_IncrDecrThres: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RNC_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RNC_ID (ASN1CTXT* pctxt, RNC_ID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RNC_ID: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(4095));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_RNC_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RSCP_Value_IncrDecrThres                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RSCP_Value_IncrDecrThres (ASN1CTXT* pctxt, RSCP_Value_IncrDecrThres* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RSCP_Value_IncrDecrThres: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(126));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_RSCP_Value_IncrDecrThres: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Received_total_wide_band_power_Value_IncrDecrThres        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Received_total_wide_band_power_Value_IncrDecrThres (ASN1CTXT* pctxt, Received_total_wide_band_power_Value_IncrDecrThres* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Received_total_wide_band_power_Value_IncrDecrThres: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(620));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Received_total_wide_band_power_Value_IncrDecrThres: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Rx_Timing_Deviation_Value_LCR                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Rx_Timing_Deviation_Value_LCR (ASN1CTXT* pctxt, Rx_Timing_Deviation_Value_LCR* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Rx_Timing_Deviation_Value_LCR: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(511));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_Rx_Timing_Deviation_Value_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AdjustmentPeriod                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_AdjustmentPeriod (ASN1CTXT* pctxt, AdjustmentPeriod* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AdjustmentPeriod: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(256));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_AdjustmentPeriod: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScaledAdjustmentRatio                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ScaledAdjustmentRatio (ASN1CTXT* pctxt, ScaledAdjustmentRatio* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ScaledAdjustmentRatio: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(100));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_ScaledAdjustmentRatio: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaxAdjustmentStep                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MaxAdjustmentStep (ASN1CTXT* pctxt, MaxAdjustmentStep* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MaxAdjustmentStep: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(10));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_MaxAdjustmentStep: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SchedulingPriorityIndicator                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SchedulingPriorityIndicator (ASN1CTXT* pctxt, SchedulingPriorityIndicator* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SchedulingPriorityIndicator: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SchedulingPriorityIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SID                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SID (ASN1CTXT* pctxt, SID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFN_FDD                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SFNSFN_FDD (ASN1CTXT* pctxt, SFNSFN_FDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFN_FDD: start\n");

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(614399));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFN_FDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFN_TDD                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SFNSFN_TDD (ASN1CTXT* pctxt, SFNSFN_TDD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFN_TDD: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(40961));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFN_TDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNChangeLimit                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SFNSFNChangeLimit (ASN1CTXT* pctxt, SFNSFNChangeLimit* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNChangeLimit: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(256));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNChangeLimit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNDriftRate                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SFNSFNDriftRate (ASN1CTXT* pctxt, SFNSFNDriftRate* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNDriftRate: start\n");

   stat = pd_ConsInt8 (pctxt, pvalue, OSINTCONST(-100), OSINTCONST(100));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNDriftRate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNDriftRateQuality                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SFNSFNDriftRateQuality (ASN1CTXT* pctxt, SFNSFNDriftRateQuality* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNDriftRateQuality: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(100));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNDriftRateQuality: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNQuality                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SFNSFNQuality (ASN1CTXT* pctxt, SFNSFNQuality* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNQuality: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNQuality: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ShutdownTimer                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ShutdownTimer (ASN1CTXT* pctxt, ShutdownTimer* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ShutdownTimer: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(3600));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_ShutdownTimer: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SIR_Error_Value_IncrDecrThres                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SIR_Error_Value_IncrDecrThres (ASN1CTXT* pctxt, SIR_Error_Value_IncrDecrThres* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SIR_Error_Value_IncrDecrThres: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(124));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SIR_Error_Value_IncrDecrThres: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SIR_Value_IncrDecrThres                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SIR_Value_IncrDecrThres (ASN1CTXT* pctxt, SIR_Value_IncrDecrThres* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SIR_Value_IncrDecrThres: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(62));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SIR_Value_IncrDecrThres: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignallingBearerRequestIndicator                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SignallingBearerRequestIndicator (ASN1CTXT* pctxt, SignallingBearerRequestIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_SignallingBearerRequestIndicator: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = bearerRequested; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SignallingBearerRequestIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Start_Of_Audit_Sequence_Indicator                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Start_Of_Audit_Sequence_Indicator (ASN1CTXT* pctxt, Start_Of_Audit_Sequence_Indicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_Start_Of_Audit_Sequence_Indicator: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = start_of_audit_sequence; break;
      case 1: *pvalue = not_start_of_audit_sequence; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Start_Of_Audit_Sequence_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncCase                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SyncCase (ASN1CTXT* pctxt, SyncCase* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncCase: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(1), OSINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncCase: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  T1                                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_T1 (ASN1CTXT* pctxt, T1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_T1: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = v10_2; break;
         case 1: *pvalue = v20_2; break;
         case 2: *pvalue = v30; break;
         case 3: *pvalue = v40_2; break;
         case 4: *pvalue = v50; break;
         case 5: *pvalue = v60_1; break;
         case 6: *pvalue = v70; break;
         case 7: *pvalue = v80_2; break;
         case 8: *pvalue = v90; break;
         case 9: *pvalue = v100_1; break;
         case 10: *pvalue = v120_1; break;
         case 11: *pvalue = v140_1; break;
         case 12: *pvalue = v160_2; break;
         case 13: *pvalue = v200_1; break;
         case 14: *pvalue = v300_1; break;
         case 15: *pvalue = v400_1; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_T1: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  T_Cell                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_T_Cell (ASN1CTXT* pctxt, T_Cell* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_T_Cell: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(9));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = v0_3; break;
      case 1: *pvalue = v1_5; break;
      case 2: *pvalue = v2_8; break;
      case 3: *pvalue = v3_2; break;
      case 4: *pvalue = v4_11; break;
      case 5: *pvalue = v5; break;
      case 6: *pvalue = v6_3; break;
      case 7: *pvalue = v7; break;
      case 8: *pvalue = v8_10; break;
      case 9: *pvalue = v9; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_T_Cell: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_AckNack_Power_Offset                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_AckNack_Power_Offset (ASN1CTXT* pctxt, TDD_AckNack_Power_Offset* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_AckNack_Power_Offset: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(-7), OSINTCONST(8));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_AckNack_Power_Offset: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TGD                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TGD (ASN1CTXT* pctxt, TGD* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TGD: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(269));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_TGD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TGPRC                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TGPRC (ASN1CTXT* pctxt, TGPRC* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TGPRC: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(511));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_TGPRC: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TGPSID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TGPSID (ASN1CTXT* pctxt, TGPSID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TGPSID: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(6));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_TGPSID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TGSN                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TGSN (ASN1CTXT* pctxt, TGSN* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TGSN: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(14));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_TGSN: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimingAdvanceApplied                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TimingAdvanceApplied (ASN1CTXT* pctxt, TimingAdvanceApplied* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_TimingAdvanceApplied: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = yes; break;
      case 1: *pvalue = no; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TimingAdvanceApplied: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynchronisationIndicator                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SynchronisationIndicator (ASN1CTXT* pctxt, SynchronisationIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationIndicator: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = timingMaintainedSynchronisation; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SynchronisationIndicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionValue (ASN1CTXT* pctxt, TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionValue* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionValue: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(100));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transmitted_Code_Power_Value_IncrDecrThres                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Transmitted_Code_Power_Value_IncrDecrThres (ASN1CTXT* pctxt, Transmitted_Code_Power_Value_IncrDecrThres* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Transmitted_Code_Power_Value_IncrDecrThres: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(112));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Transmitted_Code_Power_Value_IncrDecrThres: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransmissionDiversityApplied                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransmissionDiversityApplied (ASN1CTXT* pctxt, TransmissionDiversityApplied* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransmissionDiversityApplied: start\n");

   PU_NEWFIELD (pctxt, "boolean");

   stat = PD_BIT (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TransmissionDiversityApplied: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TUTRANGPSChangeLimit                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TUTRANGPSChangeLimit (ASN1CTXT* pctxt, TUTRANGPSChangeLimit* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TUTRANGPSChangeLimit: start\n");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(256));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_TUTRANGPSChangeLimit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TUTRANGPSDriftRate                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TUTRANGPSDriftRate (ASN1CTXT* pctxt, TUTRANGPSDriftRate* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TUTRANGPSDriftRate: start\n");

   stat = pd_ConsInt8 (pctxt, pvalue, OSINTCONST(-50), OSINTCONST(50));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_TUTRANGPSDriftRate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TUTRANGPSDriftRateQuality                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TUTRANGPSDriftRateQuality (ASN1CTXT* pctxt, TUTRANGPSDriftRateQuality* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TUTRANGPSDriftRateQuality: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(50));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_TUTRANGPSDriftRateQuality: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TUTRANGPSAccuracyClass                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TUTRANGPSAccuracyClass (ASN1CTXT* pctxt, TUTRANGPSAccuracyClass* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TUTRANGPSAccuracyClass: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = accuracy_class_A; break;
         case 1: *pvalue = accuracy_class_B; break;
         case 2: *pvalue = accuracy_class_C; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TUTRANGPSAccuracyClass: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TUTRANGPSQuality                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TUTRANGPSQuality (ASN1CTXT* pctxt, TUTRANGPSQuality* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TUTRANGPSQuality: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_TUTRANGPSQuality: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TypeOfError                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TypeOfError (ASN1CTXT* pctxt, TypeOfError* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TypeOfError: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = not_understood; break;
         case 1: *pvalue = missing; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TypeOfError: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DL_mode                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DL_mode (ASN1CTXT* pctxt, UL_DL_mode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DL_mode: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = ul_only; break;
      case 1: *pvalue = dl_only; break;
      case 2: *pvalue = both_ul_and_dl; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DL_mode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_DPDCH_Indicator_For_E_DCH_Operation                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_DPDCH_Indicator_For_E_DCH_Operation (ASN1CTXT* pctxt, UL_DPDCH_Indicator_For_E_DCH_Operation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPDCH_Indicator_For_E_DCH_Operation: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = ul_DPDCH_present; break;
      case 1: *pvalue = ul_DPDCH_not_present; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_DPDCH_Indicator_For_E_DCH_Operation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Uplink_Compressed_Mode_Method                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Uplink_Compressed_Mode_Method (ASN1CTXT* pctxt, Uplink_Compressed_Mode_Method* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Uplink_Compressed_Mode_Method: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = sFdiv2_1; break;
         case 1: *pvalue = higher_layer_scheduling_1; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Uplink_Compressed_Mode_Method: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_FP_Mode                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_FP_Mode (ASN1CTXT* pctxt, UL_FP_Mode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_FP_Mode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = normal_2; break;
         case 1: *pvalue = silent; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_FP_Mode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Synchronisation_StepSize                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Synchronisation_StepSize (ASN1CTXT* pctxt, UL_Synchronisation_StepSize* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Synchronisation_StepSize: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Synchronisation_StepSize: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Synchronisation_Frequency                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Synchronisation_Frequency (ASN1CTXT* pctxt, UL_Synchronisation_Frequency* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Synchronisation_Frequency: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Synchronisation_Frequency: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UpPTSInterferenceValue                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UpPTSInterferenceValue (ASN1CTXT* pctxt, UpPTSInterferenceValue* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UpPTSInterferenceValue: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, OSINTCONST(0), OSINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UpPTSInterferenceValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unidirectional_DCH_Indicator                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Unidirectional_DCH_Indicator (ASN1CTXT* pctxt, Unidirectional_DCH_Indicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_Unidirectional_DCH_Indicator: start\n");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = downlink_DCH_only; break;
      case 1: *pvalue = uplink_DCH_only; break;
      default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Unidirectional_DCH_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_TimeslotISCP_Value_IncrDecrThres                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_TimeslotISCP_Value_IncrDecrThres (ASN1CTXT* pctxt, UL_TimeslotISCP_Value_IncrDecrThres* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_TimeslotISCP_Value_IncrDecrThres: start\n");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(126));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_TimeslotISCP_Value_IncrDecrThres: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HARQ_MemoryPartitioningItem_process_Memory_Size           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HARQ_MemoryPartitioningItem_process_Memory_Size (ASN1CTXT* pctxt, HARQ_MemoryPartitioningItem_process_Memory_Size* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HARQ_MemoryPartitioningItem_process_Memory_Size: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ui;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(60));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = hms800; break;
         case 1: *pvalue = hms1600; break;
         case 2: *pvalue = hms2400; break;
         case 3: *pvalue = hms3200; break;
         case 4: *pvalue = hms4000; break;
         case 5: *pvalue = hms4800; break;
         case 6: *pvalue = hms5600; break;
         case 7: *pvalue = hms6400; break;
         case 8: *pvalue = hms7200; break;
         case 9: *pvalue = hms8000; break;
         case 10: *pvalue = hms8800; break;
         case 11: *pvalue = hms9600; break;
         case 12: *pvalue = hms10400; break;
         case 13: *pvalue = hms11200; break;
         case 14: *pvalue = hms12000; break;
         case 15: *pvalue = hms12800; break;
         case 16: *pvalue = hms13600; break;
         case 17: *pvalue = hms14400; break;
         case 18: *pvalue = hms15200; break;
         case 19: *pvalue = hms16000; break;
         case 20: *pvalue = hms17600; break;
         case 21: *pvalue = hms19200; break;
         case 22: *pvalue = hms20800; break;
         case 23: *pvalue = hms22400; break;
         case 24: *pvalue = hms24000; break;
         case 25: *pvalue = hms25600; break;
         case 26: *pvalue = hms27200; break;
         case 27: *pvalue = hms28800; break;
         case 28: *pvalue = hms30400; break;
         case 29: *pvalue = hms32000; break;
         case 30: *pvalue = hms36000; break;
         case 31: *pvalue = hms40000; break;
         case 32: *pvalue = hms44000; break;
         case 33: *pvalue = hms48000; break;
         case 34: *pvalue = hms52000; break;
         case 35: *pvalue = hms56000; break;
         case 36: *pvalue = hms60000; break;
         case 37: *pvalue = hms64000; break;
         case 38: *pvalue = hms68000; break;
         case 39: *pvalue = hms72000; break;
         case 40: *pvalue = hms76000; break;
         case 41: *pvalue = hms80000; break;
         case 42: *pvalue = hms88000; break;
         case 43: *pvalue = hms96000; break;
         case 44: *pvalue = hms104000; break;
         case 45: *pvalue = hms112000; break;
         case 46: *pvalue = hms120000; break;
         case 47: *pvalue = hms128000; break;
         case 48: *pvalue = hms136000; break;
         case 49: *pvalue = hms144000; break;
         case 50: *pvalue = hms152000; break;
         case 51: *pvalue = hms160000; break;
         case 52: *pvalue = hms176000; break;
         case 53: *pvalue = hms192000; break;
         case 54: *pvalue = hms208000; break;
         case 55: *pvalue = hms224000; break;
         case 56: *pvalue = hms240000; break;
         case 57: *pvalue = hms256000; break;
         case 58: *pvalue = hms272000; break;
         case 59: *pvalue = hms288000; break;
         case 60: *pvalue = hms304000; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HARQ_MemoryPartitioningItem_process_Memory_Size: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_gps_e_alm                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_ExtItem_gps_e_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_gps_e_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_gps_e_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_gps_e_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_gps_toa_alm                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_ExtItem_gps_toa_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_gps_toa_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_gps_toa_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_gps_toa_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_gps_delta_I_alm                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_ExtItem_gps_delta_I_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_gps_delta_I_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_gps_delta_I_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_gps_delta_I_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_omegadot_alm                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_ExtItem_omegadot_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_omegadot_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_omegadot_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_omegadot_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_svhealth_alm                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_ExtItem_svhealth_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_svhealth_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_svhealth_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_svhealth_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_gps_a_sqrt_alm                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_ExtItem_gps_a_sqrt_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_gps_a_sqrt_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_gps_a_sqrt_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_gps_a_sqrt_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_omegazero_alm                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_ExtItem_omegazero_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_omegazero_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_omegazero_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_omegazero_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_m_zero_alm                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_ExtItem_m_zero_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_m_zero_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_m_zero_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_m_zero_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_gps_omega_alm                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_ExtItem_gps_omega_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_gps_omega_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_gps_omega_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_gps_omega_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_gps_af_zero_alm                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_ExtItem_gps_af_zero_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_gps_af_zero_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(11), OSUINTCONST(11), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_gps_af_zero_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_gps_af_zero_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem_gps_af_one_alm                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_ExtItem_gps_af_one_alm (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem_gps_af_one_alm* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(11), OSUINTCONST(11), 0 };
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_gps_af_one_alm: start\n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem_gps_af_one_alm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transmission_Gap_Pattern_Sequence_Status_List_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Transmission_Gap_Pattern_Sequence_Status_List_element (ASN1CTXT* pctxt, Transmission_Gap_Pattern_Sequence_Status_List_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Transmission_Gap_Pattern_Sequence_Status_List_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode tGPSID */

   PU_PUSHNAME (pctxt, "tGPSID");

   stat = asn1PD_TGPSID (pctxt, &pvalue->tGPSID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tGPRC */

   PU_PUSHNAME (pctxt, "tGPRC");

   stat = asn1PD_TGPRC (pctxt, &pvalue->tGPRC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tGCFN */

   PU_PUSHNAME (pctxt, "tGCFN");

   stat = asn1PD_CFN (pctxt, &pvalue->tGCFN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Transmission_Gap_Pattern_Sequence_Status_List_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transmission_Gap_Pattern_Sequence_Status_List             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Transmission_Gap_Pattern_Sequence_Status_List (ASN1CTXT* pctxt, Transmission_Gap_Pattern_Sequence_Status_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(6), 0 };
   int stat = 0;
   Transmission_Gap_Pattern_Sequence_Status_List_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Transmission_Gap_Pattern_Sequence_Status_List: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Transmission_Gap_Pattern_Sequence_Status_List_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Transmission_Gap_Pattern_Sequence_Status_List_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Transmission_Gap_Pattern_Sequence_Status_List: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Active_Pattern_Sequence_Information                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Active_Pattern_Sequence_Information (ASN1CTXT* pctxt, Active_Pattern_Sequence_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Active_Pattern_Sequence_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "transmission_Gap_Pattern_Sequence_StatusPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transmission_Gap_Pattern_Sequence_StatusPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cMConfigurationChangeCFN */

   PU_PUSHNAME (pctxt, "cMConfigurationChangeCFN");

   stat = asn1PD_CFN (pctxt, &pvalue->cMConfigurationChangeCFN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode transmission_Gap_Pattern_Sequence_Status */

   if (pvalue->m.transmission_Gap_Pattern_Sequence_StatusPresent) {
      PU_PUSHNAME (pctxt, "transmission_Gap_Pattern_Sequence_Status");

      stat = asn1PD_Transmission_Gap_Pattern_Sequence_Status_List (pctxt, &pvalue->transmission_Gap_Pattern_Sequence_Status);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Active_Pattern_Sequence_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Angle_Of_Arrival_Value_LCR                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Angle_Of_Arrival_Value_LCR (ASN1CTXT* pctxt, Angle_Of_Arrival_Value_LCR* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Angle_Of_Arrival_Value_LCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode aOA_LCR */

   PU_PUSHNAME (pctxt, "aOA_LCR");

   stat = asn1PD_AOA_LCR (pctxt, &pvalue->aOA_LCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode aOA_LCR_Accuracy_Class */

   PU_PUSHNAME (pctxt, "aOA_LCR_Accuracy_Class");

   stat = asn1PD_AOA_LCR_Accuracy_Class (pctxt, &pvalue->aOA_LCR_Accuracy_Class);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Angle_Of_Arrival_Value_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Best_Cell_Portions_Item                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Best_Cell_Portions_Item (ASN1CTXT* pctxt, Best_Cell_Portions_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Best_Cell_Portions_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cellPortionID */

   PU_PUSHNAME (pctxt, "cellPortionID");

   stat = asn1PD_CellPortionID (pctxt, &pvalue->cellPortionID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sIRValue */

   PU_PUSHNAME (pctxt, "sIRValue");

   stat = asn1PD_SIR_Value (pctxt, &pvalue->sIRValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Best_Cell_Portions_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Best_Cell_Portions_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Best_Cell_Portions_Value (ASN1CTXT* pctxt, Best_Cell_Portions_Value* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   Best_Cell_Portions_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Best_Cell_Portions_Value: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Best_Cell_Portions_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Best_Cell_Portions_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Best_Cell_Portions_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonMeasurementAccuracy                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CommonMeasurementAccuracy (ASN1CTXT* pctxt, CommonMeasurementAccuracy* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementAccuracy: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* tUTRANGPSMeasurementAccuracyClass */
         case 0:
            PU_PUSHNAME (pctxt, "u.tUTRANGPSMeasurementAccuracyClass");

            stat = asn1PD_TUTRANGPSAccuracyClass (pctxt, &pvalue->u.tUTRANGPSMeasurementAccuracyClass);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonMeasurementAccuracy: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Common_PhysicalChannel_Status_Information                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Common_PhysicalChannel_Status_Information (ASN1CTXT* pctxt, Common_PhysicalChannel_Status_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Common_PhysicalChannel_Status_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonPhysicalChannelID */

   PU_PUSHNAME (pctxt, "commonPhysicalChannelID");

   stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->commonPhysicalChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode resourceOperationalState */

   PU_PUSHNAME (pctxt, "resourceOperationalState");

   stat = asn1PD_ResourceOperationalState (pctxt, &pvalue->resourceOperationalState);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode availabilityStatus */

   PU_PUSHNAME (pctxt, "availabilityStatus");

   stat = asn1PD_AvailabilityStatus (pctxt, &pvalue->availabilityStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Common_PhysicalChannel_Status_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Common_TransportChannel_Status_Information                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Common_TransportChannel_Status_Information (ASN1CTXT* pctxt, Common_TransportChannel_Status_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Common_TransportChannel_Status_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode commonTransportChannelID */

   PU_PUSHNAME (pctxt, "commonTransportChannelID");

   stat = asn1PD_CommonTransportChannelID (pctxt, &pvalue->commonTransportChannelID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode resourceOperationalState */

   PU_PUSHNAME (pctxt, "resourceOperationalState");

   stat = asn1PD_ResourceOperationalState (pctxt, &pvalue->resourceOperationalState);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode availabilityStatus */

   PU_PUSHNAME (pctxt, "availabilityStatus");

   stat = asn1PD_AvailabilityStatus (pctxt, &pvalue->availabilityStatus);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Common_TransportChannel_Status_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CriticalityDiagnostics_IE_List_element (ASN1CTXT* pctxt, CriticalityDiagnostics_IE_List_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics_IE_List_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "repetitionNumberPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.repetitionNumberPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode iECriticality */

   PU_PUSHNAME (pctxt, "iECriticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->iECriticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_ID */

   PU_PUSHNAME (pctxt, "iE_ID");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->iE_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionNumber */

   if (pvalue->m.repetitionNumberPresent) {
      PU_PUSHNAME (pctxt, "repetitionNumber");

      stat = asn1PD_RepetitionNumber0 (pctxt, &pvalue->repetitionNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics_IE_List_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CriticalityDiagnostics_IE_List (ASN1CTXT* pctxt, CriticalityDiagnostics_IE_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   CriticalityDiagnostics_IE_List_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics_IE_List: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CriticalityDiagnostics_IE_List_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_CriticalityDiagnostics_IE_List_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics_IE_List: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_CriticalityDiagnostics (ASN1CTXT* pctxt, CriticalityDiagnostics* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "procedureIDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.procedureIDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "triggeringMessagePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.triggeringMessagePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "procedureCriticalityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.procedureCriticalityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transactionIDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transactionIDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iEsCriticalityDiagnosticsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iEsCriticalityDiagnosticsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode procedureID */

   if (pvalue->m.procedureIDPresent) {
      PU_PUSHNAME (pctxt, "procedureID");

      stat = asn1PD_ProcedureID (pctxt, &pvalue->procedureID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode triggeringMessage */

   if (pvalue->m.triggeringMessagePresent) {
      PU_PUSHNAME (pctxt, "triggeringMessage");

      stat = asn1PD_TriggeringMessage (pctxt, &pvalue->triggeringMessage);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode procedureCriticality */

   if (pvalue->m.procedureCriticalityPresent) {
      PU_PUSHNAME (pctxt, "procedureCriticality");

      stat = asn1PD_Criticality (pctxt, &pvalue->procedureCriticality);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transactionID */

   if (pvalue->m.transactionIDPresent) {
      PU_PUSHNAME (pctxt, "transactionID");

      stat = asn1PD_TransactionID (pctxt, &pvalue->transactionID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iEsCriticalityDiagnostics */

   if (pvalue->m.iEsCriticalityDiagnosticsPresent) {
      PU_PUSHNAME (pctxt, "iEsCriticalityDiagnostics");

      stat = asn1PD_CriticalityDiagnostics_IE_List (pctxt, &pvalue->iEsCriticalityDiagnostics);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_Description_Indicator_Item                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Data_Description_Indicator_Item (ASN1CTXT* pctxt, Data_Description_Indicator_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Data_Description_Indicator_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "mACesGuaranteedBitRatePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mACesGuaranteedBitRatePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode e_DCH_DDI_Value */

   PU_PUSHNAME (pctxt, "e_DCH_DDI_Value");

   stat = asn1PD_E_DCH_DDI_Value (pctxt, &pvalue->e_DCH_DDI_Value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode associated_E_DCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "associated_E_DCH_MACdFlow_ID");

   stat = asn1PD_E_DCH_MACdFlow_ID (pctxt, &pvalue->associated_E_DCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode macdPDU_Size */

   PU_PUSHNAME (pctxt, "macdPDU_Size");

   stat = asn1PD_MACdPDU_Size (pctxt, &pvalue->macdPDU_Size);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode schedulingPriorityIndicator */

   PU_PUSHNAME (pctxt, "schedulingPriorityIndicator");

   stat = asn1PD_SchedulingPriorityIndicator (pctxt, &pvalue->schedulingPriorityIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode mACesGuaranteedBitRate */

   if (pvalue->m.mACesGuaranteedBitRatePresent) {
      PU_PUSHNAME (pctxt, "mACesGuaranteedBitRate");

      stat = asn1PD_MACesGuaranteedBitRate (pctxt, &pvalue->mACesGuaranteedBitRate);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Data_Description_Indicator_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_Description_Indicator                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Data_Description_Indicator (ASN1CTXT* pctxt, Data_Description_Indicator* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;
   Data_Description_Indicator_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Data_Description_Indicator: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Data_Description_Indicator_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Data_Description_Indicator_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Data_Description_Indicator: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_Specific_FDD_Item                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_Specific_FDD_Item (ASN1CTXT* pctxt, DCH_Specific_FDD_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_Specific_FDD_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dCH_ID */

   PU_PUSHNAME (pctxt, "dCH_ID");

   stat = asn1PD_DCH_ID (pctxt, &pvalue->dCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_TransportFormatSet */

   PU_PUSHNAME (pctxt, "ul_TransportFormatSet");

   stat = asn1PD_TransportFormatSet (pctxt, &pvalue->ul_TransportFormatSet);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_TransportFormatSet */

   PU_PUSHNAME (pctxt, "dl_TransportFormatSet");

   stat = asn1PD_TransportFormatSet (pctxt, &pvalue->dl_TransportFormatSet);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode allocationRetentionPriority */

   PU_PUSHNAME (pctxt, "allocationRetentionPriority");

   stat = asn1PD_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode frameHandlingPriority */

   PU_PUSHNAME (pctxt, "frameHandlingPriority");

   stat = asn1PD_FrameHandlingPriority (pctxt, &pvalue->frameHandlingPriority);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode qE_Selector */

   PU_PUSHNAME (pctxt, "qE_Selector");

   stat = asn1PD_QE_Selector (pctxt, &pvalue->qE_Selector);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_Specific_FDD_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_Specific_FDD_InformationList                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_Specific_FDD_InformationList (ASN1CTXT* pctxt, DCH_Specific_FDD_InformationList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   DCH_Specific_FDD_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_Specific_FDD_InformationList: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DCH_Specific_FDD_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DCH_Specific_FDD_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_Specific_FDD_InformationList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_FDD_InformationItem                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_FDD_InformationItem (ASN1CTXT* pctxt, DCH_FDD_InformationItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_FDD_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode payloadCRC_PresenceIndicator */

   PU_PUSHNAME (pctxt, "payloadCRC_PresenceIndicator");

   stat = asn1PD_PayloadCRC_PresenceIndicator (pctxt, &pvalue->payloadCRC_PresenceIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_FP_Mode */

   PU_PUSHNAME (pctxt, "ul_FP_Mode");

   stat = asn1PD_UL_FP_Mode (pctxt, &pvalue->ul_FP_Mode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode toAWS */

   PU_PUSHNAME (pctxt, "toAWS");

   stat = asn1PD_ToAWS (pctxt, &pvalue->toAWS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode toAWE */

   PU_PUSHNAME (pctxt, "toAWE");

   stat = asn1PD_ToAWE (pctxt, &pvalue->toAWE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dCH_SpecificInformationList */

   PU_PUSHNAME (pctxt, "dCH_SpecificInformationList");

   stat = asn1PD_DCH_Specific_FDD_InformationList (pctxt, &pvalue->dCH_SpecificInformationList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_FDD_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_FDD_Information                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_FDD_Information (ASN1CTXT* pctxt, DCH_FDD_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   DCH_FDD_InformationItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_FDD_Information: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DCH_FDD_InformationItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DCH_FDD_InformationItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_FDD_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_Specific_TDD_Item                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_Specific_TDD_Item (ASN1CTXT* pctxt, DCH_Specific_TDD_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_Specific_TDD_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "qE_SelectorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.qE_SelectorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dCH_ID */

   PU_PUSHNAME (pctxt, "dCH_ID");

   stat = asn1PD_DCH_ID (pctxt, &pvalue->dCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_CCTrCH_ID */

   PU_PUSHNAME (pctxt, "ul_CCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->ul_CCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_CCTrCH_ID */

   PU_PUSHNAME (pctxt, "dl_CCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->dl_CCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_TransportFormatSet */

   PU_PUSHNAME (pctxt, "ul_TransportFormatSet");

   stat = asn1PD_TransportFormatSet (pctxt, &pvalue->ul_TransportFormatSet);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_TransportFormatSet */

   PU_PUSHNAME (pctxt, "dl_TransportFormatSet");

   stat = asn1PD_TransportFormatSet (pctxt, &pvalue->dl_TransportFormatSet);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode allocationRetentionPriority */

   PU_PUSHNAME (pctxt, "allocationRetentionPriority");

   stat = asn1PD_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode frameHandlingPriority */

   PU_PUSHNAME (pctxt, "frameHandlingPriority");

   stat = asn1PD_FrameHandlingPriority (pctxt, &pvalue->frameHandlingPriority);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode qE_Selector */

   if (pvalue->m.qE_SelectorPresent) {
      PU_PUSHNAME (pctxt, "qE_Selector");

      stat = asn1PD_QE_Selector (pctxt, &pvalue->qE_Selector);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_Specific_TDD_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_Specific_TDD_InformationList                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_Specific_TDD_InformationList (ASN1CTXT* pctxt, DCH_Specific_TDD_InformationList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   DCH_Specific_TDD_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_Specific_TDD_InformationList: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DCH_Specific_TDD_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DCH_Specific_TDD_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_Specific_TDD_InformationList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_TDD_InformationItem                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_TDD_InformationItem (ASN1CTXT* pctxt, DCH_TDD_InformationItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_TDD_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode payloadCRC_PresenceIndicator */

   PU_PUSHNAME (pctxt, "payloadCRC_PresenceIndicator");

   stat = asn1PD_PayloadCRC_PresenceIndicator (pctxt, &pvalue->payloadCRC_PresenceIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_FP_Mode */

   PU_PUSHNAME (pctxt, "ul_FP_Mode");

   stat = asn1PD_UL_FP_Mode (pctxt, &pvalue->ul_FP_Mode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode toAWS */

   PU_PUSHNAME (pctxt, "toAWS");

   stat = asn1PD_ToAWS (pctxt, &pvalue->toAWS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode toAWE */

   PU_PUSHNAME (pctxt, "toAWE");

   stat = asn1PD_ToAWE (pctxt, &pvalue->toAWE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dCH_SpecificInformationList */

   PU_PUSHNAME (pctxt, "dCH_SpecificInformationList");

   stat = asn1PD_DCH_Specific_TDD_InformationList (pctxt, &pvalue->dCH_SpecificInformationList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_TDD_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_TDD_Information                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_TDD_Information (ASN1CTXT* pctxt, DCH_TDD_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   DCH_TDD_InformationItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_TDD_Information: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DCH_TDD_InformationItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DCH_TDD_InformationItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_TDD_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_ModifySpecificItem_FDD                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_ModifySpecificItem_FDD (ASN1CTXT* pctxt, DCH_ModifySpecificItem_FDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_ModifySpecificItem_FDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ul_TransportFormatSetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_TransportFormatSetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dl_TransportFormatSetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_TransportFormatSetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "allocationRetentionPriorityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.allocationRetentionPriorityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "frameHandlingPriorityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.frameHandlingPriorityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dCH_ID */

   PU_PUSHNAME (pctxt, "dCH_ID");

   stat = asn1PD_DCH_ID (pctxt, &pvalue->dCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_TransportFormatSet */

   if (pvalue->m.ul_TransportFormatSetPresent) {
      PU_PUSHNAME (pctxt, "ul_TransportFormatSet");

      stat = asn1PD_TransportFormatSet (pctxt, &pvalue->ul_TransportFormatSet);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dl_TransportFormatSet */

   if (pvalue->m.dl_TransportFormatSetPresent) {
      PU_PUSHNAME (pctxt, "dl_TransportFormatSet");

      stat = asn1PD_TransportFormatSet (pctxt, &pvalue->dl_TransportFormatSet);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode allocationRetentionPriority */

   if (pvalue->m.allocationRetentionPriorityPresent) {
      PU_PUSHNAME (pctxt, "allocationRetentionPriority");

      stat = asn1PD_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode frameHandlingPriority */

   if (pvalue->m.frameHandlingPriorityPresent) {
      PU_PUSHNAME (pctxt, "frameHandlingPriority");

      stat = asn1PD_FrameHandlingPriority (pctxt, &pvalue->frameHandlingPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_ModifySpecificItem_FDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_ModifySpecificInformation_FDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_ModifySpecificInformation_FDD (ASN1CTXT* pctxt, DCH_ModifySpecificInformation_FDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   DCH_ModifySpecificItem_FDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_ModifySpecificInformation_FDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DCH_ModifySpecificItem_FDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DCH_ModifySpecificItem_FDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_ModifySpecificInformation_FDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FDD_DCHs_to_ModifyItem                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FDD_DCHs_to_ModifyItem (ASN1CTXT* pctxt, FDD_DCHs_to_ModifyItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_FDD_DCHs_to_ModifyItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ul_FP_ModePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_FP_ModePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "toAWSPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.toAWSPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "toAWEPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.toAWEPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode ul_FP_Mode */

   if (pvalue->m.ul_FP_ModePresent) {
      PU_PUSHNAME (pctxt, "ul_FP_Mode");

      stat = asn1PD_UL_FP_Mode (pctxt, &pvalue->ul_FP_Mode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode toAWS */

   if (pvalue->m.toAWSPresent) {
      PU_PUSHNAME (pctxt, "toAWS");

      stat = asn1PD_ToAWS (pctxt, &pvalue->toAWS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode toAWE */

   if (pvalue->m.toAWEPresent) {
      PU_PUSHNAME (pctxt, "toAWE");

      stat = asn1PD_ToAWE (pctxt, &pvalue->toAWE);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportBearerRequestIndicator */

   PU_PUSHNAME (pctxt, "transportBearerRequestIndicator");

   stat = asn1PD_TransportBearerRequestIndicator (pctxt, &pvalue->transportBearerRequestIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dCH_SpecificInformationList */

   PU_PUSHNAME (pctxt, "dCH_SpecificInformationList");

   stat = asn1PD_DCH_ModifySpecificInformation_FDD (pctxt, &pvalue->dCH_SpecificInformationList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FDD_DCHs_to_ModifyItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FDD_DCHs_to_Modify                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_FDD_DCHs_to_Modify (ASN1CTXT* pctxt, FDD_DCHs_to_Modify* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   FDD_DCHs_to_ModifyItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_FDD_DCHs_to_Modify: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, FDD_DCHs_to_ModifyItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_FDD_DCHs_to_ModifyItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FDD_DCHs_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_ModifySpecificItem_TDD                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_ModifySpecificItem_TDD (ASN1CTXT* pctxt, DCH_ModifySpecificItem_TDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_ModifySpecificItem_TDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ul_CCTrCH_IDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_CCTrCH_IDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dl_CCTrCH_IDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_CCTrCH_IDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ul_TransportFormatSetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_TransportFormatSetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dl_TransportFormatSetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dl_TransportFormatSetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "allocationRetentionPriorityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.allocationRetentionPriorityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "frameHandlingPriorityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.frameHandlingPriorityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dCH_ID */

   PU_PUSHNAME (pctxt, "dCH_ID");

   stat = asn1PD_DCH_ID (pctxt, &pvalue->dCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ul_CCTrCH_ID */

   if (pvalue->m.ul_CCTrCH_IDPresent) {
      PU_PUSHNAME (pctxt, "ul_CCTrCH_ID");

      stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->ul_CCTrCH_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dl_CCTrCH_ID */

   if (pvalue->m.dl_CCTrCH_IDPresent) {
      PU_PUSHNAME (pctxt, "dl_CCTrCH_ID");

      stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->dl_CCTrCH_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ul_TransportFormatSet */

   if (pvalue->m.ul_TransportFormatSetPresent) {
      PU_PUSHNAME (pctxt, "ul_TransportFormatSet");

      stat = asn1PD_TransportFormatSet (pctxt, &pvalue->ul_TransportFormatSet);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dl_TransportFormatSet */

   if (pvalue->m.dl_TransportFormatSetPresent) {
      PU_PUSHNAME (pctxt, "dl_TransportFormatSet");

      stat = asn1PD_TransportFormatSet (pctxt, &pvalue->dl_TransportFormatSet);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode allocationRetentionPriority */

   if (pvalue->m.allocationRetentionPriorityPresent) {
      PU_PUSHNAME (pctxt, "allocationRetentionPriority");

      stat = asn1PD_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode frameHandlingPriority */

   if (pvalue->m.frameHandlingPriorityPresent) {
      PU_PUSHNAME (pctxt, "frameHandlingPriority");

      stat = asn1PD_FrameHandlingPriority (pctxt, &pvalue->frameHandlingPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_ModifySpecificItem_TDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_ModifySpecificInformation_TDD                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_ModifySpecificInformation_TDD (ASN1CTXT* pctxt, DCH_ModifySpecificInformation_TDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   DCH_ModifySpecificItem_TDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_ModifySpecificInformation_TDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DCH_ModifySpecificItem_TDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DCH_ModifySpecificItem_TDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_ModifySpecificInformation_TDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_ModifyItem_TDD                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DCH_ModifyItem_TDD (ASN1CTXT* pctxt, DCH_ModifyItem_TDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_ModifyItem_TDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ul_FP_ModePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ul_FP_ModePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "toAWSPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.toAWSPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "toAWEPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.toAWEPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode ul_FP_Mode */

   if (pvalue->m.ul_FP_ModePresent) {
      PU_PUSHNAME (pctxt, "ul_FP_Mode");

      stat = asn1PD_UL_FP_Mode (pctxt, &pvalue->ul_FP_Mode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode toAWS */

   if (pvalue->m.toAWSPresent) {
      PU_PUSHNAME (pctxt, "toAWS");

      stat = asn1PD_ToAWS (pctxt, &pvalue->toAWS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode toAWE */

   if (pvalue->m.toAWEPresent) {
      PU_PUSHNAME (pctxt, "toAWE");

      stat = asn1PD_ToAWE (pctxt, &pvalue->toAWE);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportBearerRequestIndicator */

   PU_PUSHNAME (pctxt, "transportBearerRequestIndicator");

   stat = asn1PD_TransportBearerRequestIndicator (pctxt, &pvalue->transportBearerRequestIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dCH_SpecificInformationList */

   PU_PUSHNAME (pctxt, "dCH_SpecificInformationList");

   stat = asn1PD_DCH_ModifySpecificInformation_TDD (pctxt, &pvalue->dCH_SpecificInformationList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DCH_ModifyItem_TDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TDD_DCHs_to_Modify                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TDD_DCHs_to_Modify (ASN1CTXT* pctxt, TDD_DCHs_to_Modify* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   DCH_ModifyItem_TDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_DCHs_to_Modify: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DCH_ModifyItem_TDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DCH_ModifyItem_TDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TDD_DCHs_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DelayedActivation                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DelayedActivation (ASN1CTXT* pctxt, DelayedActivation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_DelayedActivation: start\n");

   PU_PUSHNAME (pctxt, "t");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (pctxt);

   switch (ui) {
      /* cfn */
      case 0:
         PU_PUSHNAME (pctxt, "u.cfn");

         stat = asn1PD_CFN (pctxt, &pvalue->u.cfn);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         PU_POPNAME (pctxt);

         break;

      /* separate_indication */
      case 1:
         PU_PUSHNAME (pctxt, "u.separate_indication");

         /* NULL */

         PU_POPNAME (pctxt);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DelayedActivation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DGPSThresholds                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DGPSThresholds (ASN1CTXT* pctxt, DGPSThresholds* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DGPSThresholds: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ie_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode prcdeviation */

   PU_PUSHNAME (pctxt, "prcdeviation");

   stat = asn1PD_PRCDeviation (pctxt, &pvalue->prcdeviation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DGPSThresholds: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_ReferencePowerInformationItem                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_ReferencePowerInformationItem (ASN1CTXT* pctxt, DL_ReferencePowerInformationItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_ReferencePowerInformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dl_Reference_Power */

   PU_PUSHNAME (pctxt, "dl_Reference_Power");

   stat = asn1PD_DL_Power (pctxt, &pvalue->dl_Reference_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_ReferencePowerInformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_ReferencePowerInformationList                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_ReferencePowerInformationList (ASN1CTXT* pctxt, DL_ReferencePowerInformationList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   DL_ReferencePowerInformationItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_ReferencePowerInformationList: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_ReferencePowerInformationItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_ReferencePowerInformationItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_ReferencePowerInformationList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_PowerBalancing_Information                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_PowerBalancing_Information (ASN1CTXT* pctxt, DL_PowerBalancing_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_PowerBalancing_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "dLReferencePowerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dLReferencePowerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dLReferencePowerList_DL_PC_RqstPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dLReferencePowerList_DL_PC_RqstPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "maxAdjustmentStepPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maxAdjustmentStepPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "adjustmentPeriodPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.adjustmentPeriodPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "adjustmentRatioPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.adjustmentRatioPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode powerAdjustmentType */

   PU_PUSHNAME (pctxt, "powerAdjustmentType");

   stat = asn1PD_PowerAdjustmentType (pctxt, &pvalue->powerAdjustmentType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dLReferencePower */

   if (pvalue->m.dLReferencePowerPresent) {
      PU_PUSHNAME (pctxt, "dLReferencePower");

      stat = asn1PD_DL_Power (pctxt, &pvalue->dLReferencePower);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dLReferencePowerList_DL_PC_Rqst */

   if (pvalue->m.dLReferencePowerList_DL_PC_RqstPresent) {
      PU_PUSHNAME (pctxt, "dLReferencePowerList_DL_PC_Rqst");

      stat = asn1PD_DL_ReferencePowerInformationList (pctxt, &pvalue->dLReferencePowerList_DL_PC_Rqst);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode maxAdjustmentStep */

   if (pvalue->m.maxAdjustmentStepPresent) {
      PU_PUSHNAME (pctxt, "maxAdjustmentStep");

      stat = asn1PD_MaxAdjustmentStep (pctxt, &pvalue->maxAdjustmentStep);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode adjustmentPeriod */

   if (pvalue->m.adjustmentPeriodPresent) {
      PU_PUSHNAME (pctxt, "adjustmentPeriod");

      stat = asn1PD_AdjustmentPeriod (pctxt, &pvalue->adjustmentPeriod);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode adjustmentRatio */

   if (pvalue->m.adjustmentRatioPresent) {
      PU_PUSHNAME (pctxt, "adjustmentRatio");

      stat = asn1PD_ScaledAdjustmentRatio (pctxt, &pvalue->adjustmentRatio);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_PowerBalancing_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_TimeslotISCPInfoItemLCR                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_TimeslotISCPInfoItemLCR (ASN1CTXT* pctxt, DL_TimeslotISCPInfoItemLCR* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_TimeslotISCPInfoItemLCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeSlotLCR */

   PU_PUSHNAME (pctxt, "timeSlotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode dL_TimeslotISCP */

   PU_PUSHNAME (pctxt, "dL_TimeslotISCP");

   stat = asn1PD_DL_TimeslotISCP (pctxt, &pvalue->dL_TimeslotISCP);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_TimeslotISCPInfoItemLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_TimeslotISCPInfoLCR                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DL_TimeslotISCPInfoLCR (ASN1CTXT* pctxt, DL_TimeslotISCPInfoLCR* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(6), 0 };
   int stat = 0;
   DL_TimeslotISCPInfoItemLCR* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_TimeslotISCPInfoLCR: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DL_TimeslotISCPInfoItemLCR);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DL_TimeslotISCPInfoItemLCR (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_TimeslotISCPInfoLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_InformationResponseItem                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DSCH_InformationResponseItem (ASN1CTXT* pctxt, DSCH_InformationResponseItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_InformationResponseItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bindingIDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportLayerAddressPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dSCH_ID */

   PU_PUSHNAME (pctxt, "dSCH_ID");

   stat = asn1PD_DSCH_ID (pctxt, &pvalue->dSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PD_BindingID (pctxt, &pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_InformationResponseItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_InformationResponse                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DSCH_InformationResponse (ASN1CTXT* pctxt, DSCH_InformationResponse* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   DSCH_InformationResponseItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_InformationResponse: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DSCH_InformationResponseItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DSCH_InformationResponseItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_InformationResponse: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_TDD_InformationItem                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DSCH_TDD_InformationItem (ASN1CTXT* pctxt, DSCH_TDD_InformationItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_TDD_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dSCH_ID */

   PU_PUSHNAME (pctxt, "dSCH_ID");

   stat = asn1PD_DSCH_ID (pctxt, &pvalue->dSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode transportFormatSet */

   PU_PUSHNAME (pctxt, "transportFormatSet");

   stat = asn1PD_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode allocationRetentionPriority */

   PU_PUSHNAME (pctxt, "allocationRetentionPriority");

   stat = asn1PD_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode frameHandlingPriority */

   PU_PUSHNAME (pctxt, "frameHandlingPriority");

   stat = asn1PD_FrameHandlingPriority (pctxt, &pvalue->frameHandlingPriority);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode toAWS */

   PU_PUSHNAME (pctxt, "toAWS");

   stat = asn1PD_ToAWS (pctxt, &pvalue->toAWS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode toAWE */

   PU_PUSHNAME (pctxt, "toAWE");

   stat = asn1PD_ToAWE (pctxt, &pvalue->toAWE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_TDD_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_TDD_Information                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_DSCH_TDD_Information (ASN1CTXT* pctxt, DSCH_TDD_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   DSCH_TDD_InformationItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_TDD_Information: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, DSCH_TDD_InformationItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_DSCH_TDD_InformationItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DSCH_TDD_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_AGCH_FDD_Code_List                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_AGCH_FDD_Code_List (ASN1CTXT* pctxt, E_AGCH_FDD_Code_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_AGCH_FDD_Code_List: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   if (1 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PD_E_AGCH_FDD_Code_Information_Item (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_AGCH_FDD_Code_List: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_AGCH_FDD_Code_Information                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_AGCH_FDD_Code_Information (ASN1CTXT* pctxt, E_AGCH_FDD_Code_Information* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_AGCH_FDD_Code_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* replace */
         case 0:
            PU_PUSHNAME (pctxt, "u.replace");

            pvalue->u.replace = rtMemAllocTypeZ (pctxt, E_AGCH_FDD_Code_List);
            if (pvalue->u.replace == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_E_AGCH_FDD_Code_List (pctxt, pvalue->u.replace);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* remove_ */
         case 1:
            PU_PUSHNAME (pctxt, "u.remove_");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_AGCH_FDD_Code_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_FDD_DL_Control_Channel_Information                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_FDD_DL_Control_Channel_Information (ASN1CTXT* pctxt, E_DCH_FDD_DL_Control_Channel_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_FDD_DL_Control_Channel_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "e_AGCH_And_E_RGCH_E_HICH_FDD_Scrambling_CodePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.e_AGCH_And_E_RGCH_E_HICH_FDD_Scrambling_CodePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "e_AGCH_Channelisation_CodePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.e_AGCH_Channelisation_CodePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "primary_e_RNTIPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.primary_e_RNTIPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "secondary_e_RNTIPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.secondary_e_RNTIPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "e_RGCH_Signature_SequencePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.e_RGCH_Signature_SequencePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode e_AGCH_And_E_RGCH_E_HICH_FDD_Scrambling_Code */

   if (pvalue->m.e_AGCH_And_E_RGCH_E_HICH_FDD_Scrambling_CodePresent) {
      PU_PUSHNAME (pctxt, "e_AGCH_And_E_RGCH_E_HICH_FDD_Scrambling_Code");

      stat = asn1PD_DL_ScramblingCode (pctxt, &pvalue->e_AGCH_And_E_RGCH_E_HICH_FDD_Scrambling_Code);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode e_AGCH_Channelisation_Code */

   if (pvalue->m.e_AGCH_Channelisation_CodePresent) {
      PU_PUSHNAME (pctxt, "e_AGCH_Channelisation_Code");

      stat = asn1PD_FDD_DL_ChannelisationCodeNumber (pctxt, &pvalue->e_AGCH_Channelisation_Code);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode primary_e_RNTI */

   if (pvalue->m.primary_e_RNTIPresent) {
      PU_PUSHNAME (pctxt, "primary_e_RNTI");

      stat = asn1PD_E_RNTI (pctxt, &pvalue->primary_e_RNTI);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode secondary_e_RNTI */

   if (pvalue->m.secondary_e_RNTIPresent) {
      PU_PUSHNAME (pctxt, "secondary_e_RNTI");

      stat = asn1PD_E_RNTI (pctxt, &pvalue->secondary_e_RNTI);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode e_RGCH_E_HICH_Channelisation_Code */

   PU_PUSHNAME (pctxt, "e_RGCH_E_HICH_Channelisation_Code");

   stat = asn1PD_FDD_DL_ChannelisationCodeNumber (pctxt, &pvalue->e_RGCH_E_HICH_Channelisation_Code);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode e_RGCH_Signature_Sequence */

   if (pvalue->m.e_RGCH_Signature_SequencePresent) {
      PU_PUSHNAME (pctxt, "e_RGCH_Signature_Sequence");

      stat = asn1PD_E_RGCH_Signature_Sequence (pctxt, &pvalue->e_RGCH_Signature_Sequence);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode e_HICH_Signature_Sequence */

   PU_PUSHNAME (pctxt, "e_HICH_Signature_Sequence");

   stat = asn1PD_E_HICH_Signature_Sequence (pctxt, &pvalue->e_HICH_Signature_Sequence);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_FDD_DL_Control_Channel_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TnlQos                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TnlQos (ASN1CTXT* pctxt, TnlQos* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TnlQos: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* dsField */
         case 0:
            PU_PUSHNAME (pctxt, "u.dsField");

            pvalue->u.dsField = rtMemAllocTypeZ (pctxt, DsField);
            if (pvalue->u.dsField == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_DsField (pctxt, pvalue->u.dsField);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* genericTrafficCategory */
         case 1:
            PU_PUSHNAME (pctxt, "u.genericTrafficCategory");

            pvalue->u.genericTrafficCategory = rtMemAllocTypeZ (pctxt, GenericTrafficCategory);
            if (pvalue->u.genericTrafficCategory == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_GenericTrafficCategory (pctxt, pvalue->u.genericTrafficCategory);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TnlQos: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_Non_Scheduled_Transmission_Grant_Items              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_Non_Scheduled_Transmission_Grant_Items (ASN1CTXT* pctxt, E_DCH_Non_Scheduled_Transmission_Grant_Items* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_Non_Scheduled_Transmission_Grant_Items: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "hARQ_Process_Allocation_2msPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hARQ_Process_Allocation_2msPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode maxBits_MACe_PDU_non_scheduled */

   PU_PUSHNAME (pctxt, "maxBits_MACe_PDU_non_scheduled");

   stat = asn1PD_Max_Bits_MACe_PDU_non_scheduled (pctxt, &pvalue->maxBits_MACe_PDU_non_scheduled);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode hARQ_Process_Allocation_2ms */

   if (pvalue->m.hARQ_Process_Allocation_2msPresent) {
      PU_PUSHNAME (pctxt, "hARQ_Process_Allocation_2ms");

      stat = asn1PD_HARQ_Process_Allocation_2ms_EDCH (pctxt, &pvalue->hARQ_Process_Allocation_2ms);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_Non_Scheduled_Transmission_Grant_Items: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_Grant_Type_Information                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_Grant_Type_Information (ASN1CTXT* pctxt, E_DCH_Grant_Type_Information* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_Grant_Type_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* e_DCH_Non_Scheduled_Transmission_Grant */
         case 0:
            PU_PUSHNAME (pctxt, "u.e_DCH_Non_Scheduled_Transmission_Grant");

            pvalue->u.e_DCH_Non_Scheduled_Transmission_Grant = rtMemAllocTypeZ (pctxt, E_DCH_Non_Scheduled_Transmission_Grant_Items);
            if (pvalue->u.e_DCH_Non_Scheduled_Transmission_Grant == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_E_DCH_Non_Scheduled_Transmission_Grant_Items (pctxt, pvalue->u.e_DCH_Non_Scheduled_Transmission_Grant);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* e_DCH_Scheduled_Transmission_Grant */
         case 1:
            PU_PUSHNAME (pctxt, "u.e_DCH_Scheduled_Transmission_Grant");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_Grant_Type_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlow_Specific_InfoItem                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_MACdFlow_Specific_InfoItem (ASN1CTXT* pctxt, E_DCH_MACdFlow_Specific_InfoItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlow_Specific_InfoItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bindingIDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportLayerAddressPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tnlQosPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tnlQosPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "eDCH_MACdFlow_Multiplexing_ListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.eDCH_MACdFlow_Multiplexing_ListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bundlingModeIndicatorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bundlingModeIndicatorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode e_DCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "e_DCH_MACdFlow_ID");

   stat = asn1PD_E_DCH_MACdFlow_ID (pctxt, &pvalue->e_DCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PD_BindingID (pctxt, &pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode allocationRetentionPriority */

   PU_PUSHNAME (pctxt, "allocationRetentionPriority");

   stat = asn1PD_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tnlQos */

   if (pvalue->m.tnlQosPresent) {
      PU_PUSHNAME (pctxt, "tnlQos");

      stat = asn1PD_TnlQos (pctxt, &pvalue->tnlQos);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode payloadCRC_PresenceIndicator */

   PU_PUSHNAME (pctxt, "payloadCRC_PresenceIndicator");

   stat = asn1PD_PayloadCRC_PresenceIndicator (pctxt, &pvalue->payloadCRC_PresenceIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode maximum_Number_of_Retransmissions_For_E_DCH */

   PU_PUSHNAME (pctxt, "maximum_Number_of_Retransmissions_For_E_DCH");

   stat = asn1PD_Maximum_Number_of_Retransmissions_For_E_DCH (pctxt, &pvalue->maximum_Number_of_Retransmissions_For_E_DCH);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode eDCH_HARQ_PO_FDD */

   PU_PUSHNAME (pctxt, "eDCH_HARQ_PO_FDD");

   stat = asn1PD_E_DCH_HARQ_PO_FDD (pctxt, &pvalue->eDCH_HARQ_PO_FDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode eDCH_MACdFlow_Multiplexing_List */

   if (pvalue->m.eDCH_MACdFlow_Multiplexing_ListPresent) {
      PU_PUSHNAME (pctxt, "eDCH_MACdFlow_Multiplexing_List");

      stat = asn1PD_E_DCH_MACdFlow_Multiplexing_List (pctxt, &pvalue->eDCH_MACdFlow_Multiplexing_List);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode eDCH_Grant_Type_Information */

   PU_PUSHNAME (pctxt, "eDCH_Grant_Type_Information");

   stat = asn1PD_E_DCH_Grant_Type_Information (pctxt, &pvalue->eDCH_Grant_Type_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode bundlingModeIndicator */

   if (pvalue->m.bundlingModeIndicatorPresent) {
      PU_PUSHNAME (pctxt, "bundlingModeIndicator");

      stat = asn1PD_BundlingModeIndicator (pctxt, &pvalue->bundlingModeIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlow_Specific_InfoItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlow_Specific_InfoList                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_MACdFlow_Specific_InfoList (ASN1CTXT* pctxt, E_DCH_MACdFlow_Specific_InfoList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   E_DCH_MACdFlow_Specific_InfoItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlow_Specific_InfoList: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, E_DCH_MACdFlow_Specific_InfoItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_E_DCH_MACdFlow_Specific_InfoItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlow_Specific_InfoList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlows_Information                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_MACdFlows_Information (ASN1CTXT* pctxt, E_DCH_MACdFlows_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlows_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode e_DCH_MACdFlow_Specific_Info */

   PU_PUSHNAME (pctxt, "e_DCH_MACdFlow_Specific_Info");

   stat = asn1PD_E_DCH_MACdFlow_Specific_InfoList (pctxt, &pvalue->e_DCH_MACdFlow_Specific_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode data_Description_Indicator */

   PU_PUSHNAME (pctxt, "data_Description_Indicator");

   stat = asn1PD_Data_Description_Indicator (pctxt, &pvalue->data_Description_Indicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlows_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UE_E_DCH_Capability_Information                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UE_E_DCH_Capability_Information (ASN1CTXT* pctxt, UE_E_DCH_Capability_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_E_DCH_Capability_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode maximum_Allowed_UE_UL_Tx_Power */

   PU_PUSHNAME (pctxt, "maximum_Allowed_UE_UL_Tx_Power");

   stat = asn1PD_Maximum_Allowed_UE_UL_Tx_Power (pctxt, &pvalue->maximum_Allowed_UE_UL_Tx_Power);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_E_DCH_Capability_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_FDD_Information                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_FDD_Information (ASN1CTXT* pctxt, E_DCH_FDD_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_FDD_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode e_DCH_MACdFlows_Information */

   PU_PUSHNAME (pctxt, "e_DCH_MACdFlows_Information");

   stat = asn1PD_E_DCH_MACdFlows_Information (pctxt, &pvalue->e_DCH_MACdFlows_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ue_E_DCH_Capability_Info */

   PU_PUSHNAME (pctxt, "ue_E_DCH_Capability_Info");

   stat = asn1PD_UE_E_DCH_Capability_Information (pctxt, &pvalue->ue_E_DCH_Capability_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_FDD_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlow_Specific_InformationResp_Item              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_MACdFlow_Specific_InformationResp_Item (ASN1CTXT* pctxt, E_DCH_MACdFlow_Specific_InformationResp_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlow_Specific_InformationResp_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bindingIDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportLayerAddressPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode e_DCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "e_DCH_MACdFlow_ID");

   stat = asn1PD_E_DCH_MACdFlow_ID (pctxt, &pvalue->e_DCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PD_BindingID (pctxt, &pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlow_Specific_InformationResp_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlow_Specific_InformationResp                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_MACdFlow_Specific_InformationResp (ASN1CTXT* pctxt, E_DCH_MACdFlow_Specific_InformationResp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   E_DCH_MACdFlow_Specific_InformationResp_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlow_Specific_InformationResp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, E_DCH_MACdFlow_Specific_InformationResp_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_E_DCH_MACdFlow_Specific_InformationResp_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlow_Specific_InformationResp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_FDD_Information_Response                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_FDD_Information_Response (ASN1CTXT* pctxt, E_DCH_FDD_Information_Response* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_FDD_Information_Response: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "e_DCH_MACdFlow_Specific_InformationRespPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.e_DCH_MACdFlow_Specific_InformationRespPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode e_DCH_MACdFlow_Specific_InformationResp */

   if (pvalue->m.e_DCH_MACdFlow_Specific_InformationRespPresent) {
      PU_PUSHNAME (pctxt, "e_DCH_MACdFlow_Specific_InformationResp");

      stat = asn1PD_E_DCH_MACdFlow_Specific_InformationResp (pctxt, &pvalue->e_DCH_MACdFlow_Specific_InformationResp);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_FDD_Information_Response: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlow_Specific_InfoItem_to_Modify                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_MACdFlow_Specific_InfoItem_to_Modify (ASN1CTXT* pctxt, E_DCH_MACdFlow_Specific_InfoItem_to_Modify* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlow_Specific_InfoItem_to_Modify: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "allocationRetentionPriorityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.allocationRetentionPriorityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bindingIDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportLayerAddressPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tnlQosPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tnlQosPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "maximum_Number_of_Retransmissions_For_E_DCHPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maximum_Number_of_Retransmissions_For_E_DCHPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "eDCH_MACdFlow_Multiplexing_ListPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.eDCH_MACdFlow_Multiplexing_ListPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "eDCH_Grant_Type_InformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.eDCH_Grant_Type_InformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode e_DCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "e_DCH_MACdFlow_ID");

   stat = asn1PD_E_DCH_MACdFlow_ID (pctxt, &pvalue->e_DCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode allocationRetentionPriority */

   if (pvalue->m.allocationRetentionPriorityPresent) {
      PU_PUSHNAME (pctxt, "allocationRetentionPriority");

      stat = asn1PD_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportBearerRequestIndicator */

   PU_PUSHNAME (pctxt, "transportBearerRequestIndicator");

   stat = asn1PD_TransportBearerRequestIndicator (pctxt, &pvalue->transportBearerRequestIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PD_BindingID (pctxt, &pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tnlQos */

   if (pvalue->m.tnlQosPresent) {
      PU_PUSHNAME (pctxt, "tnlQos");

      stat = asn1PD_TnlQos (pctxt, &pvalue->tnlQos);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode maximum_Number_of_Retransmissions_For_E_DCH */

   if (pvalue->m.maximum_Number_of_Retransmissions_For_E_DCHPresent) {
      PU_PUSHNAME (pctxt, "maximum_Number_of_Retransmissions_For_E_DCH");

      stat = asn1PD_Maximum_Number_of_Retransmissions_For_E_DCH (pctxt, &pvalue->maximum_Number_of_Retransmissions_For_E_DCH);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode eDCH_HARQ_PO_FDD */

   PU_PUSHNAME (pctxt, "eDCH_HARQ_PO_FDD");

   stat = asn1PD_E_DCH_HARQ_PO_FDD (pctxt, &pvalue->eDCH_HARQ_PO_FDD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode eDCH_MACdFlow_Multiplexing_List */

   if (pvalue->m.eDCH_MACdFlow_Multiplexing_ListPresent) {
      PU_PUSHNAME (pctxt, "eDCH_MACdFlow_Multiplexing_List");

      stat = asn1PD_E_DCH_MACdFlow_Multiplexing_List (pctxt, &pvalue->eDCH_MACdFlow_Multiplexing_List);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode eDCH_Grant_Type_Information */

   if (pvalue->m.eDCH_Grant_Type_InformationPresent) {
      PU_PUSHNAME (pctxt, "eDCH_Grant_Type_Information");

      stat = asn1PD_E_DCH_Grant_Type_Information (pctxt, &pvalue->eDCH_Grant_Type_Information);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlow_Specific_InfoItem_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlow_Specific_InfoList_to_Modify                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_MACdFlow_Specific_InfoList_to_Modify (ASN1CTXT* pctxt, E_DCH_MACdFlow_Specific_InfoList_to_Modify* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   E_DCH_MACdFlow_Specific_InfoItem_to_Modify* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlow_Specific_InfoList_to_Modify: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, E_DCH_MACdFlow_Specific_InfoItem_to_Modify);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_E_DCH_MACdFlow_Specific_InfoItem_to_Modify (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlow_Specific_InfoList_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_FDD_Information_to_Modify                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_FDD_Information_to_Modify (ASN1CTXT* pctxt, E_DCH_FDD_Information_to_Modify* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_FDD_Information_to_Modify: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "e_DCH_MACdFlow_Specific_Info_to_ModifyPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.e_DCH_MACdFlow_Specific_Info_to_ModifyPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "data_Description_IndicatorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.data_Description_IndicatorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode e_DCH_MACdFlow_Specific_Info_to_Modify */

   if (pvalue->m.e_DCH_MACdFlow_Specific_Info_to_ModifyPresent) {
      PU_PUSHNAME (pctxt, "e_DCH_MACdFlow_Specific_Info_to_Modify");

      stat = asn1PD_E_DCH_MACdFlow_Specific_InfoList_to_Modify (pctxt, &pvalue->e_DCH_MACdFlow_Specific_Info_to_Modify);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode data_Description_Indicator */

   if (pvalue->m.data_Description_IndicatorPresent) {
      PU_PUSHNAME (pctxt, "data_Description_Indicator");

      stat = asn1PD_Data_Description_Indicator (pctxt, &pvalue->data_Description_Indicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ue_E_DCH_Capability_Info */

   PU_PUSHNAME (pctxt, "ue_E_DCH_Capability_Info");

   stat = asn1PD_UE_E_DCH_Capability_Information (pctxt, &pvalue->ue_E_DCH_Capability_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_FDD_Information_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlow_to_Delete_Item                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_MACdFlow_to_Delete_Item (ASN1CTXT* pctxt, E_DCH_MACdFlow_to_Delete_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlow_to_Delete_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode e_DCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "e_DCH_MACdFlow_ID");

   stat = asn1PD_E_DCH_MACdFlow_ID (pctxt, &pvalue->e_DCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlow_to_Delete_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MACdFlows_to_Delete                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCH_MACdFlows_to_Delete (ASN1CTXT* pctxt, E_DCH_MACdFlows_to_Delete* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   E_DCH_MACdFlow_to_Delete_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlows_to_Delete: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, E_DCH_MACdFlow_to_Delete_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_E_DCH_MACdFlow_to_Delete_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCH_MACdFlows_to_Delete: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_RGCH_E_HICH_FDD_Code_List                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_RGCH_E_HICH_FDD_Code_List (ASN1CTXT* pctxt, E_RGCH_E_HICH_FDD_Code_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RGCH_E_HICH_FDD_Code_List: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   if (1 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PD_E_RGCH_E_HICH_FDD_Code_Information_Item (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RGCH_E_HICH_FDD_Code_List: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_RGCH_E_HICH_FDD_Code_Information                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_RGCH_E_HICH_FDD_Code_Information (ASN1CTXT* pctxt, E_RGCH_E_HICH_FDD_Code_Information* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RGCH_E_HICH_FDD_Code_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* replace */
         case 0:
            PU_PUSHNAME (pctxt, "u.replace");

            pvalue->u.replace = rtMemAllocTypeZ (pctxt, E_RGCH_E_HICH_FDD_Code_List);
            if (pvalue->u.replace == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_E_RGCH_E_HICH_FDD_Code_List (pctxt, pvalue->u.replace);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* remove_ */
         case 1:
            PU_PUSHNAME (pctxt, "u.remove_");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RGCH_E_HICH_FDD_Code_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCHProvidedBitRate_Item                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCHProvidedBitRate_Item (ASN1CTXT* pctxt, E_DCHProvidedBitRate_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCHProvidedBitRate_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode schedulingPriorityIndicator */

   PU_PUSHNAME (pctxt, "schedulingPriorityIndicator");

   stat = asn1PD_SchedulingPriorityIndicator (pctxt, &pvalue->schedulingPriorityIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode e_DCHProvidedBitRateValue */

   PU_PUSHNAME (pctxt, "e_DCHProvidedBitRateValue");

   stat = asn1PD_E_DCHProvidedBitRateValue (pctxt, &pvalue->e_DCHProvidedBitRateValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCHProvidedBitRate_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCHProvidedBitRate                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_E_DCHProvidedBitRate (ASN1CTXT* pctxt, E_DCHProvidedBitRate* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   E_DCHProvidedBitRate_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCHProvidedBitRate: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, E_DCHProvidedBitRate_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_E_DCHProvidedBitRate_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_DCHProvidedBitRate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GPS_Information                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_GPS_Information (ASN1CTXT* pctxt, GPS_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(8), 0 };
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Information: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   if (8 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PD_GPS_Information_Item (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GPS_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HARQ_MemoryPartitioning_Implicit                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HARQ_MemoryPartitioning_Implicit (ASN1CTXT* pctxt, HARQ_MemoryPartitioning_Implicit* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HARQ_MemoryPartitioning_Implicit: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode number_of_Processes */

   PU_PUSHNAME (pctxt, "number_of_Processes");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, &pvalue->number_of_Processes, OSINTCONST(1), OSINTCONST(8));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, &pvalue->number_of_Processes);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HARQ_MemoryPartitioning_Implicit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HARQ_MemoryPartitioningItem                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HARQ_MemoryPartitioningItem (ASN1CTXT* pctxt, HARQ_MemoryPartitioningItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HARQ_MemoryPartitioningItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode process_Memory_Size */

   PU_PUSHNAME (pctxt, "process_Memory_Size");

   stat = asn1PD_HARQ_MemoryPartitioningItem_process_Memory_Size (pctxt, &pvalue->process_Memory_Size);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HARQ_MemoryPartitioningItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HARQ_MemoryPartitioningList                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HARQ_MemoryPartitioningList (ASN1CTXT* pctxt, HARQ_MemoryPartitioningList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   HARQ_MemoryPartitioningItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HARQ_MemoryPartitioningList: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HARQ_MemoryPartitioningItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HARQ_MemoryPartitioningItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HARQ_MemoryPartitioningList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HARQ_MemoryPartitioning_Explicit                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HARQ_MemoryPartitioning_Explicit (ASN1CTXT* pctxt, HARQ_MemoryPartitioning_Explicit* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HARQ_MemoryPartitioning_Explicit: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hARQ_MemoryPartitioningList */

   PU_PUSHNAME (pctxt, "hARQ_MemoryPartitioningList");

   stat = asn1PD_HARQ_MemoryPartitioningList (pctxt, &pvalue->hARQ_MemoryPartitioningList);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HARQ_MemoryPartitioning_Explicit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HARQ_MemoryPartitioning                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HARQ_MemoryPartitioning (ASN1CTXT* pctxt, HARQ_MemoryPartitioning* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HARQ_MemoryPartitioning: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* implicit */
         case 0:
            PU_PUSHNAME (pctxt, "u.implicit");

            pvalue->u.implicit = rtMemAllocTypeZ (pctxt, HARQ_MemoryPartitioning_Implicit);
            if (pvalue->u.implicit == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_HARQ_MemoryPartitioning_Implicit (pctxt, pvalue->u.implicit);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* explicit_ */
         case 1:
            PU_PUSHNAME (pctxt, "u.explicit_");

            pvalue->u.explicit_ = rtMemAllocTypeZ (pctxt, HARQ_MemoryPartitioning_Explicit);
            if (pvalue->u.explicit_ == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_HARQ_MemoryPartitioning_Explicit (pctxt, pvalue->u.explicit_);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HARQ_MemoryPartitioning: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHProvidedBitRate_Item                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_DSCHProvidedBitRate_Item (ASN1CTXT* pctxt, HS_DSCHProvidedBitRate_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHProvidedBitRate_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode schedulingPriorityIndicator */

   PU_PUSHNAME (pctxt, "schedulingPriorityIndicator");

   stat = asn1PD_SchedulingPriorityIndicator (pctxt, &pvalue->schedulingPriorityIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode hS_DSCHProvidedBitRateValue */

   PU_PUSHNAME (pctxt, "hS_DSCHProvidedBitRateValue");

   stat = asn1PD_HS_DSCHProvidedBitRateValue (pctxt, &pvalue->hS_DSCHProvidedBitRateValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHProvidedBitRate_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHProvidedBitRate                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_DSCHProvidedBitRate (ASN1CTXT* pctxt, HS_DSCHProvidedBitRate* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   HS_DSCHProvidedBitRate_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHProvidedBitRate: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HS_DSCHProvidedBitRate_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HS_DSCHProvidedBitRate_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHProvidedBitRate: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHProvidedBitRateValueInformation_For_CellPortion_I  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_DSCHProvidedBitRateValueInformation_For_CellPortion_Item (ASN1CTXT* pctxt, HS_DSCHProvidedBitRateValueInformation_For_CellPortion_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHProvidedBitRateValueInformation_For_CellPortion_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cellPortionID */

   PU_PUSHNAME (pctxt, "cellPortionID");

   stat = asn1PD_CellPortionID (pctxt, &pvalue->cellPortionID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode hS_DSCHProvidedBitRateValue */

   PU_PUSHNAME (pctxt, "hS_DSCHProvidedBitRateValue");

   stat = asn1PD_HS_DSCHProvidedBitRateValue (pctxt, &pvalue->hS_DSCHProvidedBitRateValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHProvidedBitRateValueInformation_For_CellPortion_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHProvidedBitRateValueInformation_For_CellPortion    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_DSCHProvidedBitRateValueInformation_For_CellPortion (ASN1CTXT* pctxt, HS_DSCHProvidedBitRateValueInformation_For_CellPortion* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   HS_DSCHProvidedBitRateValueInformation_For_CellPortion_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHProvidedBitRateValueInformation_For_CellPortion: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HS_DSCHProvidedBitRateValueInformation_For_CellPortion_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HS_DSCHProvidedBitRateValueInformation_For_CellPortion_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHProvidedBitRateValueInformation_For_CellPortion: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHRequiredPowerPerUEInformation_Item                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_DSCHRequiredPowerPerUEInformation_Item (ASN1CTXT* pctxt, HS_DSCHRequiredPowerPerUEInformation_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHRequiredPowerPerUEInformation_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "hS_DSCHRequiredPowerPerUEWeightPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hS_DSCHRequiredPowerPerUEWeightPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cRNC_CommunicationContextID */

   PU_PUSHNAME (pctxt, "cRNC_CommunicationContextID");

   stat = asn1PD_CRNC_CommunicationContextID (pctxt, &pvalue->cRNC_CommunicationContextID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode hS_DSCHRequiredPowerPerUEWeight */

   if (pvalue->m.hS_DSCHRequiredPowerPerUEWeightPresent) {
      PU_PUSHNAME (pctxt, "hS_DSCHRequiredPowerPerUEWeight");

      stat = asn1PD_HS_DSCHRequiredPowerPerUEWeight (pctxt, &pvalue->hS_DSCHRequiredPowerPerUEWeight);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHRequiredPowerPerUEInformation_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHRequiredPowerPerUEInformation                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_DSCHRequiredPowerPerUEInformation (ASN1CTXT* pctxt, HS_DSCHRequiredPowerPerUEInformation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   HS_DSCHRequiredPowerPerUEInformation_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHRequiredPowerPerUEInformation: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HS_DSCHRequiredPowerPerUEInformation_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HS_DSCHRequiredPowerPerUEInformation_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHRequiredPowerPerUEInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHRequiredPower_Item                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_DSCHRequiredPower_Item (ASN1CTXT* pctxt, HS_DSCHRequiredPower_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHRequiredPower_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "hS_DSCHRequiredPowerPerUEInformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hS_DSCHRequiredPowerPerUEInformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode schedulingPriorityIndicator */

   PU_PUSHNAME (pctxt, "schedulingPriorityIndicator");

   stat = asn1PD_SchedulingPriorityIndicator (pctxt, &pvalue->schedulingPriorityIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode hS_DSCHRequiredPowerValue */

   PU_PUSHNAME (pctxt, "hS_DSCHRequiredPowerValue");

   stat = asn1PD_HS_DSCHRequiredPowerValue (pctxt, &pvalue->hS_DSCHRequiredPowerValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode hS_DSCHRequiredPowerPerUEInformation */

   if (pvalue->m.hS_DSCHRequiredPowerPerUEInformationPresent) {
      PU_PUSHNAME (pctxt, "hS_DSCHRequiredPowerPerUEInformation");

      stat = asn1PD_HS_DSCHRequiredPowerPerUEInformation (pctxt, &pvalue->hS_DSCHRequiredPowerPerUEInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHRequiredPower_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHRequiredPower                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_DSCHRequiredPower (ASN1CTXT* pctxt, HS_DSCHRequiredPower* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   HS_DSCHRequiredPower_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHRequiredPower: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HS_DSCHRequiredPower_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HS_DSCHRequiredPower_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHRequiredPower: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHRequiredPowerValueInformation_For_CellPortion_Ite  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_DSCHRequiredPowerValueInformation_For_CellPortion_Item (ASN1CTXT* pctxt, HS_DSCHRequiredPowerValueInformation_For_CellPortion_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHRequiredPowerValueInformation_For_CellPortion_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cellPortionID */

   PU_PUSHNAME (pctxt, "cellPortionID");

   stat = asn1PD_CellPortionID (pctxt, &pvalue->cellPortionID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode hS_DSCHRequiredPowerValue */

   PU_PUSHNAME (pctxt, "hS_DSCHRequiredPowerValue");

   stat = asn1PD_HS_DSCHRequiredPowerValue (pctxt, &pvalue->hS_DSCHRequiredPowerValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHRequiredPowerValueInformation_For_CellPortion_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCHRequiredPowerValueInformation_For_CellPortion      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_DSCHRequiredPowerValueInformation_For_CellPortion (ASN1CTXT* pctxt, HS_DSCHRequiredPowerValueInformation_For_CellPortion* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   HS_DSCHRequiredPowerValueInformation_For_CellPortion_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHRequiredPowerValueInformation_For_CellPortion: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HS_DSCHRequiredPowerValueInformation_For_CellPortion_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HS_DSCHRequiredPowerValueInformation_For_CellPortion_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_DSCHRequiredPowerValueInformation_For_CellPortion: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlow_Specific_InfoItem                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_MACdFlow_Specific_InfoItem (ASN1CTXT* pctxt, HSDSCH_MACdFlow_Specific_InfoItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlow_Specific_InfoItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bindingIDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportLayerAddressPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hsDSCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "hsDSCH_MACdFlow_ID");

   stat = asn1PD_HSDSCH_MACdFlow_ID (pctxt, &pvalue->hsDSCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode allocationRetentionPriority */

   PU_PUSHNAME (pctxt, "allocationRetentionPriority");

   stat = asn1PD_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PD_BindingID (pctxt, &pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlow_Specific_InfoItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlow_Specific_InfoList                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_MACdFlow_Specific_InfoList (ASN1CTXT* pctxt, HSDSCH_MACdFlow_Specific_InfoList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   HSDSCH_MACdFlow_Specific_InfoItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlow_Specific_InfoList: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HSDSCH_MACdFlow_Specific_InfoItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HSDSCH_MACdFlow_Specific_InfoItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlow_Specific_InfoList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MACdPDU_Size_IndexItem                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MACdPDU_Size_IndexItem (ASN1CTXT* pctxt, MACdPDU_Size_IndexItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MACdPDU_Size_IndexItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode sID */

   PU_PUSHNAME (pctxt, "sID");

   stat = asn1PD_SID (pctxt, &pvalue->sID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode macdPDU_Size */

   PU_PUSHNAME (pctxt, "macdPDU_Size");

   stat = asn1PD_MACdPDU_Size (pctxt, &pvalue->macdPDU_Size);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MACdPDU_Size_IndexItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MACdPDU_Size_Indexlist                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MACdPDU_Size_Indexlist (ASN1CTXT* pctxt, MACdPDU_Size_Indexlist* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   MACdPDU_Size_IndexItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_MACdPDU_Size_Indexlist: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MACdPDU_Size_IndexItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MACdPDU_Size_IndexItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MACdPDU_Size_Indexlist: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityQueue_InfoItem                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PriorityQueue_InfoItem (ASN1CTXT* pctxt, PriorityQueue_InfoItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityQueue_InfoItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "discardTimerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.discardTimerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "mAChsGuaranteedBitRatePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mAChsGuaranteedBitRatePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode priorityQueueId */

   PU_PUSHNAME (pctxt, "priorityQueueId");

   stat = asn1PD_PriorityQueue_Id (pctxt, &pvalue->priorityQueueId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode associatedHSDSCH_MACdFlow */

   PU_PUSHNAME (pctxt, "associatedHSDSCH_MACdFlow");

   stat = asn1PD_HSDSCH_MACdFlow_ID (pctxt, &pvalue->associatedHSDSCH_MACdFlow);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode schedulingPriorityIndicator */

   PU_PUSHNAME (pctxt, "schedulingPriorityIndicator");

   stat = asn1PD_SchedulingPriorityIndicator (pctxt, &pvalue->schedulingPriorityIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode t1 */

   PU_PUSHNAME (pctxt, "t1");

   stat = asn1PD_T1 (pctxt, &pvalue->t1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode discardTimer */

   if (pvalue->m.discardTimerPresent) {
      PU_PUSHNAME (pctxt, "discardTimer");

      stat = asn1PD_DiscardTimer (pctxt, &pvalue->discardTimer);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode mAC_hsWindowSize */

   PU_PUSHNAME (pctxt, "mAC_hsWindowSize");

   stat = asn1PD_MAC_hsWindowSize (pctxt, &pvalue->mAC_hsWindowSize);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode mAChsGuaranteedBitRate */

   if (pvalue->m.mAChsGuaranteedBitRatePresent) {
      PU_PUSHNAME (pctxt, "mAChsGuaranteedBitRate");

      stat = asn1PD_MAChsGuaranteedBitRate (pctxt, &pvalue->mAChsGuaranteedBitRate);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode macdPDU_Size_Index */

   PU_PUSHNAME (pctxt, "macdPDU_Size_Index");

   stat = asn1PD_MACdPDU_Size_Indexlist (pctxt, &pvalue->macdPDU_Size_Index);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode rLC_Mode */

   PU_PUSHNAME (pctxt, "rLC_Mode");

   stat = asn1PD_RLC_Mode (pctxt, &pvalue->rLC_Mode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityQueue_InfoItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityQueue_InfoList                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PriorityQueue_InfoList (ASN1CTXT* pctxt, PriorityQueue_InfoList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   PriorityQueue_InfoItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityQueue_InfoList: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PriorityQueue_InfoItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_PriorityQueue_InfoItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityQueue_InfoList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlows_Information                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_MACdFlows_Information (ASN1CTXT* pctxt, HSDSCH_MACdFlows_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlows_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hSDSCH_MACdFlow_Specific_Info */

   PU_PUSHNAME (pctxt, "hSDSCH_MACdFlow_Specific_Info");

   stat = asn1PD_HSDSCH_MACdFlow_Specific_InfoList (pctxt, &pvalue->hSDSCH_MACdFlow_Specific_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode priorityQueue_Info */

   PU_PUSHNAME (pctxt, "priorityQueue_Info");

   stat = asn1PD_PriorityQueue_InfoList (pctxt, &pvalue->priorityQueue_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlows_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UE_Capability_Information                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UE_Capability_Information (ASN1CTXT* pctxt, UE_Capability_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_Capability_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hSDSCH_Physical_Layer_Category */

   PU_PUSHNAME (pctxt, "hSDSCH_Physical_Layer_Category");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, &pvalue->hSDSCH_Physical_Layer_Category, OSINTCONST(1), OSINTCONST(64));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, &pvalue->hSDSCH_Physical_Layer_Category);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_Capability_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_FDD_Information                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_FDD_Information (ASN1CTXT* pctxt, HSDSCH_FDD_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_FDD_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "cqiRepetitionFactorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cqiRepetitionFactorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hsscch_PowerOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hsscch_PowerOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "measurement_Power_OffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.measurement_Power_OffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hSDSCH_MACdFlows_Information */

   PU_PUSHNAME (pctxt, "hSDSCH_MACdFlows_Information");

   stat = asn1PD_HSDSCH_MACdFlows_Information (pctxt, &pvalue->hSDSCH_MACdFlows_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ueCapability_Info */

   PU_PUSHNAME (pctxt, "ueCapability_Info");

   stat = asn1PD_UE_Capability_Information (pctxt, &pvalue->ueCapability_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode mAChs_Reordering_Buffer_Size_for_RLC_UM */

   PU_PUSHNAME (pctxt, "mAChs_Reordering_Buffer_Size_for_RLC_UM");

   stat = asn1PD_MAChsReorderingBufferSize_for_RLC_UM (pctxt, &pvalue->mAChs_Reordering_Buffer_Size_for_RLC_UM);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cqiFeedback_CycleK */

   PU_PUSHNAME (pctxt, "cqiFeedback_CycleK");

   stat = asn1PD_CQI_Feedback_Cycle (pctxt, &pvalue->cqiFeedback_CycleK);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cqiRepetitionFactor */

   if (pvalue->m.cqiRepetitionFactorPresent) {
      PU_PUSHNAME (pctxt, "cqiRepetitionFactor");

      stat = asn1PD_CQI_RepetitionFactor (pctxt, &pvalue->cqiRepetitionFactor);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ackNackRepetitionFactor */

   PU_PUSHNAME (pctxt, "ackNackRepetitionFactor");

   stat = asn1PD_AckNack_RepetitionFactor (pctxt, &pvalue->ackNackRepetitionFactor);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cqiPowerOffset */

   PU_PUSHNAME (pctxt, "cqiPowerOffset");

   stat = asn1PD_CQI_Power_Offset (pctxt, &pvalue->cqiPowerOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ackPowerOffset */

   PU_PUSHNAME (pctxt, "ackPowerOffset");

   stat = asn1PD_Ack_Power_Offset (pctxt, &pvalue->ackPowerOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode nackPowerOffset */

   PU_PUSHNAME (pctxt, "nackPowerOffset");

   stat = asn1PD_Nack_Power_Offset (pctxt, &pvalue->nackPowerOffset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode hsscch_PowerOffset */

   if (pvalue->m.hsscch_PowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "hsscch_PowerOffset");

      stat = asn1PD_HSSCCH_PowerOffset (pctxt, &pvalue->hsscch_PowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode measurement_Power_Offset */

   if (pvalue->m.measurement_Power_OffsetPresent) {
      PU_PUSHNAME (pctxt, "measurement_Power_Offset");

      stat = asn1PD_Measurement_Power_Offset (pctxt, &pvalue->measurement_Power_Offset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_FDD_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_TDD_Information                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_TDD_Information (ASN1CTXT* pctxt, HSDSCH_TDD_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_TDD_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hSDSCH_MACdFlows_Information */

   PU_PUSHNAME (pctxt, "hSDSCH_MACdFlows_Information");

   stat = asn1PD_HSDSCH_MACdFlows_Information (pctxt, &pvalue->hSDSCH_MACdFlows_Information);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ueCapability_Info */

   PU_PUSHNAME (pctxt, "ueCapability_Info");

   stat = asn1PD_UE_Capability_Information (pctxt, &pvalue->ueCapability_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode mAChs_Reordering_Buffer_Size_for_RLC_UM */

   PU_PUSHNAME (pctxt, "mAChs_Reordering_Buffer_Size_for_RLC_UM");

   stat = asn1PD_MAChsReorderingBufferSize_for_RLC_UM (pctxt, &pvalue->mAChs_Reordering_Buffer_Size_for_RLC_UM);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tDD_AckNack_Power_Offset */

   PU_PUSHNAME (pctxt, "tDD_AckNack_Power_Offset");

   stat = asn1PD_TDD_AckNack_Power_Offset (pctxt, &pvalue->tDD_AckNack_Power_Offset);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_TDD_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlow_Specific_InfoItem_to_Modify               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_MACdFlow_Specific_InfoItem_to_Modify (ASN1CTXT* pctxt, HSDSCH_MACdFlow_Specific_InfoItem_to_Modify* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlow_Specific_InfoItem_to_Modify: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "allocationRetentionPriorityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.allocationRetentionPriorityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bindingIDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportLayerAddressPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hsDSCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "hsDSCH_MACdFlow_ID");

   stat = asn1PD_HSDSCH_MACdFlow_ID (pctxt, &pvalue->hsDSCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode allocationRetentionPriority */

   if (pvalue->m.allocationRetentionPriorityPresent) {
      PU_PUSHNAME (pctxt, "allocationRetentionPriority");

      stat = asn1PD_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportBearerRequestIndicator */

   PU_PUSHNAME (pctxt, "transportBearerRequestIndicator");

   stat = asn1PD_TransportBearerRequestIndicator (pctxt, &pvalue->transportBearerRequestIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PD_BindingID (pctxt, &pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlow_Specific_InfoItem_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlow_Specific_InfoList_to_Modify               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_MACdFlow_Specific_InfoList_to_Modify (ASN1CTXT* pctxt, HSDSCH_MACdFlow_Specific_InfoList_to_Modify* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   HSDSCH_MACdFlow_Specific_InfoItem_to_Modify* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlow_Specific_InfoList_to_Modify: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HSDSCH_MACdFlow_Specific_InfoItem_to_Modify);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HSDSCH_MACdFlow_Specific_InfoItem_to_Modify (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlow_Specific_InfoList_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityQueue_InfoItem_to_Add                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PriorityQueue_InfoItem_to_Add (ASN1CTXT* pctxt, PriorityQueue_InfoItem_to_Add* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityQueue_InfoItem_to_Add: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "discardTimerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.discardTimerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "mAChsGuaranteedBitRatePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mAChsGuaranteedBitRatePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode priorityQueueId */

   PU_PUSHNAME (pctxt, "priorityQueueId");

   stat = asn1PD_PriorityQueue_Id (pctxt, &pvalue->priorityQueueId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode associatedHSDSCH_MACdFlow */

   PU_PUSHNAME (pctxt, "associatedHSDSCH_MACdFlow");

   stat = asn1PD_HSDSCH_MACdFlow_ID (pctxt, &pvalue->associatedHSDSCH_MACdFlow);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode schedulingPriorityIndicator */

   PU_PUSHNAME (pctxt, "schedulingPriorityIndicator");

   stat = asn1PD_SchedulingPriorityIndicator (pctxt, &pvalue->schedulingPriorityIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode t1 */

   PU_PUSHNAME (pctxt, "t1");

   stat = asn1PD_T1 (pctxt, &pvalue->t1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode discardTimer */

   if (pvalue->m.discardTimerPresent) {
      PU_PUSHNAME (pctxt, "discardTimer");

      stat = asn1PD_DiscardTimer (pctxt, &pvalue->discardTimer);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode mAC_hsWindowSize */

   PU_PUSHNAME (pctxt, "mAC_hsWindowSize");

   stat = asn1PD_MAC_hsWindowSize (pctxt, &pvalue->mAC_hsWindowSize);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode mAChsGuaranteedBitRate */

   if (pvalue->m.mAChsGuaranteedBitRatePresent) {
      PU_PUSHNAME (pctxt, "mAChsGuaranteedBitRate");

      stat = asn1PD_MAChsGuaranteedBitRate (pctxt, &pvalue->mAChsGuaranteedBitRate);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode macdPDU_Size_Index */

   PU_PUSHNAME (pctxt, "macdPDU_Size_Index");

   stat = asn1PD_MACdPDU_Size_Indexlist (pctxt, &pvalue->macdPDU_Size_Index);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode rLC_Mode */

   PU_PUSHNAME (pctxt, "rLC_Mode");

   stat = asn1PD_RLC_Mode (pctxt, &pvalue->rLC_Mode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityQueue_InfoItem_to_Add: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MACdPDU_Size_IndexItem_to_Modify                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MACdPDU_Size_IndexItem_to_Modify (ASN1CTXT* pctxt, MACdPDU_Size_IndexItem_to_Modify* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MACdPDU_Size_IndexItem_to_Modify: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode sID */

   PU_PUSHNAME (pctxt, "sID");

   stat = asn1PD_SID (pctxt, &pvalue->sID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode macdPDU_Size */

   PU_PUSHNAME (pctxt, "macdPDU_Size");

   stat = asn1PD_MACdPDU_Size (pctxt, &pvalue->macdPDU_Size);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MACdPDU_Size_IndexItem_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MACdPDU_Size_Indexlist_to_Modify                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MACdPDU_Size_Indexlist_to_Modify (ASN1CTXT* pctxt, MACdPDU_Size_Indexlist_to_Modify* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   MACdPDU_Size_IndexItem_to_Modify* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_MACdPDU_Size_Indexlist_to_Modify: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MACdPDU_Size_IndexItem_to_Modify);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MACdPDU_Size_IndexItem_to_Modify (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MACdPDU_Size_Indexlist_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityQueue_InfoItem_to_Modify                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PriorityQueue_InfoItem_to_Modify (ASN1CTXT* pctxt, PriorityQueue_InfoItem_to_Modify* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityQueue_InfoItem_to_Modify: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "schedulingPriorityIndicatorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.schedulingPriorityIndicatorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "t1Present");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.t1Present = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "discardTimerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.discardTimerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "mAC_hsWindowSizePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mAC_hsWindowSizePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "mAChsGuaranteedBitRatePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mAChsGuaranteedBitRatePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "macdPDU_Size_Index_to_ModifyPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.macdPDU_Size_Index_to_ModifyPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode priorityQueueId */

   PU_PUSHNAME (pctxt, "priorityQueueId");

   stat = asn1PD_PriorityQueue_Id (pctxt, &pvalue->priorityQueueId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode schedulingPriorityIndicator */

   if (pvalue->m.schedulingPriorityIndicatorPresent) {
      PU_PUSHNAME (pctxt, "schedulingPriorityIndicator");

      stat = asn1PD_SchedulingPriorityIndicator (pctxt, &pvalue->schedulingPriorityIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode t1 */

   if (pvalue->m.t1Present) {
      PU_PUSHNAME (pctxt, "t1");

      stat = asn1PD_T1 (pctxt, &pvalue->t1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode discardTimer */

   if (pvalue->m.discardTimerPresent) {
      PU_PUSHNAME (pctxt, "discardTimer");

      stat = asn1PD_DiscardTimer (pctxt, &pvalue->discardTimer);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode mAC_hsWindowSize */

   if (pvalue->m.mAC_hsWindowSizePresent) {
      PU_PUSHNAME (pctxt, "mAC_hsWindowSize");

      stat = asn1PD_MAC_hsWindowSize (pctxt, &pvalue->mAC_hsWindowSize);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode mAChsGuaranteedBitRate */

   if (pvalue->m.mAChsGuaranteedBitRatePresent) {
      PU_PUSHNAME (pctxt, "mAChsGuaranteedBitRate");

      stat = asn1PD_MAChsGuaranteedBitRate (pctxt, &pvalue->mAChsGuaranteedBitRate);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode macdPDU_Size_Index_to_Modify */

   if (pvalue->m.macdPDU_Size_Index_to_ModifyPresent) {
      PU_PUSHNAME (pctxt, "macdPDU_Size_Index_to_Modify");

      stat = asn1PD_MACdPDU_Size_Indexlist_to_Modify (pctxt, &pvalue->macdPDU_Size_Index_to_Modify);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityQueue_InfoItem_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ModifyPriorityQueue                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ModifyPriorityQueue (ASN1CTXT* pctxt, ModifyPriorityQueue* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ModifyPriorityQueue: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* addPriorityQueue */
         case 0:
            PU_PUSHNAME (pctxt, "u.addPriorityQueue");

            pvalue->u.addPriorityQueue = rtMemAllocTypeZ (pctxt, PriorityQueue_InfoItem_to_Add);
            if (pvalue->u.addPriorityQueue == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_PriorityQueue_InfoItem_to_Add (pctxt, pvalue->u.addPriorityQueue);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* modifyPriorityQueue */
         case 1:
            PU_PUSHNAME (pctxt, "u.modifyPriorityQueue");

            pvalue->u.modifyPriorityQueue = rtMemAllocTypeZ (pctxt, PriorityQueue_InfoItem_to_Modify);
            if (pvalue->u.modifyPriorityQueue == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_PriorityQueue_InfoItem_to_Modify (pctxt, pvalue->u.modifyPriorityQueue);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* deletePriorityQueue */
         case 2:
            PU_PUSHNAME (pctxt, "u.deletePriorityQueue");

            stat = asn1PD_PriorityQueue_Id (pctxt, &pvalue->u.deletePriorityQueue);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ModifyPriorityQueue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityQueue_InfoList_to_Modify                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PriorityQueue_InfoList_to_Modify (ASN1CTXT* pctxt, PriorityQueue_InfoList_to_Modify* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   ModifyPriorityQueue* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityQueue_InfoList_to_Modify: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ModifyPriorityQueue);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_ModifyPriorityQueue (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityQueue_InfoList_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_Information_to_Modify                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_Information_to_Modify (ASN1CTXT* pctxt, HSDSCH_Information_to_Modify* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_Information_to_Modify: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "hsDSCH_MACdFlow_Specific_Info_to_ModifyPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hsDSCH_MACdFlow_Specific_Info_to_ModifyPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "priorityQueueInfotoModifyPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.priorityQueueInfotoModifyPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "mAChs_Reordering_Buffer_Size_for_RLC_UMPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mAChs_Reordering_Buffer_Size_for_RLC_UMPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cqiFeedback_CycleKPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cqiFeedback_CycleKPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cqiRepetitionFactorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cqiRepetitionFactorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ackNackRepetitionFactorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ackNackRepetitionFactorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cqiPowerOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cqiPowerOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ackPowerOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ackPowerOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "nackPowerOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nackPowerOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hsscch_PowerOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hsscch_PowerOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "measurement_Power_OffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.measurement_Power_OffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hSSCCHCodeChangeGrantPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hSSCCHCodeChangeGrantPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tDDAckNackPowerOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tDDAckNackPowerOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hsDSCH_MACdFlow_Specific_Info_to_Modify */

   if (pvalue->m.hsDSCH_MACdFlow_Specific_Info_to_ModifyPresent) {
      PU_PUSHNAME (pctxt, "hsDSCH_MACdFlow_Specific_Info_to_Modify");

      stat = asn1PD_HSDSCH_MACdFlow_Specific_InfoList_to_Modify (pctxt, &pvalue->hsDSCH_MACdFlow_Specific_Info_to_Modify);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode priorityQueueInfotoModify */

   if (pvalue->m.priorityQueueInfotoModifyPresent) {
      PU_PUSHNAME (pctxt, "priorityQueueInfotoModify");

      stat = asn1PD_PriorityQueue_InfoList_to_Modify (pctxt, &pvalue->priorityQueueInfotoModify);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode mAChs_Reordering_Buffer_Size_for_RLC_UM */

   if (pvalue->m.mAChs_Reordering_Buffer_Size_for_RLC_UMPresent) {
      PU_PUSHNAME (pctxt, "mAChs_Reordering_Buffer_Size_for_RLC_UM");

      stat = asn1PD_MAChsReorderingBufferSize_for_RLC_UM (pctxt, &pvalue->mAChs_Reordering_Buffer_Size_for_RLC_UM);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode cqiFeedback_CycleK */

   if (pvalue->m.cqiFeedback_CycleKPresent) {
      PU_PUSHNAME (pctxt, "cqiFeedback_CycleK");

      stat = asn1PD_CQI_Feedback_Cycle (pctxt, &pvalue->cqiFeedback_CycleK);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode cqiRepetitionFactor */

   if (pvalue->m.cqiRepetitionFactorPresent) {
      PU_PUSHNAME (pctxt, "cqiRepetitionFactor");

      stat = asn1PD_CQI_RepetitionFactor (pctxt, &pvalue->cqiRepetitionFactor);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ackNackRepetitionFactor */

   if (pvalue->m.ackNackRepetitionFactorPresent) {
      PU_PUSHNAME (pctxt, "ackNackRepetitionFactor");

      stat = asn1PD_AckNack_RepetitionFactor (pctxt, &pvalue->ackNackRepetitionFactor);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode cqiPowerOffset */

   if (pvalue->m.cqiPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "cqiPowerOffset");

      stat = asn1PD_CQI_Power_Offset (pctxt, &pvalue->cqiPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ackPowerOffset */

   if (pvalue->m.ackPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "ackPowerOffset");

      stat = asn1PD_Ack_Power_Offset (pctxt, &pvalue->ackPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode nackPowerOffset */

   if (pvalue->m.nackPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "nackPowerOffset");

      stat = asn1PD_Nack_Power_Offset (pctxt, &pvalue->nackPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode hsscch_PowerOffset */

   if (pvalue->m.hsscch_PowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "hsscch_PowerOffset");

      stat = asn1PD_HSSCCH_PowerOffset (pctxt, &pvalue->hsscch_PowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode measurement_Power_Offset */

   if (pvalue->m.measurement_Power_OffsetPresent) {
      PU_PUSHNAME (pctxt, "measurement_Power_Offset");

      stat = asn1PD_Measurement_Power_Offset (pctxt, &pvalue->measurement_Power_Offset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode hSSCCHCodeChangeGrant */

   if (pvalue->m.hSSCCHCodeChangeGrantPresent) {
      PU_PUSHNAME (pctxt, "hSSCCHCodeChangeGrant");

      stat = asn1PD_HSSCCH_Code_Change_Grant (pctxt, &pvalue->hSSCCHCodeChangeGrant);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tDDAckNackPowerOffset */

   if (pvalue->m.tDDAckNackPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "tDDAckNackPowerOffset");

      stat = asn1PD_TDD_AckNack_Power_Offset (pctxt, &pvalue->tDDAckNackPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_Information_to_Modify: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityQueue_InfoItem_to_Modify_Unsynchronised           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PriorityQueue_InfoItem_to_Modify_Unsynchronised (ASN1CTXT* pctxt, PriorityQueue_InfoItem_to_Modify_Unsynchronised* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityQueue_InfoItem_to_Modify_Unsynchronised: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "schedulingPriorityIndicatorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.schedulingPriorityIndicatorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "discardTimerPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.discardTimerPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "mAChsGuaranteedBitRatePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mAChsGuaranteedBitRatePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode priorityQueueId */

   PU_PUSHNAME (pctxt, "priorityQueueId");

   stat = asn1PD_PriorityQueue_Id (pctxt, &pvalue->priorityQueueId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode schedulingPriorityIndicator */

   if (pvalue->m.schedulingPriorityIndicatorPresent) {
      PU_PUSHNAME (pctxt, "schedulingPriorityIndicator");

      stat = asn1PD_SchedulingPriorityIndicator (pctxt, &pvalue->schedulingPriorityIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode discardTimer */

   if (pvalue->m.discardTimerPresent) {
      PU_PUSHNAME (pctxt, "discardTimer");

      stat = asn1PD_DiscardTimer (pctxt, &pvalue->discardTimer);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode mAChsGuaranteedBitRate */

   if (pvalue->m.mAChsGuaranteedBitRatePresent) {
      PU_PUSHNAME (pctxt, "mAChsGuaranteedBitRate");

      stat = asn1PD_MAChsGuaranteedBitRate (pctxt, &pvalue->mAChsGuaranteedBitRate);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityQueue_InfoItem_to_Modify_Unsynchronised: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityQueue_InfoList_to_Modify_Unsynchronised           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_PriorityQueue_InfoList_to_Modify_Unsynchronised (ASN1CTXT* pctxt, PriorityQueue_InfoList_to_Modify_Unsynchronised* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   PriorityQueue_InfoItem_to_Modify_Unsynchronised* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityQueue_InfoList_to_Modify_Unsynchronised: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PriorityQueue_InfoItem_to_Modify_Unsynchronised);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_PriorityQueue_InfoItem_to_Modify_Unsynchronised (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityQueue_InfoList_to_Modify_Unsynchronised: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_Information_to_Modify_Unsynchronised               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_Information_to_Modify_Unsynchronised (ASN1CTXT* pctxt, HSDSCH_Information_to_Modify_Unsynchronised* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_Information_to_Modify_Unsynchronised: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "hsDSCH_MACdFlow_Specific_Info_to_ModifyPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hsDSCH_MACdFlow_Specific_Info_to_ModifyPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "priorityQueueInfotoModifyUnsynchronisedPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.priorityQueueInfotoModifyUnsynchronisedPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cqiPowerOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cqiPowerOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ackPowerOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ackPowerOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "nackPowerOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nackPowerOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hsscch_PowerOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hsscch_PowerOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tDDAckNackPowerOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tDDAckNackPowerOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hsDSCH_MACdFlow_Specific_Info_to_Modify */

   if (pvalue->m.hsDSCH_MACdFlow_Specific_Info_to_ModifyPresent) {
      PU_PUSHNAME (pctxt, "hsDSCH_MACdFlow_Specific_Info_to_Modify");

      stat = asn1PD_HSDSCH_MACdFlow_Specific_InfoList_to_Modify (pctxt, &pvalue->hsDSCH_MACdFlow_Specific_Info_to_Modify);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode priorityQueueInfotoModifyUnsynchronised */

   if (pvalue->m.priorityQueueInfotoModifyUnsynchronisedPresent) {
      PU_PUSHNAME (pctxt, "priorityQueueInfotoModifyUnsynchronised");

      stat = asn1PD_PriorityQueue_InfoList_to_Modify_Unsynchronised (pctxt, &pvalue->priorityQueueInfotoModifyUnsynchronised);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode cqiPowerOffset */

   if (pvalue->m.cqiPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "cqiPowerOffset");

      stat = asn1PD_CQI_Power_Offset (pctxt, &pvalue->cqiPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ackPowerOffset */

   if (pvalue->m.ackPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "ackPowerOffset");

      stat = asn1PD_Ack_Power_Offset (pctxt, &pvalue->ackPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode nackPowerOffset */

   if (pvalue->m.nackPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "nackPowerOffset");

      stat = asn1PD_Nack_Power_Offset (pctxt, &pvalue->nackPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode hsscch_PowerOffset */

   if (pvalue->m.hsscch_PowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "hsscch_PowerOffset");

      stat = asn1PD_HSSCCH_PowerOffset (pctxt, &pvalue->hsscch_PowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tDDAckNackPowerOffset */

   if (pvalue->m.tDDAckNackPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "tDDAckNackPowerOffset");

      stat = asn1PD_TDD_AckNack_Power_Offset (pctxt, &pvalue->tDDAckNackPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_Information_to_Modify_Unsynchronised: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_Initial_Capacity_AllocationItem                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_Initial_Capacity_AllocationItem (ASN1CTXT* pctxt, HSDSCH_Initial_Capacity_AllocationItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_Initial_Capacity_AllocationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode schedulingPriorityIndicator */

   PU_PUSHNAME (pctxt, "schedulingPriorityIndicator");

   stat = asn1PD_SchedulingPriorityIndicator (pctxt, &pvalue->schedulingPriorityIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode maximum_MACdPDU_Size */

   PU_PUSHNAME (pctxt, "maximum_MACdPDU_Size");

   stat = asn1PD_MACdPDU_Size (pctxt, &pvalue->maximum_MACdPDU_Size);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode hSDSCH_InitialWindowSize */

   PU_PUSHNAME (pctxt, "hSDSCH_InitialWindowSize");

   stat = asn1PD_HSDSCH_InitialWindowSize (pctxt, &pvalue->hSDSCH_InitialWindowSize);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_Initial_Capacity_AllocationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_Initial_Capacity_Allocation                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_Initial_Capacity_Allocation (ASN1CTXT* pctxt, HSDSCH_Initial_Capacity_Allocation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   HSDSCH_Initial_Capacity_AllocationItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_Initial_Capacity_Allocation: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HSDSCH_Initial_Capacity_AllocationItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HSDSCH_Initial_Capacity_AllocationItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_Initial_Capacity_Allocation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlow_Specific_InformationResp_Item             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_MACdFlow_Specific_InformationResp_Item (ASN1CTXT* pctxt, HSDSCH_MACdFlow_Specific_InformationResp_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlow_Specific_InformationResp_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bindingIDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportLayerAddressPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hSDSCH_Initial_Capacity_AllocationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hSDSCH_Initial_Capacity_AllocationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hsDSCHMacdFlow_Id */

   PU_PUSHNAME (pctxt, "hsDSCHMacdFlow_Id");

   stat = asn1PD_HSDSCH_MACdFlow_ID (pctxt, &pvalue->hsDSCHMacdFlow_Id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PD_BindingID (pctxt, &pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode hSDSCH_Initial_Capacity_Allocation */

   if (pvalue->m.hSDSCH_Initial_Capacity_AllocationPresent) {
      PU_PUSHNAME (pctxt, "hSDSCH_Initial_Capacity_Allocation");

      stat = asn1PD_HSDSCH_Initial_Capacity_Allocation (pctxt, &pvalue->hSDSCH_Initial_Capacity_Allocation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlow_Specific_InformationResp_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlow_Specific_InformationResp                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_MACdFlow_Specific_InformationResp (ASN1CTXT* pctxt, HSDSCH_MACdFlow_Specific_InformationResp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   HSDSCH_MACdFlow_Specific_InformationResp_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlow_Specific_InformationResp: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HSDSCH_MACdFlow_Specific_InformationResp_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HSDSCH_MACdFlow_Specific_InformationResp_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlow_Specific_InformationResp: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSCCH_Codes                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSSCCH_Codes (ASN1CTXT* pctxt, HSSCCH_Codes* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSCCH_Codes: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode codeNumber */

   PU_PUSHNAME (pctxt, "codeNumber");

   stat = pd_ConsUInt8 (pctxt, &pvalue->codeNumber, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSCCH_Codes: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSCCH_Specific_InformationRespListFDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSSCCH_Specific_InformationRespListFDD (ASN1CTXT* pctxt, HSSCCH_Specific_InformationRespListFDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(4), 0 };
   int stat = 0;
   HSSCCH_Codes* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSCCH_Specific_InformationRespListFDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HSSCCH_Codes);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HSSCCH_Codes (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSCCH_Specific_InformationRespListFDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_FDD_Information_Response                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_FDD_Information_Response (ASN1CTXT* pctxt, HSDSCH_FDD_Information_Response* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_FDD_Information_Response: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "hsDSCH_MACdFlow_Specific_InformationRespPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hsDSCH_MACdFlow_Specific_InformationRespPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hsSCCH_Specific_Information_ResponseFDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hsSCCH_Specific_Information_ResponseFDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hARQ_MemoryPartitioningPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hARQ_MemoryPartitioningPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hsDSCH_MACdFlow_Specific_InformationResp */

   if (pvalue->m.hsDSCH_MACdFlow_Specific_InformationRespPresent) {
      PU_PUSHNAME (pctxt, "hsDSCH_MACdFlow_Specific_InformationResp");

      stat = asn1PD_HSDSCH_MACdFlow_Specific_InformationResp (pctxt, &pvalue->hsDSCH_MACdFlow_Specific_InformationResp);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode hsSCCH_Specific_Information_ResponseFDD */

   if (pvalue->m.hsSCCH_Specific_Information_ResponseFDDPresent) {
      PU_PUSHNAME (pctxt, "hsSCCH_Specific_Information_ResponseFDD");

      stat = asn1PD_HSSCCH_Specific_InformationRespListFDD (pctxt, &pvalue->hsSCCH_Specific_Information_ResponseFDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode hARQ_MemoryPartitioning */

   if (pvalue->m.hARQ_MemoryPartitioningPresent) {
      PU_PUSHNAME (pctxt, "hARQ_MemoryPartitioning");

      stat = asn1PD_HARQ_MemoryPartitioning (pctxt, &pvalue->hARQ_MemoryPartitioning);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_FDD_Information_Response: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSICH_Info                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSSICH_Info (ASN1CTXT* pctxt, HSSICH_Info* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSICH_Info: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hsSICH_ID */

   PU_PUSHNAME (pctxt, "hsSICH_ID");

   stat = asn1PD_HS_SICH_ID (pctxt, &pvalue->hsSICH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeslot */

   PU_PUSHNAME (pctxt, "timeslot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeslot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftAndBurstType */

   PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tDD_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tDD_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tDD_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSICH_Info: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSCCH_Specific_InformationRespItemTDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSSCCH_Specific_InformationRespItemTDD (ASN1CTXT* pctxt, HSSCCH_Specific_InformationRespItemTDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSCCH_Specific_InformationRespItemTDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeslot */

   PU_PUSHNAME (pctxt, "timeslot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeslot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftAndBurstType */

   PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tDD_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tDD_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tDD_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode hSSICH_Info */

   PU_PUSHNAME (pctxt, "hSSICH_Info");

   stat = asn1PD_HSSICH_Info (pctxt, &pvalue->hSSICH_Info);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSCCH_Specific_InformationRespItemTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSCCH_Specific_InformationRespListTDD                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSSCCH_Specific_InformationRespListTDD (ASN1CTXT* pctxt, HSSCCH_Specific_InformationRespListTDD* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(4), 0 };
   int stat = 0;
   HSSCCH_Specific_InformationRespItemTDD* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSCCH_Specific_InformationRespListTDD: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HSSCCH_Specific_InformationRespItemTDD);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HSSCCH_Specific_InformationRespItemTDD (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSCCH_Specific_InformationRespListTDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSICH_InfoLCR                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSSICH_InfoLCR (ASN1CTXT* pctxt, HSSICH_InfoLCR* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSICH_InfoLCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hsSICH_ID */

   PU_PUSHNAME (pctxt, "hsSICH_ID");

   stat = asn1PD_HS_SICH_ID (pctxt, &pvalue->hsSICH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeslotLCR */

   PU_PUSHNAME (pctxt, "timeslotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeslotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftLCR */

   PU_PUSHNAME (pctxt, "midambleShiftLCR");

   stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tDD_ChannelisationCode */

   PU_PUSHNAME (pctxt, "tDD_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->tDD_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSICH_InfoLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSCCH_Specific_InformationRespItemTDDLCR                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSSCCH_Specific_InformationRespItemTDDLCR (ASN1CTXT* pctxt, HSSCCH_Specific_InformationRespItemTDDLCR* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSCCH_Specific_InformationRespItemTDDLCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode timeslotLCR */

   PU_PUSHNAME (pctxt, "timeslotLCR");

   stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeslotLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode midambleShiftLCR */

   PU_PUSHNAME (pctxt, "midambleShiftLCR");

   stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode first_TDD_ChannelisationCode */

   PU_PUSHNAME (pctxt, "first_TDD_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->first_TDD_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode second_TDD_ChannelisationCode */

   PU_PUSHNAME (pctxt, "second_TDD_ChannelisationCode");

   stat = asn1PD_TDD_ChannelisationCode (pctxt, &pvalue->second_TDD_ChannelisationCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode hSSICH_InfoLCR */

   PU_PUSHNAME (pctxt, "hSSICH_InfoLCR");

   stat = asn1PD_HSSICH_InfoLCR (pctxt, &pvalue->hSSICH_InfoLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSCCH_Specific_InformationRespItemTDDLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSSCCH_Specific_InformationRespListTDDLCR                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSSCCH_Specific_InformationRespListTDDLCR (ASN1CTXT* pctxt, HSSCCH_Specific_InformationRespListTDDLCR* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(4), 0 };
   int stat = 0;
   HSSCCH_Specific_InformationRespItemTDDLCR* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSCCH_Specific_InformationRespListTDDLCR: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HSSCCH_Specific_InformationRespItemTDDLCR);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HSSCCH_Specific_InformationRespItemTDDLCR (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSSCCH_Specific_InformationRespListTDDLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_TDD_Information_Response                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_TDD_Information_Response (ASN1CTXT* pctxt, HSDSCH_TDD_Information_Response* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_TDD_Information_Response: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "hsDSCH_MACdFlow_Specific_InformationRespPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hsDSCH_MACdFlow_Specific_InformationRespPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hsSCCH_Specific_Information_ResponseTDDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hsSCCH_Specific_Information_ResponseTDDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hsSCCH_Specific_Information_ResponseTDDLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hsSCCH_Specific_Information_ResponseTDDLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hARQ_MemoryPartitioningPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hARQ_MemoryPartitioningPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hsDSCH_MACdFlow_Specific_InformationResp */

   if (pvalue->m.hsDSCH_MACdFlow_Specific_InformationRespPresent) {
      PU_PUSHNAME (pctxt, "hsDSCH_MACdFlow_Specific_InformationResp");

      stat = asn1PD_HSDSCH_MACdFlow_Specific_InformationResp (pctxt, &pvalue->hsDSCH_MACdFlow_Specific_InformationResp);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode hsSCCH_Specific_Information_ResponseTDD */

   if (pvalue->m.hsSCCH_Specific_Information_ResponseTDDPresent) {
      PU_PUSHNAME (pctxt, "hsSCCH_Specific_Information_ResponseTDD");

      stat = asn1PD_HSSCCH_Specific_InformationRespListTDD (pctxt, &pvalue->hsSCCH_Specific_Information_ResponseTDD);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode hsSCCH_Specific_Information_ResponseTDDLCR */

   if (pvalue->m.hsSCCH_Specific_Information_ResponseTDDLCRPresent) {
      PU_PUSHNAME (pctxt, "hsSCCH_Specific_Information_ResponseTDDLCR");

      stat = asn1PD_HSSCCH_Specific_InformationRespListTDDLCR (pctxt, &pvalue->hsSCCH_Specific_Information_ResponseTDDLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode hARQ_MemoryPartitioning */

   if (pvalue->m.hARQ_MemoryPartitioningPresent) {
      PU_PUSHNAME (pctxt, "hARQ_MemoryPartitioning");

      stat = asn1PD_HARQ_MemoryPartitioning (pctxt, &pvalue->hARQ_MemoryPartitioning);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_TDD_Information_Response: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlows_to_Delete_Item                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_MACdFlows_to_Delete_Item (ASN1CTXT* pctxt, HSDSCH_MACdFlows_to_Delete_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlows_to_Delete_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hsDSCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "hsDSCH_MACdFlow_ID");

   stat = asn1PD_HSDSCH_MACdFlow_ID (pctxt, &pvalue->hsDSCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlows_to_Delete_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_MACdFlows_to_Delete                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_MACdFlows_to_Delete (ASN1CTXT* pctxt, HSDSCH_MACdFlows_to_Delete* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   HSDSCH_MACdFlows_to_Delete_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlows_to_Delete: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, HSDSCH_MACdFlows_to_Delete_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_HSDSCH_MACdFlows_to_Delete_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_MACdFlows_to_Delete: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_SICH_Reception_Quality_Value                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HS_SICH_Reception_Quality_Value (ASN1CTXT* pctxt, HS_SICH_Reception_Quality_Value* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_Reception_Quality_Value: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode failed_HS_SICH */

   PU_PUSHNAME (pctxt, "failed_HS_SICH");

   stat = asn1PD_HS_SICH_failed (pctxt, &pvalue->failed_HS_SICH);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode missed_HS_SICH */

   PU_PUSHNAME (pctxt, "missed_HS_SICH");

   stat = asn1PD_HS_SICH_missed (pctxt, &pvalue->missed_HS_SICH);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode total_HS_SICH */

   PU_PUSHNAME (pctxt, "total_HS_SICH");

   stat = asn1PD_HS_SICH_total (pctxt, &pvalue->total_HS_SICH);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HS_SICH_Reception_Quality_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_FDD_Update_Information                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_FDD_Update_Information (ASN1CTXT* pctxt, HSDSCH_FDD_Update_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_FDD_Update_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "hsSCCHCodeChangeIndicatorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hsSCCHCodeChangeIndicatorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cqiFeedback_CycleKPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cqiFeedback_CycleKPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cqiRepetitionFactorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cqiRepetitionFactorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ackNackRepetitionFactorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ackNackRepetitionFactorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cqiPowerOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cqiPowerOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ackPowerOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ackPowerOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "nackPowerOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nackPowerOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hsSCCHCodeChangeIndicator */

   if (pvalue->m.hsSCCHCodeChangeIndicatorPresent) {
      PU_PUSHNAME (pctxt, "hsSCCHCodeChangeIndicator");

      stat = asn1PD_HSSCCH_CodeChangeIndicator (pctxt, &pvalue->hsSCCHCodeChangeIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode cqiFeedback_CycleK */

   if (pvalue->m.cqiFeedback_CycleKPresent) {
      PU_PUSHNAME (pctxt, "cqiFeedback_CycleK");

      stat = asn1PD_CQI_Feedback_Cycle (pctxt, &pvalue->cqiFeedback_CycleK);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode cqiRepetitionFactor */

   if (pvalue->m.cqiRepetitionFactorPresent) {
      PU_PUSHNAME (pctxt, "cqiRepetitionFactor");

      stat = asn1PD_CQI_RepetitionFactor (pctxt, &pvalue->cqiRepetitionFactor);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ackNackRepetitionFactor */

   if (pvalue->m.ackNackRepetitionFactorPresent) {
      PU_PUSHNAME (pctxt, "ackNackRepetitionFactor");

      stat = asn1PD_AckNack_RepetitionFactor (pctxt, &pvalue->ackNackRepetitionFactor);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode cqiPowerOffset */

   if (pvalue->m.cqiPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "cqiPowerOffset");

      stat = asn1PD_CQI_Power_Offset (pctxt, &pvalue->cqiPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ackPowerOffset */

   if (pvalue->m.ackPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "ackPowerOffset");

      stat = asn1PD_Ack_Power_Offset (pctxt, &pvalue->ackPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode nackPowerOffset */

   if (pvalue->m.nackPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "nackPowerOffset");

      stat = asn1PD_Nack_Power_Offset (pctxt, &pvalue->nackPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_FDD_Update_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HSDSCH_TDD_Update_Information                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_HSDSCH_TDD_Update_Information (ASN1CTXT* pctxt, HSDSCH_TDD_Update_Information* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_TDD_Update_Information: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "hsSCCHCodeChangeIndicatorPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hsSCCHCodeChangeIndicatorPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tDDAckNackPowerOffsetPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tDDAckNackPowerOffsetPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode hsSCCHCodeChangeIndicator */

   if (pvalue->m.hsSCCHCodeChangeIndicatorPresent) {
      PU_PUSHNAME (pctxt, "hsSCCHCodeChangeIndicator");

      stat = asn1PD_HSSCCH_CodeChangeIndicator (pctxt, &pvalue->hsSCCHCodeChangeIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tDDAckNackPowerOffset */

   if (pvalue->m.tDDAckNackPowerOffsetPresent) {
      PU_PUSHNAME (pctxt, "tDDAckNackPowerOffset");

      stat = asn1PD_TDD_AckNack_Power_Offset (pctxt, &pvalue->tDDAckNackPowerOffset);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HSDSCH_TDD_Update_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationReportCharacteristicsType_ReportPeriodicity    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationReportCharacteristicsType_ReportPeriodicity (ASN1CTXT* pctxt, InformationReportCharacteristicsType_ReportPeriodicity* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationReportCharacteristicsType_ReportPeriodicity: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* min */
         case 0:
            PU_PUSHNAME (pctxt, "u.min");

            stat = asn1PD_ReportPeriodicity_Scaledmin (pctxt, &pvalue->u.min);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* hours */
         case 1:
            PU_PUSHNAME (pctxt, "u.hours");

            stat = asn1PD_ReportPeriodicity_Scaledhour (pctxt, &pvalue->u.hours);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationReportCharacteristicsType_ReportPeriodicity: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationThresholds                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationThresholds (ASN1CTXT* pctxt, InformationThresholds* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationThresholds: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* dgps */
         case 0:
            PU_PUSHNAME (pctxt, "u.dgps");

            pvalue->u.dgps = rtMemAllocTypeZ (pctxt, DGPSThresholds);
            if (pvalue->u.dgps == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_DGPSThresholds (pctxt, pvalue->u.dgps);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationThresholds: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationReportCharacteristicsType_OnModification       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationReportCharacteristicsType_OnModification (ASN1CTXT* pctxt, InformationReportCharacteristicsType_OnModification* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationReportCharacteristicsType_OnModification: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "information_thresholdsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.information_thresholdsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ie_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode information_thresholds */

   if (pvalue->m.information_thresholdsPresent) {
      PU_PUSHNAME (pctxt, "information_thresholds");

      stat = asn1PD_InformationThresholds (pctxt, &pvalue->information_thresholds);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationReportCharacteristicsType_OnModification: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationReportCharacteristics                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationReportCharacteristics (ASN1CTXT* pctxt, InformationReportCharacteristics* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationReportCharacteristics: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* onDemand */
         case 0:
            PU_PUSHNAME (pctxt, "u.onDemand");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         /* periodic */
         case 1:
            PU_PUSHNAME (pctxt, "u.periodic");

            pvalue->u.periodic = rtMemAllocTypeZ (pctxt, InformationReportCharacteristicsType_ReportPeriodicity);
            if (pvalue->u.periodic == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_InformationReportCharacteristicsType_ReportPeriodicity (pctxt, pvalue->u.periodic);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* onModification */
         case 2:
            PU_PUSHNAME (pctxt, "u.onModification");

            pvalue->u.onModification = rtMemAllocTypeZ (pctxt, InformationReportCharacteristicsType_OnModification);
            if (pvalue->u.onModification == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_InformationReportCharacteristicsType_OnModification (pctxt, pvalue->u.onModification);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationReportCharacteristics: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_InformationType (ASN1CTXT* pctxt, InformationType* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "gPSInformationPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.gPSInformationPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode information_Type_Item */

   PU_PUSHNAME (pctxt, "information_Type_Item");

   stat = asn1PD_Information_Type_Item (pctxt, &pvalue->information_Type_Item);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode gPSInformation */

   if (pvalue->m.gPSInformationPresent) {
      PU_PUSHNAME (pctxt, "gPSInformation");

      stat = asn1PD_GPS_Information (pctxt, &pvalue->gPSInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InformationType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageStructure_element                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MessageStructure_element (ASN1CTXT* pctxt, MessageStructure_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_MessageStructure_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "repetitionNumberPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.repetitionNumberPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode iE_ID */

   PU_PUSHNAME (pctxt, "iE_ID");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->iE_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode repetitionNumber */

   if (pvalue->m.repetitionNumberPresent) {
      PU_PUSHNAME (pctxt, "repetitionNumber");

      stat = asn1PD_RepetitionNumber1 (pctxt, &pvalue->repetitionNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MessageStructure_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageStructure                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_MessageStructure (ASN1CTXT* pctxt, MessageStructure* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   MessageStructure_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_MessageStructure: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, MessageStructure_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_MessageStructure_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MessageStructure: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UC_Id                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UC_Id (ASN1CTXT* pctxt, UC_Id* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UC_Id: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rNC_ID */

   PU_PUSHNAME (pctxt, "rNC_ID");

   stat = asn1PD_RNC_ID (pctxt, &pvalue->rNC_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode c_ID */

   PU_PUSHNAME (pctxt, "c_ID");

   stat = asn1PD_C_ID (pctxt, &pvalue->c_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UC_Id: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NeighbouringFDDCellMeasurementInformation                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NeighbouringFDDCellMeasurementInformation (ASN1CTXT* pctxt, NeighbouringFDDCellMeasurementInformation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_NeighbouringFDDCellMeasurementInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode uC_Id */

   PU_PUSHNAME (pctxt, "uC_Id");

   stat = asn1PD_UC_Id (pctxt, &pvalue->uC_Id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uARFCN */

   PU_PUSHNAME (pctxt, "uARFCN");

   stat = asn1PD_UARFCN (pctxt, &pvalue->uARFCN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode primaryScramblingCode */

   PU_PUSHNAME (pctxt, "primaryScramblingCode");

   stat = asn1PD_PrimaryScramblingCode (pctxt, &pvalue->primaryScramblingCode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NeighbouringFDDCellMeasurementInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NeighbouringTDDCellMeasurementInformation                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NeighbouringTDDCellMeasurementInformation (ASN1CTXT* pctxt, NeighbouringTDDCellMeasurementInformation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_NeighbouringTDDCellMeasurementInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "timeSlotPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.timeSlotPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "midambleShiftAndBurstTypePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.midambleShiftAndBurstTypePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode uC_Id */

   PU_PUSHNAME (pctxt, "uC_Id");

   stat = asn1PD_UC_Id (pctxt, &pvalue->uC_Id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uARFCN */

   PU_PUSHNAME (pctxt, "uARFCN");

   stat = asn1PD_UARFCN (pctxt, &pvalue->uARFCN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cellParameterID */

   PU_PUSHNAME (pctxt, "cellParameterID");

   stat = asn1PD_CellParameterID (pctxt, &pvalue->cellParameterID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlot */

   if (pvalue->m.timeSlotPresent) {
      PU_PUSHNAME (pctxt, "timeSlot");

      stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode midambleShiftAndBurstType */

   if (pvalue->m.midambleShiftAndBurstTypePresent) {
      PU_PUSHNAME (pctxt, "midambleShiftAndBurstType");

      stat = asn1PD_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NeighbouringTDDCellMeasurementInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NeighbouringCellMeasurementInformation_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NeighbouringCellMeasurementInformation_element (ASN1CTXT* pctxt, NeighbouringCellMeasurementInformation_element* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;
   ASN1CTXT lctxt;

   RTDIAGSTRM2 (pctxt,"asn1PD_NeighbouringCellMeasurementInformation_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* neighbouringFDDCellMeasurementInformation */
         case 0:
            PU_PUSHNAME (pctxt, "u.neighbouringFDDCellMeasurementInformation");

            pvalue->u.neighbouringFDDCellMeasurementInformation = rtMemAllocTypeZ (pctxt, NeighbouringFDDCellMeasurementInformation);
            if (pvalue->u.neighbouringFDDCellMeasurementInformation == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_NeighbouringFDDCellMeasurementInformation (pctxt, pvalue->u.neighbouringFDDCellMeasurementInformation);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* neighbouringTDDCellMeasurementInformation */
         case 1:
            PU_PUSHNAME (pctxt, "u.neighbouringTDDCellMeasurementInformation");

            pvalue->u.neighbouringTDDCellMeasurementInformation = rtMemAllocTypeZ (pctxt, NeighbouringTDDCellMeasurementInformation);
            if (pvalue->u.neighbouringTDDCellMeasurementInformation == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_NeighbouringTDDCellMeasurementInformation (pctxt, pvalue->u.neighbouringTDDCellMeasurementInformation);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      rtCopyContext (&lctxt, pctxt);
      rtInitContextBuffer (pctxt, openType.data, openType.numocts);
      pu_setTrace (pctxt, FALSE);

      switch (pvalue->t) {
         /* extension_neighbouringCellMeasurementInformation */
         case 3:
            PU_PUSHNAME (pctxt, "u.extension_neighbouringCellMeasurementInformation");

            pvalue->u.extension_neighbouringCellMeasurementInformation = rtMemAllocTypeZ (pctxt, Extension_neighbouringCellMeasurementInformation);
            if (pvalue->u.extension_neighbouringCellMeasurementInformation == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Extension_neighbouringCellMeasurementInformation (pctxt, pvalue->u.extension_neighbouringCellMeasurementInformation);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            PU_PUSHNAME (pctxt, "extension");

            pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

            PU_POPNAME (pctxt);

      }

      rtCopyContext (pctxt, &lctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NeighbouringCellMeasurementInformation_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NeighbouringCellMeasurementInformation                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NeighbouringCellMeasurementInformation (ASN1CTXT* pctxt, NeighbouringCellMeasurementInformation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(96), 0 };
   int stat = 0;
   NeighbouringCellMeasurementInformation_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_NeighbouringCellMeasurementInformation: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, NeighbouringCellMeasurementInformation_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_NeighbouringCellMeasurementInformation_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NeighbouringCellMeasurementInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NeighbouringTDDCellMeasurementInformationLCR              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NeighbouringTDDCellMeasurementInformationLCR (ASN1CTXT* pctxt, NeighbouringTDDCellMeasurementInformationLCR* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_NeighbouringTDDCellMeasurementInformationLCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "timeSlotLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.timeSlotLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "midambleShiftLCRPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.midambleShiftLCRPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode uC_Id */

   PU_PUSHNAME (pctxt, "uC_Id");

   stat = asn1PD_UC_Id (pctxt, &pvalue->uC_Id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uARFCN */

   PU_PUSHNAME (pctxt, "uARFCN");

   stat = asn1PD_UARFCN (pctxt, &pvalue->uARFCN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cellParameterID */

   PU_PUSHNAME (pctxt, "cellParameterID");

   stat = asn1PD_CellParameterID (pctxt, &pvalue->cellParameterID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlotLCR */

   if (pvalue->m.timeSlotLCRPresent) {
      PU_PUSHNAME (pctxt, "timeSlotLCR");

      stat = asn1PD_TimeSlotLCR (pctxt, &pvalue->timeSlotLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode midambleShiftLCR */

   if (pvalue->m.midambleShiftLCRPresent) {
      PU_PUSHNAME (pctxt, "midambleShiftLCR");

      stat = asn1PD_MidambleShiftLCR (pctxt, &pvalue->midambleShiftLCR);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NeighbouringTDDCellMeasurementInformationLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NI_Information                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_NI_Information (ASN1CTXT* pctxt, NI_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_NI_Information: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "n");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &pvalue->n);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   if (256 < pvalue->n) {
      return LOG_ASN1ERR (pctxt, ASN_E_ARRAYSIZE);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      stat = asn1PD_Notification_Indicator (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NI_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Specific_DCH_Info_Item                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Specific_DCH_Info_Item (ASN1CTXT* pctxt, RL_Specific_DCH_Info_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Specific_DCH_Info_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bindingIDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportlayeraddressPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportlayeraddressPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode dCH_id */

   PU_PUSHNAME (pctxt, "dCH_id");

   stat = asn1PD_DCH_ID (pctxt, &pvalue->dCH_id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PD_BindingID (pctxt, &pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportlayeraddress */

   if (pvalue->m.transportlayeraddressPresent) {
      PU_PUSHNAME (pctxt, "transportlayeraddress");

      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportlayeraddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Specific_DCH_Info_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Specific_DCH_Info                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Specific_DCH_Info (ASN1CTXT* pctxt, RL_Specific_DCH_Info* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   RL_Specific_DCH_Info_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Specific_DCH_Info: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RL_Specific_DCH_Info_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RL_Specific_DCH_Info_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Specific_DCH_Info: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Specific_E_DCH_Info_Item                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Specific_E_DCH_Info_Item (ASN1CTXT* pctxt, RL_Specific_E_DCH_Info_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Specific_E_DCH_Info_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bindingIDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportlayeraddressPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportlayeraddressPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode e_DCH_MACdFlow_ID */

   PU_PUSHNAME (pctxt, "e_DCH_MACdFlow_ID");

   stat = asn1PD_E_DCH_MACdFlow_ID (pctxt, &pvalue->e_DCH_MACdFlow_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PD_BindingID (pctxt, &pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportlayeraddress */

   if (pvalue->m.transportlayeraddressPresent) {
      PU_PUSHNAME (pctxt, "transportlayeraddress");

      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportlayeraddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Specific_E_DCH_Info_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RL_Specific_E_DCH_Info                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_RL_Specific_E_DCH_Info (ASN1CTXT* pctxt, RL_Specific_E_DCH_Info* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   RL_Specific_E_DCH_Info_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Specific_E_DCH_Info: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RL_Specific_E_DCH_Info_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_RL_Specific_E_DCH_Info_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RL_Specific_E_DCH_Info: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_ReportPeriodicity               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReportCharacteristicsType_ReportPeriodicity (ASN1CTXT* pctxt, ReportCharacteristicsType_ReportPeriodicity* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_ReportPeriodicity: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* msec */
         case 0:
            PU_PUSHNAME (pctxt, "u.msec");

            stat = asn1PD_ReportPeriodicity_Scaledmsec (pctxt, &pvalue->u.msec);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* min */
         case 1:
            PU_PUSHNAME (pctxt, "u.min");

            stat = asn1PD_ReportPeriodicity_Scaledmin (pctxt, &pvalue->u.min);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_ReportPeriodicity: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_MeasurementThreshold            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReportCharacteristicsType_MeasurementThreshold (ASN1CTXT* pctxt, ReportCharacteristicsType_MeasurementThreshold* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;
   ASN1CTXT lctxt;

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_MeasurementThreshold: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(11));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* received_total_wide_band_power */
         case 0:
            PU_PUSHNAME (pctxt, "u.received_total_wide_band_power");

            stat = asn1PD_Received_total_wide_band_power_Value (pctxt, &pvalue->u.received_total_wide_band_power);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* transmitted_carrier_power */
         case 1:
            PU_PUSHNAME (pctxt, "u.transmitted_carrier_power");

            stat = asn1PD_Transmitted_Carrier_Power_Value (pctxt, &pvalue->u.transmitted_carrier_power);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* acknowledged_prach_preambles */
         case 2:
            PU_PUSHNAME (pctxt, "u.acknowledged_prach_preambles");

            stat = asn1PD_Acknowledged_PRACH_preambles_Value (pctxt, &pvalue->u.acknowledged_prach_preambles);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* uL_TimeslotISCP */
         case 3:
            PU_PUSHNAME (pctxt, "u.uL_TimeslotISCP");

            stat = asn1PD_UL_TimeslotISCP_Value (pctxt, &pvalue->u.uL_TimeslotISCP);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* sir */
         case 4:
            PU_PUSHNAME (pctxt, "u.sir");

            stat = asn1PD_SIR_Value (pctxt, &pvalue->u.sir);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* sir_error */
         case 5:
            PU_PUSHNAME (pctxt, "u.sir_error");

            stat = asn1PD_SIR_Error_Value (pctxt, &pvalue->u.sir_error);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* transmitted_code_power */
         case 6:
            PU_PUSHNAME (pctxt, "u.transmitted_code_power");

            stat = asn1PD_Transmitted_Code_Power_Value (pctxt, &pvalue->u.transmitted_code_power);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* rscp */
         case 7:
            PU_PUSHNAME (pctxt, "u.rscp");

            stat = asn1PD_RSCP_Value (pctxt, &pvalue->u.rscp);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* rx_timing_deviation */
         case 8:
            PU_PUSHNAME (pctxt, "u.rx_timing_deviation");

            stat = asn1PD_Rx_Timing_Deviation_Value (pctxt, &pvalue->u.rx_timing_deviation);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* round_trip_time */
         case 9:
            PU_PUSHNAME (pctxt, "u.round_trip_time");

            stat = asn1PD_Round_Trip_Time_Value (pctxt, &pvalue->u.round_trip_time);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* notUsed_1_acknowledged_PCPCH_access_preambles */
         case 10:
            PU_PUSHNAME (pctxt, "u.notUsed_1_acknowledged_PCPCH_access_preambles");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         /* notUsed_2_detected_PCPCH_access_preambles */
         case 11:
            PU_PUSHNAME (pctxt, "u.notUsed_2_detected_PCPCH_access_preambles");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 13;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      rtCopyContext (&lctxt, pctxt);
      rtInitContextBuffer (pctxt, openType.data, openType.numocts);
      pu_setTrace (pctxt, FALSE);

      switch (pvalue->t) {
         /* extension_ReportCharacteristicsType_MeasurementThreshold */
         case 13:
            PU_PUSHNAME (pctxt, "u.extension_ReportCharacteristicsType_MeasurementThreshold");

            pvalue->u.extension_ReportCharacteristicsType_MeasurementThreshold = rtMemAllocTypeZ (pctxt, Extension_ReportCharacteristicsType_MeasurementThreshold);
            if (pvalue->u.extension_ReportCharacteristicsType_MeasurementThreshold == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Extension_ReportCharacteristicsType_MeasurementThreshold (pctxt, pvalue->u.extension_ReportCharacteristicsType_MeasurementThreshold);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            PU_PUSHNAME (pctxt, "extension");

            pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

            PU_POPNAME (pctxt);

      }

      rtCopyContext (pctxt, &lctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_MeasurementThreshold: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_ScaledMeasurementHysteresisTim  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReportCharacteristicsType_ScaledMeasurementHysteresisTime (ASN1CTXT* pctxt, ReportCharacteristicsType_ScaledMeasurementHysteresisTime* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_ScaledMeasurementHysteresisTime: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* msec */
         case 0:
            PU_PUSHNAME (pctxt, "u.msec");

            stat = asn1PD_MeasurementHysteresisTime_Scaledmsec (pctxt, &pvalue->u.msec);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_ScaledMeasurementHysteresisTime: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_EventA                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReportCharacteristicsType_EventA (ASN1CTXT* pctxt, ReportCharacteristicsType_EventA* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_EventA: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "measurementHysteresisTimePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.measurementHysteresisTimePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode measurementThreshold */

   PU_PUSHNAME (pctxt, "measurementThreshold");

   stat = asn1PD_ReportCharacteristicsType_MeasurementThreshold (pctxt, &pvalue->measurementThreshold);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode measurementHysteresisTime */

   if (pvalue->m.measurementHysteresisTimePresent) {
      PU_PUSHNAME (pctxt, "measurementHysteresisTime");

      stat = asn1PD_ReportCharacteristicsType_ScaledMeasurementHysteresisTime (pctxt, &pvalue->measurementHysteresisTime);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_EventA: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_EventB                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReportCharacteristicsType_EventB (ASN1CTXT* pctxt, ReportCharacteristicsType_EventB* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_EventB: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "measurementHysteresisTimePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.measurementHysteresisTimePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode measurementThreshold */

   PU_PUSHNAME (pctxt, "measurementThreshold");

   stat = asn1PD_ReportCharacteristicsType_MeasurementThreshold (pctxt, &pvalue->measurementThreshold);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode measurementHysteresisTime */

   if (pvalue->m.measurementHysteresisTimePresent) {
      PU_PUSHNAME (pctxt, "measurementHysteresisTime");

      stat = asn1PD_ReportCharacteristicsType_ScaledMeasurementHysteresisTime (pctxt, &pvalue->measurementHysteresisTime);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_EventB: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_MeasurementIncreaseDecreaseThr  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold (ASN1CTXT* pctxt, ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;
   ASN1CTXT lctxt;

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(10));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* received_total_wide_band_power */
         case 0:
            PU_PUSHNAME (pctxt, "u.received_total_wide_band_power");

            stat = asn1PD_Received_total_wide_band_power_Value_IncrDecrThres (pctxt, &pvalue->u.received_total_wide_band_power);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* transmitted_carrier_power */
         case 1:
            PU_PUSHNAME (pctxt, "u.transmitted_carrier_power");

            stat = asn1PD_Transmitted_Carrier_Power_Value (pctxt, &pvalue->u.transmitted_carrier_power);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* acknowledged_prach_preambles */
         case 2:
            PU_PUSHNAME (pctxt, "u.acknowledged_prach_preambles");

            stat = asn1PD_Acknowledged_PRACH_preambles_Value (pctxt, &pvalue->u.acknowledged_prach_preambles);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* uL_TimeslotISCP */
         case 3:
            PU_PUSHNAME (pctxt, "u.uL_TimeslotISCP");

            stat = asn1PD_UL_TimeslotISCP_Value_IncrDecrThres (pctxt, &pvalue->u.uL_TimeslotISCP);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* sir */
         case 4:
            PU_PUSHNAME (pctxt, "u.sir");

            stat = asn1PD_SIR_Value_IncrDecrThres (pctxt, &pvalue->u.sir);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* sir_error */
         case 5:
            PU_PUSHNAME (pctxt, "u.sir_error");

            stat = asn1PD_SIR_Error_Value_IncrDecrThres (pctxt, &pvalue->u.sir_error);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* transmitted_code_power */
         case 6:
            PU_PUSHNAME (pctxt, "u.transmitted_code_power");

            stat = asn1PD_Transmitted_Code_Power_Value_IncrDecrThres (pctxt, &pvalue->u.transmitted_code_power);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* rscp */
         case 7:
            PU_PUSHNAME (pctxt, "u.rscp");

            stat = asn1PD_RSCP_Value_IncrDecrThres (pctxt, &pvalue->u.rscp);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* round_trip_time */
         case 8:
            PU_PUSHNAME (pctxt, "u.round_trip_time");

            stat = asn1PD_Round_Trip_Time_IncrDecrThres (pctxt, &pvalue->u.round_trip_time);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* notUsed_1_acknowledged_PCPCH_access_preambles */
         case 9:
            PU_PUSHNAME (pctxt, "u.notUsed_1_acknowledged_PCPCH_access_preambles");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         /* notUsed_2_detected_PCPCH_access_preambles */
         case 10:
            PU_PUSHNAME (pctxt, "u.notUsed_2_detected_PCPCH_access_preambles");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 12;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      rtCopyContext (&lctxt, pctxt);
      rtInitContextBuffer (pctxt, openType.data, openType.numocts);
      pu_setTrace (pctxt, FALSE);

      switch (pvalue->t) {
         /* extension_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold */
         case 12:
            PU_PUSHNAME (pctxt, "u.extension_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold");

            pvalue->u.extension_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold = rtMemAllocTypeZ (pctxt, Extension_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold);
            if (pvalue->u.extension_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Extension_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold (pctxt, pvalue->u.extension_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            PU_PUSHNAME (pctxt, "extension");

            pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

            PU_POPNAME (pctxt);

      }

      rtCopyContext (pctxt, &lctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_ScaledMeasurementChangeTime     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReportCharacteristicsType_ScaledMeasurementChangeTime (ASN1CTXT* pctxt, ReportCharacteristicsType_ScaledMeasurementChangeTime* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_ScaledMeasurementChangeTime: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* msec */
         case 0:
            PU_PUSHNAME (pctxt, "u.msec");

            stat = asn1PD_MeasurementChangeTime_Scaledmsec (pctxt, &pvalue->u.msec);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_ScaledMeasurementChangeTime: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_EventC                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReportCharacteristicsType_EventC (ASN1CTXT* pctxt, ReportCharacteristicsType_EventC* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_EventC: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode measurementIncreaseThreshold */

   PU_PUSHNAME (pctxt, "measurementIncreaseThreshold");

   stat = asn1PD_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold (pctxt, &pvalue->measurementIncreaseThreshold);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode measurementChangeTime */

   PU_PUSHNAME (pctxt, "measurementChangeTime");

   stat = asn1PD_ReportCharacteristicsType_ScaledMeasurementChangeTime (pctxt, &pvalue->measurementChangeTime);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_EventC: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_EventD                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReportCharacteristicsType_EventD (ASN1CTXT* pctxt, ReportCharacteristicsType_EventD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_EventD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode measurementDecreaseThreshold */

   PU_PUSHNAME (pctxt, "measurementDecreaseThreshold");

   stat = asn1PD_ReportCharacteristicsType_MeasurementIncreaseDecreaseThreshold (pctxt, &pvalue->measurementDecreaseThreshold);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode measurementChangeTime */

   PU_PUSHNAME (pctxt, "measurementChangeTime");

   stat = asn1PD_ReportCharacteristicsType_ScaledMeasurementChangeTime (pctxt, &pvalue->measurementChangeTime);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_EventD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_EventE                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReportCharacteristicsType_EventE (ASN1CTXT* pctxt, ReportCharacteristicsType_EventE* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_EventE: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "measurementThreshold2Present");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.measurementThreshold2Present = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "measurementHysteresisTimePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.measurementHysteresisTimePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "reportPeriodicityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.reportPeriodicityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode measurementThreshold1 */

   PU_PUSHNAME (pctxt, "measurementThreshold1");

   stat = asn1PD_ReportCharacteristicsType_MeasurementThreshold (pctxt, &pvalue->measurementThreshold1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode measurementThreshold2 */

   if (pvalue->m.measurementThreshold2Present) {
      PU_PUSHNAME (pctxt, "measurementThreshold2");

      stat = asn1PD_ReportCharacteristicsType_MeasurementThreshold (pctxt, &pvalue->measurementThreshold2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode measurementHysteresisTime */

   if (pvalue->m.measurementHysteresisTimePresent) {
      PU_PUSHNAME (pctxt, "measurementHysteresisTime");

      stat = asn1PD_ReportCharacteristicsType_ScaledMeasurementHysteresisTime (pctxt, &pvalue->measurementHysteresisTime);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode reportPeriodicity */

   if (pvalue->m.reportPeriodicityPresent) {
      PU_PUSHNAME (pctxt, "reportPeriodicity");

      stat = asn1PD_ReportCharacteristicsType_ReportPeriodicity (pctxt, &pvalue->reportPeriodicity);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_EventE: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_EventF                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReportCharacteristicsType_EventF (ASN1CTXT* pctxt, ReportCharacteristicsType_EventF* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_EventF: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "measurementThreshold2Present");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.measurementThreshold2Present = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "measurementHysteresisTimePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.measurementHysteresisTimePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "reportPeriodicityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.reportPeriodicityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode measurementThreshold1 */

   PU_PUSHNAME (pctxt, "measurementThreshold1");

   stat = asn1PD_ReportCharacteristicsType_MeasurementThreshold (pctxt, &pvalue->measurementThreshold1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode measurementThreshold2 */

   if (pvalue->m.measurementThreshold2Present) {
      PU_PUSHNAME (pctxt, "measurementThreshold2");

      stat = asn1PD_ReportCharacteristicsType_MeasurementThreshold (pctxt, &pvalue->measurementThreshold2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode measurementHysteresisTime */

   if (pvalue->m.measurementHysteresisTimePresent) {
      PU_PUSHNAME (pctxt, "measurementHysteresisTime");

      stat = asn1PD_ReportCharacteristicsType_ScaledMeasurementHysteresisTime (pctxt, &pvalue->measurementHysteresisTime);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode reportPeriodicity */

   if (pvalue->m.reportPeriodicityPresent) {
      PU_PUSHNAME (pctxt, "reportPeriodicity");

      stat = asn1PD_ReportCharacteristicsType_ReportPeriodicity (pctxt, &pvalue->reportPeriodicity);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_EventF: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristics                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReportCharacteristics (ASN1CTXT* pctxt, ReportCharacteristics* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;
   ASN1CTXT lctxt;

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristics: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* onDemand */
         case 0:
            PU_PUSHNAME (pctxt, "u.onDemand");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         /* periodic */
         case 1:
            PU_PUSHNAME (pctxt, "u.periodic");

            pvalue->u.periodic = rtMemAllocTypeZ (pctxt, ReportCharacteristicsType_ReportPeriodicity);
            if (pvalue->u.periodic == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_ReportCharacteristicsType_ReportPeriodicity (pctxt, pvalue->u.periodic);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* event_a */
         case 2:
            PU_PUSHNAME (pctxt, "u.event_a");

            pvalue->u.event_a = rtMemAllocTypeZ (pctxt, ReportCharacteristicsType_EventA);
            if (pvalue->u.event_a == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_ReportCharacteristicsType_EventA (pctxt, pvalue->u.event_a);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* event_b */
         case 3:
            PU_PUSHNAME (pctxt, "u.event_b");

            pvalue->u.event_b = rtMemAllocTypeZ (pctxt, ReportCharacteristicsType_EventB);
            if (pvalue->u.event_b == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_ReportCharacteristicsType_EventB (pctxt, pvalue->u.event_b);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* event_c */
         case 4:
            PU_PUSHNAME (pctxt, "u.event_c");

            pvalue->u.event_c = rtMemAllocTypeZ (pctxt, ReportCharacteristicsType_EventC);
            if (pvalue->u.event_c == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_ReportCharacteristicsType_EventC (pctxt, pvalue->u.event_c);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* event_d */
         case 5:
            PU_PUSHNAME (pctxt, "u.event_d");

            pvalue->u.event_d = rtMemAllocTypeZ (pctxt, ReportCharacteristicsType_EventD);
            if (pvalue->u.event_d == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_ReportCharacteristicsType_EventD (pctxt, pvalue->u.event_d);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* event_e */
         case 6:
            PU_PUSHNAME (pctxt, "u.event_e");

            pvalue->u.event_e = rtMemAllocTypeZ (pctxt, ReportCharacteristicsType_EventE);
            if (pvalue->u.event_e == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_ReportCharacteristicsType_EventE (pctxt, pvalue->u.event_e);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* event_f */
         case 7:
            PU_PUSHNAME (pctxt, "u.event_f");

            pvalue->u.event_f = rtMemAllocTypeZ (pctxt, ReportCharacteristicsType_EventF);
            if (pvalue->u.event_f == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_ReportCharacteristicsType_EventF (pctxt, pvalue->u.event_f);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 9;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      rtCopyContext (&lctxt, pctxt);
      rtInitContextBuffer (pctxt, openType.data, openType.numocts);
      pu_setTrace (pctxt, FALSE);

      switch (pvalue->t) {
         /* extension_ReportCharacteristics */
         case 9:
            PU_PUSHNAME (pctxt, "u.extension_ReportCharacteristics");

            pvalue->u.extension_ReportCharacteristics = rtMemAllocTypeZ (pctxt, Extension_ReportCharacteristics);
            if (pvalue->u.extension_ReportCharacteristics == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Extension_ReportCharacteristics (pctxt, pvalue->u.extension_ReportCharacteristics);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            PU_PUSHNAME (pctxt, "extension");

            pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

            PU_POPNAME (pctxt);

      }

      rtCopyContext (pctxt, &lctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristics: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportCharacteristicsType_OnModification                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_ReportCharacteristicsType_OnModification (ASN1CTXT* pctxt, ReportCharacteristicsType_OnModification* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_OnModification: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode measurementThreshold */

   PU_PUSHNAME (pctxt, "measurementThreshold");

   stat = asn1PD_ReportCharacteristicsType_MeasurementThreshold (pctxt, &pvalue->measurementThreshold);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportCharacteristicsType_OnModification: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Received_total_wide_band_power_For_CellPortion_Value_Ite  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Received_total_wide_band_power_For_CellPortion_Value_Item (ASN1CTXT* pctxt, Received_total_wide_band_power_For_CellPortion_Value_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Received_total_wide_band_power_For_CellPortion_Value_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cellPortionID */

   PU_PUSHNAME (pctxt, "cellPortionID");

   stat = asn1PD_CellPortionID (pctxt, &pvalue->cellPortionID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode received_total_wide_band_power_value */

   PU_PUSHNAME (pctxt, "received_total_wide_band_power_value");

   stat = asn1PD_Received_total_wide_band_power_Value (pctxt, &pvalue->received_total_wide_band_power_value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Received_total_wide_band_power_For_CellPortion_Value_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Received_total_wide_band_power_For_CellPortion_Value      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Received_total_wide_band_power_For_CellPortion_Value (ASN1CTXT* pctxt, Received_total_wide_band_power_For_CellPortion_Value* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   Received_total_wide_band_power_For_CellPortion_Value_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Received_total_wide_band_power_For_CellPortion_Value: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Received_total_wide_band_power_For_CellPortion_Value_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Received_total_wide_band_power_For_CellPortion_Value_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Received_total_wide_band_power_For_CellPortion_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtItem                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_ExtItem (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "ie_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.ie_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode data_id */

   PU_PUSHNAME (pctxt, "data_id");

   stat = asn1PD_DATA_ID (pctxt, &pvalue->data_id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sat_id */

   PU_PUSHNAME (pctxt, "sat_id");

   stat = asn1PD_SAT_ID (pctxt, &pvalue->sat_id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode gps_e_alm */

   PU_PUSHNAME (pctxt, "gps_e_alm");

   stat = asn1PD_SAT_Info_Almanac_ExtItem_gps_e_alm (pctxt, &pvalue->gps_e_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode gps_toa_alm */

   PU_PUSHNAME (pctxt, "gps_toa_alm");

   stat = asn1PD_SAT_Info_Almanac_ExtItem_gps_toa_alm (pctxt, &pvalue->gps_toa_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode gps_delta_I_alm */

   PU_PUSHNAME (pctxt, "gps_delta_I_alm");

   stat = asn1PD_SAT_Info_Almanac_ExtItem_gps_delta_I_alm (pctxt, &pvalue->gps_delta_I_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode omegadot_alm */

   PU_PUSHNAME (pctxt, "omegadot_alm");

   stat = asn1PD_SAT_Info_Almanac_ExtItem_omegadot_alm (pctxt, &pvalue->omegadot_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode svhealth_alm */

   PU_PUSHNAME (pctxt, "svhealth_alm");

   stat = asn1PD_SAT_Info_Almanac_ExtItem_svhealth_alm (pctxt, &pvalue->svhealth_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode gps_a_sqrt_alm */

   PU_PUSHNAME (pctxt, "gps_a_sqrt_alm");

   stat = asn1PD_SAT_Info_Almanac_ExtItem_gps_a_sqrt_alm (pctxt, &pvalue->gps_a_sqrt_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode omegazero_alm */

   PU_PUSHNAME (pctxt, "omegazero_alm");

   stat = asn1PD_SAT_Info_Almanac_ExtItem_omegazero_alm (pctxt, &pvalue->omegazero_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode m_zero_alm */

   PU_PUSHNAME (pctxt, "m_zero_alm");

   stat = asn1PD_SAT_Info_Almanac_ExtItem_m_zero_alm (pctxt, &pvalue->m_zero_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode gps_omega_alm */

   PU_PUSHNAME (pctxt, "gps_omega_alm");

   stat = asn1PD_SAT_Info_Almanac_ExtItem_gps_omega_alm (pctxt, &pvalue->gps_omega_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode gps_af_zero_alm */

   PU_PUSHNAME (pctxt, "gps_af_zero_alm");

   stat = asn1PD_SAT_Info_Almanac_ExtItem_gps_af_zero_alm (pctxt, &pvalue->gps_af_zero_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode gps_af_one_alm */

   PU_PUSHNAME (pctxt, "gps_af_one_alm");

   stat = asn1PD_SAT_Info_Almanac_ExtItem_gps_af_one_alm (pctxt, &pvalue->gps_af_one_alm);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ie_Extensions */

   if (pvalue->m.ie_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "ie_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->ie_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAT_Info_Almanac_ExtList                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SAT_Info_Almanac_ExtList (ASN1CTXT* pctxt, SAT_Info_Almanac_ExtList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   SAT_Info_Almanac_ExtItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtList: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SAT_Info_Almanac_ExtItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SAT_Info_Almanac_ExtItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SAT_Info_Almanac_ExtList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Secondary_CPICH_Information_Change                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Secondary_CPICH_Information_Change (ASN1CTXT* pctxt, Secondary_CPICH_Information_Change* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CPICH_Information_Change: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* new_secondary_CPICH */
         case 0:
            PU_PUSHNAME (pctxt, "u.new_secondary_CPICH");

            stat = asn1PD_CommonPhysicalChannelID (pctxt, &pvalue->u.new_secondary_CPICH);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* secondary_CPICH_shall_not_be_used */
         case 1:
            PU_PUSHNAME (pctxt, "u.secondary_CPICH_shall_not_be_used");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Secondary_CPICH_Information_Change: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Serving_E_DCH_RL_in_this_NodeB                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Serving_E_DCH_RL_in_this_NodeB (ASN1CTXT* pctxt, Serving_E_DCH_RL_in_this_NodeB* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Serving_E_DCH_RL_in_this_NodeB: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode rL_ID */

   PU_PUSHNAME (pctxt, "rL_ID");

   stat = asn1PD_RL_ID (pctxt, &pvalue->rL_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Serving_E_DCH_RL_in_this_NodeB: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Serving_E_DCH_RL_ID                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Serving_E_DCH_RL_ID (ASN1CTXT* pctxt, Serving_E_DCH_RL_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Serving_E_DCH_RL_ID: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* serving_E_DCH_RL_in_this_NodeB */
         case 0:
            PU_PUSHNAME (pctxt, "u.serving_E_DCH_RL_in_this_NodeB");

            pvalue->u.serving_E_DCH_RL_in_this_NodeB = rtMemAllocTypeZ (pctxt, Serving_E_DCH_RL_in_this_NodeB);
            if (pvalue->u.serving_E_DCH_RL_in_this_NodeB == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_Serving_E_DCH_RL_in_this_NodeB (pctxt, pvalue->u.serving_E_DCH_RL_in_this_NodeB);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* serving_E_DCH_RL_not_in_this_NodeB */
         case 1:
            PU_PUSHNAME (pctxt, "u.serving_E_DCH_RL_not_in_this_NodeB");

            /* NULL */

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Serving_E_DCH_RL_ID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNMeasurementThresholdInformation                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SFNSFNMeasurementThresholdInformation (ASN1CTXT* pctxt, SFNSFNMeasurementThresholdInformation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNMeasurementThresholdInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "sFNSFNChangeLimitPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sFNSFNChangeLimitPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "predictedSFNSFNDeviationLimitPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.predictedSFNSFNDeviationLimitPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode sFNSFNChangeLimit */

   if (pvalue->m.sFNSFNChangeLimitPresent) {
      PU_PUSHNAME (pctxt, "sFNSFNChangeLimit");

      stat = asn1PD_SFNSFNChangeLimit (pctxt, &pvalue->sFNSFNChangeLimit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode predictedSFNSFNDeviationLimit */

   if (pvalue->m.predictedSFNSFNDeviationLimitPresent) {
      PU_PUSHNAME (pctxt, "predictedSFNSFNDeviationLimit");

      stat = asn1PD_PredictedSFNSFNDeviationLimit (pctxt, &pvalue->predictedSFNSFNDeviationLimit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNMeasurementThresholdInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNValue                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SFNSFNValue (ASN1CTXT* pctxt, SFNSFNValue* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNValue: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* sFNSFN_FDD */
         case 0:
            PU_PUSHNAME (pctxt, "u.sFNSFN_FDD");

            stat = asn1PD_SFNSFN_FDD (pctxt, &pvalue->u.sFNSFN_FDD);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* sFNSFN_TDD */
         case 1:
            PU_PUSHNAME (pctxt, "u.sFNSFN_TDD");

            stat = asn1PD_SFNSFN_TDD (pctxt, &pvalue->u.sFNSFN_TDD);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNTimeStamp_TDD                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SFNSFNTimeStamp_TDD (ASN1CTXT* pctxt, SFNSFNTimeStamp_TDD* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNTimeStamp_TDD: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode sFN */

   PU_PUSHNAME (pctxt, "sFN");

   stat = asn1PD_SFN (pctxt, &pvalue->sFN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode timeSlot */

   PU_PUSHNAME (pctxt, "timeSlot");

   stat = asn1PD_TimeSlot (pctxt, &pvalue->timeSlot);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNTimeStamp_TDD: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNTimeStampInformation                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SFNSFNTimeStampInformation (ASN1CTXT* pctxt, SFNSFNTimeStampInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNTimeStampInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      PU_PUSHNAME (pctxt, "t");

      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      PU_POPNAME (pctxt);

      switch (ui) {
         /* sFNSFNTimeStamp_FDD */
         case 0:
            PU_PUSHNAME (pctxt, "u.sFNSFNTimeStamp_FDD");

            stat = asn1PD_SFN (pctxt, &pvalue->u.sFNSFNTimeStamp_FDD);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         /* sFNSFNTimeStamp_TDD */
         case 1:
            PU_PUSHNAME (pctxt, "u.sFNSFNTimeStamp_TDD");

            pvalue->u.sFNSFNTimeStamp_TDD = rtMemAllocTypeZ (pctxt, SFNSFNTimeStamp_TDD);
            if (pvalue->u.sFNSFNTimeStamp_TDD == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_SFNSFNTimeStamp_TDD (pctxt, pvalue->u.sFNSFNTimeStamp_TDD);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            PU_POPNAME (pctxt);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_PUSHNAME (pctxt, "choice extension");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);

      PU_PUSHNAME (pctxt, "extension");

      pvalue->u.extElem1 = rtMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      PU_POPNAME (pctxt);

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNTimeStampInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNMeasurementValueInformation_successfullNeighbourin  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element (ASN1CTXT* pctxt, SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "sFNSFNQualityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sFNSFNQualityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "sFNSFNDriftRateQualityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sFNSFNDriftRateQualityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode uC_Id */

   PU_PUSHNAME (pctxt, "uC_Id");

   stat = asn1PD_UC_Id (pctxt, &pvalue->uC_Id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sFNSFNValue */

   PU_PUSHNAME (pctxt, "sFNSFNValue");

   stat = asn1PD_SFNSFNValue (pctxt, &pvalue->sFNSFNValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sFNSFNQuality */

   if (pvalue->m.sFNSFNQualityPresent) {
      PU_PUSHNAME (pctxt, "sFNSFNQuality");

      stat = asn1PD_SFNSFNQuality (pctxt, &pvalue->sFNSFNQuality);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode sFNSFNDriftRate */

   PU_PUSHNAME (pctxt, "sFNSFNDriftRate");

   stat = asn1PD_SFNSFNDriftRate (pctxt, &pvalue->sFNSFNDriftRate);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode sFNSFNDriftRateQuality */

   if (pvalue->m.sFNSFNDriftRateQualityPresent) {
      PU_PUSHNAME (pctxt, "sFNSFNDriftRateQuality");

      stat = asn1PD_SFNSFNDriftRateQuality (pctxt, &pvalue->sFNSFNDriftRateQuality);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode sFNSFNTimeStampInformation */

   PU_PUSHNAME (pctxt, "sFNSFNTimeStampInformation");

   stat = asn1PD_SFNSFNTimeStampInformation (pctxt, &pvalue->sFNSFNTimeStampInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNMeasurementValueInformation_successfullNeighbourin  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation (ASN1CTXT* pctxt, SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(96), 0 };
   int stat = 0;
   SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNMeasurementValueInformation_unsuccessfullNeighbour  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element (ASN1CTXT* pctxt, SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode uC_Id */

   PU_PUSHNAME (pctxt, "uC_Id");

   stat = asn1PD_UC_Id (pctxt, &pvalue->uC_Id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNMeasurementValueInformation_unsuccessfullNeighbour  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation (ASN1CTXT* pctxt, SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(95), 0 };
   int stat = 0;
   SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SFNSFNMeasurementValueInformation                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SFNSFNMeasurementValueInformation (ASN1CTXT* pctxt, SFNSFNMeasurementValueInformation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNMeasurementValueInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation */

   PU_PUSHNAME (pctxt, "successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation");

   stat = asn1PD_SFNSFNMeasurementValueInformation_successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation (pctxt, &pvalue->successfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation */

   PU_PUSHNAME (pctxt, "unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation");

   stat = asn1PD_SFNSFNMeasurementValueInformation_unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation (pctxt, &pvalue->unsuccessfullNeighbouringCellSFNSFNObservedTimeDifferenceMeasurementInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SFNSFNMeasurementValueInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncDLCodeInfoItemLCR                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SyncDLCodeInfoItemLCR (ASN1CTXT* pctxt, SyncDLCodeInfoItemLCR* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncDLCodeInfoItemLCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "syncDLCodeIdArrivTimePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.syncDLCodeIdArrivTimePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "syncDLCodeIdTimingThrePresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.syncDLCodeIdTimingThrePresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode syncDLCodeId */

   PU_PUSHNAME (pctxt, "syncDLCodeId");

   stat = asn1PD_SYNCDlCodeId (pctxt, &pvalue->syncDLCodeId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode syncDLCodeIdArrivTime */

   if (pvalue->m.syncDLCodeIdArrivTimePresent) {
      PU_PUSHNAME (pctxt, "syncDLCodeIdArrivTime");

      stat = asn1PD_CellSyncBurstTimingLCR (pctxt, &pvalue->syncDLCodeIdArrivTime);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode syncDLCodeIdTimingThre */

   if (pvalue->m.syncDLCodeIdTimingThrePresent) {
      PU_PUSHNAME (pctxt, "syncDLCodeIdTimingThre");

      stat = asn1PD_CellSyncBurstTimingThreshold (pctxt, &pvalue->syncDLCodeIdTimingThre);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncDLCodeInfoItemLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncDLCodeInfoListLCR                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SyncDLCodeInfoListLCR (ASN1CTXT* pctxt, SyncDLCodeInfoListLCR* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   SyncDLCodeInfoItemLCR* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncDLCodeInfoListLCR: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SyncDLCodeInfoItemLCR);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SyncDLCodeInfoItemLCR (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncDLCodeInfoListLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncDLCodeIdThreInfoList                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SyncDLCodeIdThreInfoList (ASN1CTXT* pctxt, SyncDLCodeIdThreInfoList* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncDLCodeIdThreInfoList: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode syncFrameNoToReceive */

   PU_PUSHNAME (pctxt, "syncFrameNoToReceive");

   stat = asn1PD_SyncFrameNumber (pctxt, &pvalue->syncFrameNoToReceive);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode syncDLCodeIdInfoLCR */

   PU_PUSHNAME (pctxt, "syncDLCodeIdInfoLCR");

   stat = asn1PD_SyncDLCodeInfoListLCR (pctxt, &pvalue->syncDLCodeIdInfoLCR);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncDLCodeIdThreInfoList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SyncDLCodeIdThreInfoLCR                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_SyncDLCodeIdThreInfoLCR (ASN1CTXT* pctxt, SyncDLCodeIdThreInfoLCR* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(512), 0 };
   int stat = 0;
   SyncDLCodeIdThreInfoList* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncDLCodeIdThreInfoLCR: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SyncDLCodeIdThreInfoList);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_SyncDLCodeIdThreInfoList (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SyncDLCodeIdThreInfoLCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transmission_Gap_Pattern_Sequence_Information_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Transmission_Gap_Pattern_Sequence_Information_element (ASN1CTXT* pctxt, Transmission_Gap_Pattern_Sequence_Information_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Transmission_Gap_Pattern_Sequence_Information_element: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "tGL2Present");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tGL2Present = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "not_to_be_used_1Present");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.not_to_be_used_1Present = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "downlink_Compressed_Mode_MethodPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.downlink_Compressed_Mode_MethodPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "uplink_Compressed_Mode_MethodPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.uplink_Compressed_Mode_MethodPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "delta_SIR2Present");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.delta_SIR2Present = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "delta_SIR_after2Present");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.delta_SIR_after2Present = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode tGPSID */

   PU_PUSHNAME (pctxt, "tGPSID");

   stat = asn1PD_TGPSID (pctxt, &pvalue->tGPSID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tGSN */

   PU_PUSHNAME (pctxt, "tGSN");

   stat = asn1PD_TGSN (pctxt, &pvalue->tGSN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tGL1 */

   PU_PUSHNAME (pctxt, "tGL1");

   stat = asn1PD_GapLength (pctxt, &pvalue->tGL1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tGL2 */

   if (pvalue->m.tGL2Present) {
      PU_PUSHNAME (pctxt, "tGL2");

      stat = asn1PD_GapLength (pctxt, &pvalue->tGL2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tGD */

   PU_PUSHNAME (pctxt, "tGD");

   stat = asn1PD_TGD (pctxt, &pvalue->tGD);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tGPL1 */

   PU_PUSHNAME (pctxt, "tGPL1");

   stat = asn1PD_GapDuration (pctxt, &pvalue->tGPL1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode not_to_be_used_1 */

   if (pvalue->m.not_to_be_used_1Present) {
      PU_PUSHNAME (pctxt, "not_to_be_used_1");

      stat = asn1PD_GapDuration (pctxt, &pvalue->not_to_be_used_1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode uL_DL_mode */

   PU_PUSHNAME (pctxt, "uL_DL_mode");

   stat = asn1PD_UL_DL_mode (pctxt, &pvalue->uL_DL_mode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode downlink_Compressed_Mode_Method */

   if (pvalue->m.downlink_Compressed_Mode_MethodPresent) {
      PU_PUSHNAME (pctxt, "downlink_Compressed_Mode_Method");

      stat = asn1PD_Downlink_Compressed_Mode_Method (pctxt, &pvalue->downlink_Compressed_Mode_Method);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode uplink_Compressed_Mode_Method */

   if (pvalue->m.uplink_Compressed_Mode_MethodPresent) {
      PU_PUSHNAME (pctxt, "uplink_Compressed_Mode_Method");

      stat = asn1PD_Uplink_Compressed_Mode_Method (pctxt, &pvalue->uplink_Compressed_Mode_Method);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode dL_FrameType */

   PU_PUSHNAME (pctxt, "dL_FrameType");

   stat = asn1PD_DL_FrameType (pctxt, &pvalue->dL_FrameType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode delta_SIR1 */

   PU_PUSHNAME (pctxt, "delta_SIR1");

   stat = asn1PD_DeltaSIR (pctxt, &pvalue->delta_SIR1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode delta_SIR_after1 */

   PU_PUSHNAME (pctxt, "delta_SIR_after1");

   stat = asn1PD_DeltaSIR (pctxt, &pvalue->delta_SIR_after1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode delta_SIR2 */

   if (pvalue->m.delta_SIR2Present) {
      PU_PUSHNAME (pctxt, "delta_SIR2");

      stat = asn1PD_DeltaSIR (pctxt, &pvalue->delta_SIR2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode delta_SIR_after2 */

   if (pvalue->m.delta_SIR_after2Present) {
      PU_PUSHNAME (pctxt, "delta_SIR_after2");

      stat = asn1PD_DeltaSIR (pctxt, &pvalue->delta_SIR_after2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Transmission_Gap_Pattern_Sequence_Information_element: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transmission_Gap_Pattern_Sequence_Information             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Transmission_Gap_Pattern_Sequence_Information (ASN1CTXT* pctxt, Transmission_Gap_Pattern_Sequence_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(6), 0 };
   int stat = 0;
   Transmission_Gap_Pattern_Sequence_Information_element* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Transmission_Gap_Pattern_Sequence_Information: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Transmission_Gap_Pattern_Sequence_Information_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Transmission_Gap_Pattern_Sequence_Information_element (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Transmission_Gap_Pattern_Sequence_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue_Item (ASN1CTXT* pctxt, TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cellPortionID */

   PU_PUSHNAME (pctxt, "cellPortionID");

   stat = asn1PD_CellPortionID (pctxt, &pvalue->cellPortionID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode transmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionValue */

   PU_PUSHNAME (pctxt, "transmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionValue");

   stat = asn1PD_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionValue (pctxt, &pvalue->transmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue (ASN1CTXT* pctxt, TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TransmittedCarrierPowerOfAllCodesNotUsedForHS_PDSCHOrHS_SCCHTransmissionCellPortionValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transmitted_Carrier_Power_For_CellPortion_Value_Item      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Transmitted_Carrier_Power_For_CellPortion_Value_Item (ASN1CTXT* pctxt, Transmitted_Carrier_Power_For_CellPortion_Value_Item* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_Transmitted_Carrier_Power_For_CellPortion_Value_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode cellPortionID */

   PU_PUSHNAME (pctxt, "cellPortionID");

   stat = asn1PD_CellPortionID (pctxt, &pvalue->cellPortionID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode transmitted_Carrier_Power_Value */

   PU_PUSHNAME (pctxt, "transmitted_Carrier_Power_Value");

   stat = asn1PD_Transmitted_Carrier_Power_Value (pctxt, &pvalue->transmitted_Carrier_Power_Value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Transmitted_Carrier_Power_For_CellPortion_Value_Item: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transmitted_Carrier_Power_For_CellPortion_Value           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_Transmitted_Carrier_Power_For_CellPortion_Value (ASN1CTXT* pctxt, Transmitted_Carrier_Power_For_CellPortion_Value* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   Transmitted_Carrier_Power_For_CellPortion_Value_Item* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_Transmitted_Carrier_Power_For_CellPortion_Value: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Transmitted_Carrier_Power_For_CellPortion_Value_Item);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_Transmitted_Carrier_Power_For_CellPortion_Value_Item (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Transmitted_Carrier_Power_For_CellPortion_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TUTRANGPS                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TUTRANGPS (ASN1CTXT* pctxt, TUTRANGPS* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TUTRANGPS: start\n");

   /* decode ms_part */

   PU_PUSHNAME (pctxt, "ms_part");

   stat = pd_ConsUInt16 (pctxt, &pvalue->ms_part, OSUINTCONST(0), OSUINTCONST(16383));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode ls_part */

   PU_PUSHNAME (pctxt, "ls_part");

   stat = pd_ConsUnsigned (pctxt, &pvalue->ls_part, OSUINTCONST(0), OSUINT32_MAX);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TUTRANGPS: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TUTRANGPSMeasurementThresholdInformation                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TUTRANGPSMeasurementThresholdInformation (ASN1CTXT* pctxt, TUTRANGPSMeasurementThresholdInformation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TUTRANGPSMeasurementThresholdInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "tUTRANGPSChangeLimitPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tUTRANGPSChangeLimitPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "predictedTUTRANGPSDeviationLimitPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.predictedTUTRANGPSDeviationLimitPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode tUTRANGPSChangeLimit */

   if (pvalue->m.tUTRANGPSChangeLimitPresent) {
      PU_PUSHNAME (pctxt, "tUTRANGPSChangeLimit");

      stat = asn1PD_TUTRANGPSChangeLimit (pctxt, &pvalue->tUTRANGPSChangeLimit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode predictedTUTRANGPSDeviationLimit */

   if (pvalue->m.predictedTUTRANGPSDeviationLimitPresent) {
      PU_PUSHNAME (pctxt, "predictedTUTRANGPSDeviationLimit");

      stat = asn1PD_PredictedTUTRANGPSDeviationLimit (pctxt, &pvalue->predictedTUTRANGPSDeviationLimit);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TUTRANGPSMeasurementThresholdInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TUTRANGPSMeasurementValueInformation                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_TUTRANGPSMeasurementValueInformation (ASN1CTXT* pctxt, TUTRANGPSMeasurementValueInformation* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_TUTRANGPSMeasurementValueInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "tUTRANGPSQualityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tUTRANGPSQualityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tUTRANGPSDriftRateQualityPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tUTRANGPSDriftRateQualityPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode tUTRANGPS */

   PU_PUSHNAME (pctxt, "tUTRANGPS");

   stat = asn1PD_TUTRANGPS (pctxt, &pvalue->tUTRANGPS);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tUTRANGPSQuality */

   if (pvalue->m.tUTRANGPSQualityPresent) {
      PU_PUSHNAME (pctxt, "tUTRANGPSQuality");

      stat = asn1PD_TUTRANGPSQuality (pctxt, &pvalue->tUTRANGPSQuality);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode tUTRANGPSDriftRate */

   PU_PUSHNAME (pctxt, "tUTRANGPSDriftRate");

   stat = asn1PD_TUTRANGPSDriftRate (pctxt, &pvalue->tUTRANGPSDriftRate);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode tUTRANGPSDriftRateQuality */

   if (pvalue->m.tUTRANGPSDriftRateQualityPresent) {
      PU_PUSHNAME (pctxt, "tUTRANGPSDriftRateQuality");

      stat = asn1PD_TUTRANGPSDriftRateQuality (pctxt, &pvalue->tUTRANGPSDriftRateQuality);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TUTRANGPSMeasurementValueInformation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_Synchronisation_Parameters_LCR                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_UL_Synchronisation_Parameters_LCR (ASN1CTXT* pctxt, UL_Synchronisation_Parameters_LCR* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Synchronisation_Parameters_LCR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode uL_Synchronisation_StepSize */

   PU_PUSHNAME (pctxt, "uL_Synchronisation_StepSize");

   stat = asn1PD_UL_Synchronisation_StepSize (pctxt, &pvalue->uL_Synchronisation_StepSize);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode uL_Synchronisation_Frequency */

   PU_PUSHNAME (pctxt, "uL_Synchronisation_Frequency");

   stat = asn1PD_UL_Synchronisation_Frequency (pctxt, &pvalue->uL_Synchronisation_Frequency);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_Synchronisation_Parameters_LCR: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_InformationItem                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_USCH_InformationItem (ASN1CTXT* pctxt, USCH_InformationItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_InformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode uSCH_ID */

   PU_PUSHNAME (pctxt, "uSCH_ID");

   stat = asn1PD_USCH_ID (pctxt, &pvalue->uSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode cCTrCH_ID */

   PU_PUSHNAME (pctxt, "cCTrCH_ID");

   stat = asn1PD_CCTrCH_ID (pctxt, &pvalue->cCTrCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode transportFormatSet */

   PU_PUSHNAME (pctxt, "transportFormatSet");

   stat = asn1PD_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode allocationRetentionPriority */

   PU_PUSHNAME (pctxt, "allocationRetentionPriority");

   stat = asn1PD_AllocationRetentionPriority (pctxt, &pvalue->allocationRetentionPriority);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_InformationItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_Information                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_USCH_Information (ASN1CTXT* pctxt, USCH_Information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   USCH_InformationItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_Information: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, USCH_InformationItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_USCH_InformationItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_Information: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_InformationResponseItem                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_USCH_InformationResponseItem (ASN1CTXT* pctxt, USCH_InformationResponseItem* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit;
   OSBOOL extbit;

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_InformationResponseItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   PU_NEWFIELD (pctxt, "bindingIDPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bindingIDPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transportLayerAddressPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportLayerAddressPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iE_ExtensionsPresent");

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.iE_ExtensionsPresent = optbit;

   PU_SETBITCOUNT (pctxt);

   /* decode uSCH_ID */

   PU_PUSHNAME (pctxt, "uSCH_ID");

   stat = asn1PD_USCH_ID (pctxt, &pvalue->uSCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode bindingID */

   if (pvalue->m.bindingIDPresent) {
      PU_PUSHNAME (pctxt, "bindingID");

      stat = asn1PD_BindingID (pctxt, &pvalue->bindingID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      PU_PUSHNAME (pctxt, "transportLayerAddress");

      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      PU_PUSHNAME (pctxt, "iE_Extensions");

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
   }

   if (extbit) {

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      PU_SETBITCOUNT (pctxt);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      rtPreInitContext (&lctxt);
      stat = pu_initContextBuffer (&lctxt, pctxt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      for (i = 0; i < bitcnt; i++) {
         stat = PD_BIT (&lctxt, &optbit);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         if (optbit) {
            /* set ext elem name for trace */
            switch (i) {
               case 0: PU_PUSHNAME (pctxt, "extElem1"); break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = rtMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_InformationResponseItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_InformationResponse                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_USCH_InformationResponse (ASN1CTXT* pctxt, USCH_InformationResponse* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   USCH_InformationResponseItem* pdata;
   OSUINT32 count = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_InformationResponse: start\n");

   /* decode length determinant */

   PU_PUSHNAME (pctxt, "count");

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   PU_POPNAME (pctxt);

   /* decode elements */

   rtDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PU_PUSHELEMNAME (pctxt, xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, USCH_InformationResponseItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_USCH_InformationResponseItem (pctxt, pdata);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      PU_POPNAME (pctxt);
      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_USCH_InformationResponse: end\n");

   return (stat);
}

