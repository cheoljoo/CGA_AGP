/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.83, Date: 05-Feb-2007.
 */
#include "asn1intl.h"
#include "MEDIA-GATEWAY-CONTROL.h"

/**************************************************************/
/*                                                            */
/*  SecurityParmIndex                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SecurityParmIndex (ASN1CTXT* pctxt,
   SecurityParmIndex *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_SecurityParmIndex: start\n");

   pvalue->numocts = 4;
   stat = xd_octstr_s (pctxt, pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!(pvalue->numocts == 4)) {
      rtErrAddStrParm (&pctxt->errInfo, "SecurityParmIndex.numocts");
      rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->numocts);
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_SecurityParmIndex: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SequenceNum                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SequenceNum (ASN1CTXT* pctxt,
   SequenceNum *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_SequenceNum: start\n");

   pvalue->numocts = 4;
   stat = xd_octstr_s (pctxt, pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!(pvalue->numocts == 4)) {
      rtErrAddStrParm (&pctxt->errInfo, "SequenceNum.numocts");
      rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->numocts);
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_SequenceNum: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuthData                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AuthData (ASN1CTXT* pctxt,
   AuthData *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_AuthData: start\n");

   pvalue->numocts = 32;
   stat = xd_octstr_s (pctxt, pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!((pvalue->numocts >= 12 && pvalue->numocts <= 32))) {
      rtErrAddStrParm (&pctxt->errInfo, "AuthData.numocts");
      rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->numocts);
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_AuthData: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PathName                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PathName (ASN1CTXT* pctxt,
   PathName *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_PathName: start\n");

   stat = xd_charstr (pctxt,
      pvalue,
      tagging, (TM_UNIV|TM_PRIM|22), length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   { size_t nchars = strlen (*pvalue);
   if (!((nchars >= 1 && nchars <= 64))) {
      rtErrAddStrParm (&pctxt->errInfo, "PathName");
      rtErrAddIntParm (&pctxt->errInfo, (int)nchars);
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
   }

   }
   RTDIAGSTRM2 (pctxt,"asn1D_PathName: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransactionId                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TransactionId (ASN1CTXT* pctxt,
   TransactionId *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_TransactionId: start\n");

   stat = xd_unsigned (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_TransactionId: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorCode                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ErrorCode (ASN1CTXT* pctxt,
   ErrorCode *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_ErrorCode: start\n");

   stat = xd_uint16 (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_ErrorCode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorText                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ErrorText (ASN1CTXT* pctxt,
   ErrorText *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_ErrorText: start\n");

   stat = xd_charstr (pctxt,
      pvalue,
      tagging, (TM_UNIV|TM_PRIM|22), length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_ErrorText: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ContextID                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ContextID (ASN1CTXT* pctxt,
   ContextID *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_ContextID: start\n");

   stat = xd_unsigned (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_ContextID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PkgdName                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PkgdName (ASN1CTXT* pctxt,
   PkgdName *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_PkgdName: start\n");

   pvalue->numocts = 4;
   stat = xd_octstr_s (pctxt, pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!(pvalue->numocts == 4)) {
      rtErrAddStrParm (&pctxt->errInfo, "PkgdName.numocts");
      rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->numocts);
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_PkgdName: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EventName                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_EventName (ASN1CTXT* pctxt,
   EventName *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_EventName: start\n");

   stat = asn1D_PkgdName (pctxt, 
      pvalue, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_EventName: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  WildcardField                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_WildcardField (ASN1CTXT* pctxt,
   WildcardField *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_WildcardField: start\n");

   pvalue->numocts = 1;
   stat = xd_octstr_s (pctxt, pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!(pvalue->numocts == 1)) {
      rtErrAddStrParm (&pctxt->errInfo, "WildcardField.numocts");
      rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->numocts);
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_WildcardField: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StreamMode                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_StreamMode (ASN1CTXT* pctxt,
   StreamMode *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_StreamMode: start\n");

   stat = xd_enum (pctxt, (ASN1ENUM*)pvalue, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_StreamMode: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Name                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Name (ASN1CTXT* pctxt,
   Name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_Name: start\n");

   pvalue->numocts = 2;
   stat = xd_octstr_s (pctxt, pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!(pvalue->numocts == 2)) {
      rtErrAddStrParm (&pctxt->errInfo, "Name.numocts");
      rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->numocts);
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_Name: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Relation                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Relation (ASN1CTXT* pctxt,
   Relation *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_Relation: start\n");

   stat = xd_enum (pctxt, (ASN1ENUM*)pvalue, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_Relation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EventBufferControl                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_EventBufferControl (ASN1CTXT* pctxt,
   EventBufferControl *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_EventBufferControl: start\n");

   stat = xd_enum (pctxt, (ASN1ENUM*)pvalue, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_EventBufferControl: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceState                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ServiceState (ASN1CTXT* pctxt,
   ServiceState *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_ServiceState: start\n");

   stat = xd_enum (pctxt, (ASN1ENUM*)pvalue, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_ServiceState: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MuxType                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MuxType (ASN1CTXT* pctxt,
   MuxType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_MuxType: start\n");

   stat = xd_enum (pctxt, (ASN1ENUM*)pvalue, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_MuxType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StreamID                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_StreamID (ASN1CTXT* pctxt,
   StreamID *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_StreamID: start\n");

   stat = xd_uint16 (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_StreamID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignalType                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SignalType (ASN1CTXT* pctxt,
   SignalType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_SignalType: start\n");

   stat = xd_enum (pctxt, (ASN1ENUM*)pvalue, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_SignalType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignalName                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SignalName (ASN1CTXT* pctxt,
   SignalName *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_SignalName: start\n");

   stat = asn1D_PkgdName (pctxt, 
      pvalue, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_SignalName: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotifyCompletion                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_NotifyCompletion (ASN1CTXT* pctxt,
   NotifyCompletion *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_NotifyCompletion: start\n");

   pvalue->numbits = 4;
   stat = xd_bitstr_s (pctxt, pvalue->data, &pvalue->numbits, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_NotifyCompletion: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestID                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_RequestID (ASN1CTXT* pctxt,
   RequestID *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_RequestID: start\n");

   stat = xd_unsigned (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_RequestID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ModemType                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ModemType (ASN1CTXT* pctxt,
   ModemType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_ModemType: start\n");

   stat = xd_enum (pctxt, (ASN1ENUM*)pvalue, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_ModemType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DigitMapName                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_DigitMapName (ASN1CTXT* pctxt,
   DigitMapName *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_DigitMapName: start\n");

   stat = asn1D_Name (pctxt, 
      pvalue, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_DigitMapName: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceChangeMethod                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ServiceChangeMethod (ASN1CTXT* pctxt,
   ServiceChangeMethod *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_ServiceChangeMethod: start\n");

   stat = xd_enum (pctxt, (ASN1ENUM*)pvalue, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_ServiceChangeMethod: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MId_mtpAddress                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MId_mtpAddress (ASN1CTXT* pctxt,
   MId_mtpAddress *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_MId_mtpAddress: start\n");

   pvalue->numocts = 4;
   stat = xd_octstr_s (pctxt, pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!((pvalue->numocts >= 2 && pvalue->numocts <= 4))) {
      rtErrAddStrParm (&pctxt->errInfo, "MId_mtpAddress.numocts");
      rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->numocts);
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_MId_mtpAddress: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IP4Address_address                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_IP4Address_address (ASN1CTXT* pctxt,
   IP4Address_address *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_IP4Address_address: start\n");

   pvalue->numocts = 4;
   stat = xd_octstr_s (pctxt, pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!(pvalue->numocts == 4)) {
      rtErrAddStrParm (&pctxt->errInfo, "IP4Address_address.numocts");
      rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->numocts);
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_IP4Address_address: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IP6Address_address                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_IP6Address_address (ASN1CTXT* pctxt,
   IP6Address_address *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_IP6Address_address: start\n");

   pvalue->numocts = 16;
   stat = xd_octstr_s (pctxt, pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!(pvalue->numocts == 16)) {
      rtErrAddStrParm (&pctxt->errInfo, "IP6Address_address.numocts");
      rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->numocts);
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_IP6Address_address: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TopologyRequest_topologyDirection                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TopologyRequest_topologyDirection (ASN1CTXT* pctxt,
   TopologyRequest_topologyDirection *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_TopologyRequest_topologyDirection: start\n");

   stat = xd_enum (pctxt, (ASN1ENUM*)pvalue, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);

   RTDIAGSTRM2 (pctxt,"asn1D_TopologyRequest_topologyDirection: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuditDescriptor_auditToken                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AuditDescriptor_auditToken (ASN1CTXT* pctxt,
   AuditDescriptor_auditToken *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_AuditDescriptor_auditToken: start\n");

   pvalue->numbits = 10;
   stat = xd_bitstr_s (pctxt, pvalue->data, &pvalue->numbits, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1D_AuditDescriptor_auditToken: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminationID_id                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TerminationID_id (ASN1CTXT* pctxt,
   TerminationID_id *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_TerminationID_id: start\n");

   pvalue->numocts = 8;
   stat = xd_octstr_s (pctxt, pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!((pvalue->numocts >= 1 && pvalue->numocts <= 8))) {
      rtErrAddStrParm (&pctxt->errInfo, "TerminationID_id.numocts");
      rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->numocts);
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_TerminationID_id: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceChangeAddress_mtpAddress                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ServiceChangeAddress_mtpAddress (ASN1CTXT* pctxt,
   ServiceChangeAddress_mtpAddress *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1D_ServiceChangeAddress_mtpAddress: start\n");

   pvalue->numocts = 4;
   stat = xd_octstr_s (pctxt, pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!((pvalue->numocts >= 2 && pvalue->numocts <= 4))) {
      rtErrAddStrParm (&pctxt->errInfo, "ServiceChangeAddress_mtpAddress.numocts");
      rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->numocts);
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_ServiceChangeAddress_mtpAddress: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuthenticationHeader                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AuthenticationHeader (ASN1CTXT* pctxt,
   AuthenticationHeader *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_AuthenticationHeader: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode secParmIndex */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_SecurityParmIndex (pctxt, 
               &pvalue->secParmIndex, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode seqNum */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_SequenceNum (pctxt, 
               &pvalue->seqNum, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode ad */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_AuthData (pctxt, 
               &pvalue->ad, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_AuthenticationHeader: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IP4Address                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_IP4Address (ASN1CTXT* pctxt,
   IP4Address *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_IP4Address: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode address */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_IP4Address_address (pctxt, 
               &pvalue->address, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode portNumber */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_uint16 (pctxt, &pvalue->portNumber, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.portNumberPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_IP4Address: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IP6Address                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_IP6Address (ASN1CTXT* pctxt,
   IP6Address *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_IP6Address: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode address */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_IP6Address_address (pctxt, 
               &pvalue->address, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode portNumber */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_uint16 (pctxt, &pvalue->portNumber, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.portNumberPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_IP6Address: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DomainName                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_DomainName (ASN1CTXT* pctxt,
   DomainName *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_DomainName: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_charstr (pctxt,
               &pvalue->name,
               ASN1IMPL, (TM_UNIV|TM_PRIM|22), length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode portNumber */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_uint16 (pctxt, &pvalue->portNumber, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.portNumberPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_DomainName: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MId                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MId (ASN1CTXT* pctxt,
   MId *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_MId: start\n");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.ip4Address = rtMemAllocTypeZ (pctxt, IP4Address);
         if (pvalue->u.ip4Address== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_IP4Address (pctxt, 
            pvalue->u.ip4Address, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.ip6Address = rtMemAllocTypeZ (pctxt, IP6Address);
         if (pvalue->u.ip6Address== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_IP6Address (pctxt, 
            pvalue->u.ip6Address, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.domainName = rtMemAllocTypeZ (pctxt, DomainName);
         if (pvalue->u.domainName== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_DomainName (pctxt, 
            pvalue->u.domainName, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_PRIM|3):
      case (TM_CTXT|TM_CONS|3):
         stat = asn1D_PathName (pctxt, 
            &pvalue->u.deviceName, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 4;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|4):
      case (TM_CTXT|TM_CONS|4):
         pvalue->u.mtpAddress = rtMemAllocTypeZ (pctxt, MId_mtpAddress);
         if (pvalue->u.mtpAddress== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_MId_mtpAddress (pctxt, 
            pvalue->u.mtpAddress, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 5;
         ccb.len = 0;
         break;

      default:
         ASN1BUF_RESTORE (pctxt);
         pvalue->u.extElem1 = rtMemAllocTypeZ (pctxt, ASN1OpenType);
         if (pvalue->u.extElem1== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = xd_OpenType (pctxt, &pvalue->u.extElem1->data, &pvalue->u.extElem1->numocts);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         pvalue->t = 6;
         ccb.len = 0;
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_MId: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorDescriptor                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ErrorDescriptor (ASN1CTXT* pctxt,
   ErrorDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_ErrorDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode errorCode */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ErrorCode (pctxt, 
               &pvalue->errorCode, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode errorText */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ErrorText (pctxt, 
               &pvalue->errorText, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.errorTextPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_ErrorDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfWildcardField                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfWildcardField (ASN1CTXT* pctxt,
   _SeqOfWildcardField *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int count;
   int xx1;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfWildcardField: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   stat = xd_count (pctxt, length, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   pvalue->n = count;
   ALLOC_ASN1ARRAY (pctxt, pvalue, WildcardField);

   xx1 = 0;
   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      stat = asn1D_WildcardField (pctxt, 
         &pvalue->elem[xx1], ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      xx1++;
   }
   pvalue->n = xx1;

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfWildcardField: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminationID                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TerminationID (ASN1CTXT* pctxt,
   TerminationID *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_TerminationID: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode wildcard */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfWildcardField (pctxt, 
               &pvalue->wildcard, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TerminationID_id (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_TerminationID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TopologyRequest                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TopologyRequest (ASN1CTXT* pctxt,
   TopologyRequest *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_TopologyRequest: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode terminationFrom */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TerminationID (pctxt, 
               &pvalue->terminationFrom, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode terminationTo */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TerminationID (pctxt, 
               &pvalue->terminationTo, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode topologyDirection */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TopologyRequest_topologyDirection (pctxt, 
               &pvalue->topologyDirection, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_TopologyRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfTopologyRequest                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfTopologyRequest (ASN1CTXT* pctxt,
   _SeqOfTopologyRequest *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   TopologyRequest* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfTopologyRequest: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TopologyRequest);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_TopologyRequest (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfTopologyRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ContextRequest                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ContextRequest (ASN1CTXT* pctxt,
   ContextRequest *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_ContextRequest: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode priority */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_uint8 (pctxt, &pvalue->priority, ASN1IMPL, length);
            if (stat == 0) {
               if (!((pvalue->priority <= 15))) {
                  rtErrAddStrParm (&pctxt->errInfo, "ContextRequest.priority");
                  rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->priority);
                  return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
               }

               pvalue->m.priorityPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode emergency */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->emergency, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.emergencyPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode topologyReq */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfTopologyRequest (pctxt, 
               &pvalue->topologyReq, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.topologyReqPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_ContextRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ContextAttrAuditRequest                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ContextAttrAuditRequest (ASN1CTXT* pctxt,
   ContextAttrAuditRequest *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_ContextAttrAuditRequest: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode topology */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_null (pctxt, ASN1IMPL);
            if (stat == 0) {
               pvalue->m.topologyPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode emergency */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_null (pctxt, ASN1IMPL);
            if (stat == 0) {
               pvalue->m.emergencyPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode priority */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_null (pctxt, ASN1IMPL);
            if (stat == 0) {
               pvalue->m.priorityPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_ContextAttrAuditRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminationIDList                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TerminationIDList (ASN1CTXT* pctxt,
   TerminationIDList *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   TerminationID* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_TerminationIDList: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TerminationID);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_TerminationID (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_TerminationIDList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PropertyParm_value                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PropertyParm_value (ASN1CTXT* pctxt,
   PropertyParm_value *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int count;
   int xx1;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_PropertyParm_value: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   stat = xd_count (pctxt, length, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   pvalue->n = count;
   ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1DynOctStr);

   xx1 = 0;
   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      stat = xd_octstr (pctxt, &pvalue->elem[xx1].data, &pvalue->elem[xx1].numocts, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      xx1++;
   }
   pvalue->n = xx1;

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_PropertyParm_value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PropertyParm_extraInfo                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PropertyParm_extraInfo (ASN1CTXT* pctxt,
   PropertyParm_extraInfo *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_PropertyParm_extraInfo: start\n");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
         stat = asn1D_Relation (pctxt, 
            &pvalue->u.relation, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = xd_boolean (pctxt, &pvalue->u.range, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_PRIM|2):
         stat = xd_boolean (pctxt, &pvalue->u.sublist, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_PropertyParm_extraInfo: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PropertyParm                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PropertyParm (ASN1CTXT* pctxt,
   PropertyParm *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_PropertyParm: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_PkgdName (pctxt, 
               &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_PropertyParm_value (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode extraInfo */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_PropertyParm_extraInfo (pctxt, 
               &pvalue->extraInfo, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extraInfoPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_PropertyParm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfPropertyParm                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfPropertyParm (ASN1CTXT* pctxt,
   _SeqOfPropertyParm *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   PropertyParm* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfPropertyParm: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PropertyParm);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_PropertyParm (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfPropertyParm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminationStateDescriptor                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TerminationStateDescriptor (ASN1CTXT* pctxt,
   TerminationStateDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_TerminationStateDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode propertyParms */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfPropertyParm (pctxt, 
               &pvalue->propertyParms, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode eventBufferControl */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_EventBufferControl (pctxt, 
               &pvalue->eventBufferControl, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.eventBufferControlPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode serviceState */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ServiceState (pctxt, 
               &pvalue->serviceState, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.serviceStatePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_TerminationStateDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocalControlDescriptor                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_LocalControlDescriptor (ASN1CTXT* pctxt,
   LocalControlDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_LocalControlDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode streamMode */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_StreamMode (pctxt, 
               &pvalue->streamMode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.streamModePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode reserveValue */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->reserveValue, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.reserveValuePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode reserveGroup */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->reserveGroup, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.reserveGroupPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode propertyParms */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfPropertyParm (pctxt, 
               &pvalue->propertyParms, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_LocalControlDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PropertyGroup                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PropertyGroup (ASN1CTXT* pctxt,
   PropertyGroup *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   PropertyParm* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_PropertyGroup: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PropertyParm);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_PropertyParm (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_PropertyGroup: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfPropertyGroup                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfPropertyGroup (ASN1CTXT* pctxt,
   _SeqOfPropertyGroup *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   PropertyGroup* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfPropertyGroup: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PropertyGroup);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_PropertyGroup (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfPropertyGroup: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocalRemoteDescriptor                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_LocalRemoteDescriptor (ASN1CTXT* pctxt,
   LocalRemoteDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_LocalRemoteDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode propGrps */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfPropertyGroup (pctxt, 
               &pvalue->propGrps, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_LocalRemoteDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StreamParms                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_StreamParms (ASN1CTXT* pctxt,
   StreamParms *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_StreamParms: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode localControlDescriptor */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_LocalControlDescriptor (pctxt, 
               &pvalue->localControlDescriptor, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.localControlDescriptorPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode localDescriptor */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_LocalRemoteDescriptor (pctxt, 
               &pvalue->localDescriptor, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.localDescriptorPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode remoteDescriptor */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_LocalRemoteDescriptor (pctxt, 
               &pvalue->remoteDescriptor, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.remoteDescriptorPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_StreamParms: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StreamDescriptor                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_StreamDescriptor (ASN1CTXT* pctxt,
   StreamDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_StreamDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode streamID */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_StreamID (pctxt, 
               &pvalue->streamID, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode streamParms */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_StreamParms (pctxt, 
               &pvalue->streamParms, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_StreamDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfStreamDescriptor                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfStreamDescriptor (ASN1CTXT* pctxt,
   _SeqOfStreamDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   StreamDescriptor* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfStreamDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, StreamDescriptor);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_StreamDescriptor (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfStreamDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MediaDescriptor_streams                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MediaDescriptor_streams (ASN1CTXT* pctxt,
   MediaDescriptor_streams *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_MediaDescriptor_streams: start\n");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.oneStream = rtMemAllocTypeZ (pctxt, StreamParms);
         if (pvalue->u.oneStream== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_StreamParms (pctxt, 
            pvalue->u.oneStream, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.multiStream = rtMemAllocTypeZ (pctxt, _SeqOfStreamDescriptor);
         if (pvalue->u.multiStream== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D__SeqOfStreamDescriptor (pctxt, 
            pvalue->u.multiStream, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_MediaDescriptor_streams: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MediaDescriptor                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MediaDescriptor (ASN1CTXT* pctxt,
   MediaDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_MediaDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode termStateDescr */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TerminationStateDescriptor (pctxt, 
               &pvalue->termStateDescr, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.termStateDescrPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode streams */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_MediaDescriptor_streams (pctxt, 
               &pvalue->streams, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.streamsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_MediaDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfModemType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfModemType (ASN1CTXT* pctxt,
   _SeqOfModemType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int count;
   int xx1;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfModemType: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   stat = xd_count (pctxt, length, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   pvalue->n = count;
   ALLOC_ASN1ARRAY (pctxt, pvalue, ModemType);

   xx1 = 0;
   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      stat = asn1D_ModemType (pctxt, 
         &pvalue->elem[xx1], ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      xx1++;
   }
   pvalue->n = xx1;

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfModemType: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H221NonStandard                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_H221NonStandard (ASN1CTXT* pctxt,
   H221NonStandard *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_H221NonStandard: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode t35CountryCode1 */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_uint8 (pctxt, &pvalue->t35CountryCode1, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode t35CountryCode2 */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_uint8 (pctxt, &pvalue->t35CountryCode2, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode t35Extension */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_uint8 (pctxt, &pvalue->t35Extension, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode manufacturerCode */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_uint16 (pctxt, &pvalue->manufacturerCode, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_H221NonStandard: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NonStandardIdentifier                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_NonStandardIdentifier (ASN1CTXT* pctxt,
   NonStandardIdentifier *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_NonStandardIdentifier: start\n");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
         pvalue->u.object = rtMemAllocTypeZ (pctxt, ASN1OBJID);
         if (pvalue->u.object== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = xd_objid (pctxt, pvalue->u.object, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.h221NonStandard = rtMemAllocTypeZ (pctxt, H221NonStandard);
         if (pvalue->u.h221NonStandard== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_H221NonStandard (pctxt, 
            pvalue->u.h221NonStandard, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_PRIM|2):
      case (TM_CTXT|TM_CONS|2):
         stat = xd_charstr (pctxt,
            &pvalue->u.experimental,
            ASN1IMPL, (TM_UNIV|TM_PRIM|22), length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         { size_t nchars = strlen (pvalue->u.experimental);
         if (!(nchars == 8)) {
            rtErrAddStrParm (&pctxt->errInfo, "NonStandardIdentifier.u.experimental");
            rtErrAddIntParm (&pctxt->errInfo, (int)nchars);
            return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
         }

         }
         pvalue->t = 3;
         ccb.len = 0;
         break;

      default:
         ASN1BUF_RESTORE (pctxt);
         pvalue->u.extElem1 = rtMemAllocTypeZ (pctxt, ASN1OpenType);
         if (pvalue->u.extElem1== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = xd_OpenType (pctxt, &pvalue->u.extElem1->data, &pvalue->u.extElem1->numocts);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         pvalue->t = 4;
         ccb.len = 0;
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_NonStandardIdentifier: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NonStandardData                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_NonStandardData (ASN1CTXT* pctxt,
   NonStandardData *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_NonStandardData: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode nonStandardIdentifier */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_NonStandardIdentifier (pctxt, 
               &pvalue->nonStandardIdentifier, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode data */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_octstr (pctxt, &pvalue->data.data, &pvalue->data.numocts, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_NonStandardData: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ModemDescriptor                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ModemDescriptor (ASN1CTXT* pctxt,
   ModemDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_ModemDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode mtl */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfModemType (pctxt, 
               &pvalue->mtl, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode mpl */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfPropertyParm (pctxt, 
               &pvalue->mpl, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode nonStandardData */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_NonStandardData (pctxt, 
               &pvalue->nonStandardData, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.nonStandardDataPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_ModemDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfTerminationID                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfTerminationID (ASN1CTXT* pctxt,
   _SeqOfTerminationID *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   TerminationID* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfTerminationID: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TerminationID);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_TerminationID (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfTerminationID: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MuxDescriptor                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MuxDescriptor (ASN1CTXT* pctxt,
   MuxDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_MuxDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode muxType */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_MuxType (pctxt, 
               &pvalue->muxType, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode termList */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfTerminationID (pctxt, 
               &pvalue->termList, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode nonStandardData */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_NonStandardData (pctxt, 
               &pvalue->nonStandardData, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.nonStandardDataPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_MuxDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DigitMapValue                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_DigitMapValue (ASN1CTXT* pctxt,
   DigitMapValue *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_DigitMapValue: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode startTimer */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_uint8 (pctxt, &pvalue->startTimer, ASN1IMPL, length);
            if (stat == 0) {
               if (!((pvalue->startTimer <= 99))) {
                  rtErrAddStrParm (&pctxt->errInfo, "DigitMapValue.startTimer");
                  rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->startTimer);
                  return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
               }

               pvalue->m.startTimerPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode shortTimer */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_uint8 (pctxt, &pvalue->shortTimer, ASN1IMPL, length);
            if (stat == 0) {
               if (!((pvalue->shortTimer <= 99))) {
                  rtErrAddStrParm (&pctxt->errInfo, "DigitMapValue.shortTimer");
                  rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->shortTimer);
                  return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
               }

               pvalue->m.shortTimerPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode longTimer */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_uint8 (pctxt, &pvalue->longTimer, ASN1IMPL, length);
            if (stat == 0) {
               if (!((pvalue->longTimer <= 99))) {
                  rtErrAddStrParm (&pctxt->errInfo, "DigitMapValue.longTimer");
                  rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->longTimer);
                  return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
               }

               pvalue->m.longTimerPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode digitMapBody */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_charstr (pctxt,
               &pvalue->digitMapBody,
               ASN1IMPL, (TM_UNIV|TM_PRIM|22), length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_DigitMapValue: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EventDM                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_EventDM (ASN1CTXT* pctxt,
   EventDM *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_EventDM: start\n");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.digitMapName = rtMemAllocTypeZ (pctxt, DigitMapName);
         if (pvalue->u.digitMapName== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_DigitMapName (pctxt, 
            pvalue->u.digitMapName, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.digitMapValue = rtMemAllocTypeZ (pctxt, DigitMapValue);
         if (pvalue->u.digitMapValue== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_DigitMapValue (pctxt, 
            pvalue->u.digitMapValue, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_EventDM: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Value                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Value (ASN1CTXT* pctxt,
   Value *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int count;
   int xx1;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_Value: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   stat = xd_count (pctxt, length, &count);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   pvalue->n = count;
   ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1DynOctStr);

   xx1 = 0;
   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      stat = xd_octstr (pctxt, &pvalue->elem[xx1].data, &pvalue->elem[xx1].numocts, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      xx1++;
   }
   pvalue->n = xx1;

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_Value: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SigParameter_extraInfo                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SigParameter_extraInfo (ASN1CTXT* pctxt,
   SigParameter_extraInfo *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_SigParameter_extraInfo: start\n");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
         stat = asn1D_Relation (pctxt, 
            &pvalue->u.relation, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = xd_boolean (pctxt, &pvalue->u.range, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_PRIM|2):
         stat = xd_boolean (pctxt, &pvalue->u.sublist, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_SigParameter_extraInfo: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SigParameter                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SigParameter (ASN1CTXT* pctxt,
   SigParameter *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_SigParameter: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode sigParameterName */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_Name (pctxt, 
               &pvalue->sigParameterName, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_Value (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode extraInfo */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_SigParameter_extraInfo (pctxt, 
               &pvalue->extraInfo, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extraInfoPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_SigParameter: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfSigParameter                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfSigParameter (ASN1CTXT* pctxt,
   _SeqOfSigParameter *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   SigParameter* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfSigParameter: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SigParameter);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_SigParameter (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfSigParameter: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Signal                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Signal (ASN1CTXT* pctxt,
   Signal *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_Signal: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode signalName */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_SignalName (pctxt, 
               &pvalue->signalName, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode streamID */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_StreamID (pctxt, 
               &pvalue->streamID, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.streamIDPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode sigType */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_SignalType (pctxt, 
               &pvalue->sigType, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sigTypePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode duration */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_uint16 (pctxt, &pvalue->duration, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.durationPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode notifyCompletion */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_NotifyCompletion (pctxt, 
               &pvalue->notifyCompletion, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.notifyCompletionPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode keepActive */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->keepActive, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.keepActivePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode sigParList */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfSigParameter (pctxt, 
               &pvalue->sigParList, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|6):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_Signal: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfSignal                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfSignal (ASN1CTXT* pctxt,
   _SeqOfSignal *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   Signal* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfSignal: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Signal);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_Signal (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfSignal: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SeqSigList                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SeqSigList (ASN1CTXT* pctxt,
   SeqSigList *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_SeqSigList: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_uint16 (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode signalList */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfSignal (pctxt, 
               &pvalue->signalList, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_SeqSigList: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignalRequest                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SignalRequest (ASN1CTXT* pctxt,
   SignalRequest *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_SignalRequest: start\n");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.signal = rtMemAllocTypeZ (pctxt, Signal);
         if (pvalue->u.signal== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_Signal (pctxt, 
            pvalue->u.signal, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.seqSigList = rtMemAllocTypeZ (pctxt, SeqSigList);
         if (pvalue->u.seqSigList== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_SeqSigList (pctxt, 
            pvalue->u.seqSigList, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         ASN1BUF_RESTORE (pctxt);
         pvalue->u.extElem1 = rtMemAllocTypeZ (pctxt, ASN1OpenType);
         if (pvalue->u.extElem1== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = xd_OpenType (pctxt, &pvalue->u.extElem1->data, &pvalue->u.extElem1->numocts);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         pvalue->t = 3;
         ccb.len = 0;
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_SignalRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignalsDescriptor                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SignalsDescriptor (ASN1CTXT* pctxt,
   SignalsDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   SignalRequest* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_SignalsDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SignalRequest);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_SignalRequest (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_SignalsDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecondRequestedActions                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SecondRequestedActions (ASN1CTXT* pctxt,
   SecondRequestedActions *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_SecondRequestedActions: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode keepActive */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->keepActive, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.keepActivePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode eventDM */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_EventDM (pctxt, 
               &pvalue->eventDM, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.eventDMPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode signalsDescriptor */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_SignalsDescriptor (pctxt, 
               &pvalue->signalsDescriptor, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.signalsDescriptorPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_SecondRequestedActions: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EventParameter_extraInfo                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_EventParameter_extraInfo (ASN1CTXT* pctxt,
   EventParameter_extraInfo *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_EventParameter_extraInfo: start\n");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
         stat = asn1D_Relation (pctxt, 
            &pvalue->u.relation, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = xd_boolean (pctxt, &pvalue->u.range, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_PRIM|2):
         stat = xd_boolean (pctxt, &pvalue->u.sublist, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_EventParameter_extraInfo: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EventParameter                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_EventParameter (ASN1CTXT* pctxt,
   EventParameter *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_EventParameter: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode eventParameterName */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_Name (pctxt, 
               &pvalue->eventParameterName, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_Value (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode extraInfo */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_EventParameter_extraInfo (pctxt, 
               &pvalue->extraInfo, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extraInfoPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_EventParameter: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfEventParameter                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfEventParameter (ASN1CTXT* pctxt,
   _SeqOfEventParameter *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   EventParameter* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfEventParameter: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, EventParameter);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_EventParameter (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfEventParameter: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecondRequestedEvent                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SecondRequestedEvent (ASN1CTXT* pctxt,
   SecondRequestedEvent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_SecondRequestedEvent: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode pkgdName */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_PkgdName (pctxt, 
               &pvalue->pkgdName, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode streamID */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_StreamID (pctxt, 
               &pvalue->streamID, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.streamIDPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode eventAction */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_SecondRequestedActions (pctxt, 
               &pvalue->eventAction, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.eventActionPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode evParList */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfEventParameter (pctxt, 
               &pvalue->evParList, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_SecondRequestedEvent: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfSecondRequestedEvent                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfSecondRequestedEvent (ASN1CTXT* pctxt,
   _SeqOfSecondRequestedEvent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   SecondRequestedEvent* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfSecondRequestedEvent: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, SecondRequestedEvent);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_SecondRequestedEvent (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfSecondRequestedEvent: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecondEventsDescriptor                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SecondEventsDescriptor (ASN1CTXT* pctxt,
   SecondEventsDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_SecondEventsDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode requestID */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_RequestID (pctxt, 
               &pvalue->requestID, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.requestIDPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode eventList */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfSecondRequestedEvent (pctxt, 
               &pvalue->eventList, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_SecondEventsDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestedActions                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_RequestedActions (ASN1CTXT* pctxt,
   RequestedActions *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_RequestedActions: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode keepActive */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->keepActive, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.keepActivePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode eventDM */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_EventDM (pctxt, 
               &pvalue->eventDM, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.eventDMPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode secondEvent */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_SecondEventsDescriptor (pctxt, 
               &pvalue->secondEvent, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.secondEventPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode signalsDescriptor */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_SignalsDescriptor (pctxt, 
               &pvalue->signalsDescriptor, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.signalsDescriptorPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_RequestedActions: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestedEvent                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_RequestedEvent (ASN1CTXT* pctxt,
   RequestedEvent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_RequestedEvent: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode pkgdName */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_PkgdName (pctxt, 
               &pvalue->pkgdName, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode streamID */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_StreamID (pctxt, 
               &pvalue->streamID, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.streamIDPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode eventAction */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_RequestedActions (pctxt, 
               &pvalue->eventAction, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.eventActionPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode evParList */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfEventParameter (pctxt, 
               &pvalue->evParList, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_RequestedEvent: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfRequestedEvent                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfRequestedEvent (ASN1CTXT* pctxt,
   _SeqOfRequestedEvent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   RequestedEvent* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfRequestedEvent: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, RequestedEvent);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_RequestedEvent (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfRequestedEvent: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EventsDescriptor                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_EventsDescriptor (ASN1CTXT* pctxt,
   EventsDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_EventsDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode requestID */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_RequestID (pctxt, 
               &pvalue->requestID, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.requestIDPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode eventList */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfRequestedEvent (pctxt, 
               &pvalue->eventList, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_EventsDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EventSpec                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_EventSpec (ASN1CTXT* pctxt,
   EventSpec *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_EventSpec: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode eventName */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_EventName (pctxt, 
               &pvalue->eventName, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode streamID */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_StreamID (pctxt, 
               &pvalue->streamID, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.streamIDPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode eventParList */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfEventParameter (pctxt, 
               &pvalue->eventParList, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_EventSpec: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EventBufferDescriptor                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_EventBufferDescriptor (ASN1CTXT* pctxt,
   EventBufferDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   EventSpec* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_EventBufferDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, EventSpec);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_EventSpec (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_EventBufferDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DigitMapDescriptor                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_DigitMapDescriptor (ASN1CTXT* pctxt,
   DigitMapDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_DigitMapDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode digitMapName */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_DigitMapName (pctxt, 
               &pvalue->digitMapName, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.digitMapNamePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode digitMapValue */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_DigitMapValue (pctxt, 
               &pvalue->digitMapValue, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.digitMapValuePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_DigitMapDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuditDescriptor                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AuditDescriptor (ASN1CTXT* pctxt,
   AuditDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_AuditDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode auditToken */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_AuditDescriptor_auditToken (pctxt, 
               &pvalue->auditToken, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.auditTokenPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_AuditDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AmmDescriptor                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AmmDescriptor (ASN1CTXT* pctxt,
   AmmDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_AmmDescriptor: start\n");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.mediaDescriptor = rtMemAllocTypeZ (pctxt, MediaDescriptor);
         if (pvalue->u.mediaDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_MediaDescriptor (pctxt, 
            pvalue->u.mediaDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.modemDescriptor = rtMemAllocTypeZ (pctxt, ModemDescriptor);
         if (pvalue->u.modemDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_ModemDescriptor (pctxt, 
            pvalue->u.modemDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.muxDescriptor = rtMemAllocTypeZ (pctxt, MuxDescriptor);
         if (pvalue->u.muxDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_MuxDescriptor (pctxt, 
            pvalue->u.muxDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.eventsDescriptor = rtMemAllocTypeZ (pctxt, EventsDescriptor);
         if (pvalue->u.eventsDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_EventsDescriptor (pctxt, 
            pvalue->u.eventsDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.eventBufferDescriptor = rtMemAllocTypeZ (pctxt, EventBufferDescriptor);
         if (pvalue->u.eventBufferDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_EventBufferDescriptor (pctxt, 
            pvalue->u.eventBufferDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.signalsDescriptor = rtMemAllocTypeZ (pctxt, SignalsDescriptor);
         if (pvalue->u.signalsDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_SignalsDescriptor (pctxt, 
            pvalue->u.signalsDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.digitMapDescriptor = rtMemAllocTypeZ (pctxt, DigitMapDescriptor);
         if (pvalue->u.digitMapDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_DigitMapDescriptor (pctxt, 
            pvalue->u.digitMapDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.auditDescriptor = rtMemAllocTypeZ (pctxt, AuditDescriptor);
         if (pvalue->u.auditDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_AuditDescriptor (pctxt, 
            pvalue->u.auditDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 8;
         break;

      default:
         ASN1BUF_RESTORE (pctxt);
         pvalue->u.extElem1 = rtMemAllocTypeZ (pctxt, ASN1OpenType);
         if (pvalue->u.extElem1== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = xd_OpenType (pctxt, &pvalue->u.extElem1->data, &pvalue->u.extElem1->numocts);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         pvalue->t = 9;
         ccb.len = 0;
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_AmmDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfAmmDescriptor                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfAmmDescriptor (ASN1CTXT* pctxt,
   _SeqOfAmmDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   AmmDescriptor* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfAmmDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, AmmDescriptor);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_AmmDescriptor (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfAmmDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AmmRequest                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AmmRequest (ASN1CTXT* pctxt,
   AmmRequest *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_AmmRequest: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode terminationID */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TerminationIDList (pctxt, 
               &pvalue->terminationID, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode descriptors */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfAmmDescriptor (pctxt, 
               &pvalue->descriptors, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_AmmRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SubtractRequest                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SubtractRequest (ASN1CTXT* pctxt,
   SubtractRequest *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_SubtractRequest: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode terminationID */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TerminationIDList (pctxt, 
               &pvalue->terminationID, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode auditDescriptor */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_AuditDescriptor (pctxt, 
               &pvalue->auditDescriptor, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.auditDescriptorPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_SubtractRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuditRequest                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AuditRequest (ASN1CTXT* pctxt,
   AuditRequest *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_AuditRequest: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode terminationID */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TerminationID (pctxt, 
               &pvalue->terminationID, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode auditDescriptor */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_AuditDescriptor (pctxt, 
               &pvalue->auditDescriptor, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_AuditRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeNotation                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TimeNotation (ASN1CTXT* pctxt,
   TimeNotation *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_TimeNotation: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode date */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_charstr (pctxt,
               &pvalue->date,
               ASN1IMPL, (TM_UNIV|TM_PRIM|22), length);
            if (stat == 0) {
               { size_t nchars = strlen (pvalue->date);
               if (!(nchars == 8)) {
                  rtErrAddStrParm (&pctxt->errInfo, "TimeNotation.date");
                  rtErrAddIntParm (&pctxt->errInfo, (int)nchars);
                  return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
               }

               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode time_ */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_charstr (pctxt,
               &pvalue->time_,
               ASN1IMPL, (TM_UNIV|TM_PRIM|22), length);
            if (stat == 0) {
               { size_t nchars = strlen (pvalue->time_);
               if (!(nchars == 8)) {
                  rtErrAddStrParm (&pctxt->errInfo, "TimeNotation.time_");
                  rtErrAddIntParm (&pctxt->errInfo, (int)nchars);
                  return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
               }

               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_TimeNotation: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ObservedEvent                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ObservedEvent (ASN1CTXT* pctxt,
   ObservedEvent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_ObservedEvent: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode eventName */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_EventName (pctxt, 
               &pvalue->eventName, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode streamID */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_StreamID (pctxt, 
               &pvalue->streamID, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.streamIDPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode eventParList */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfEventParameter (pctxt, 
               &pvalue->eventParList, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode timeNotation */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TimeNotation (pctxt, 
               &pvalue->timeNotation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeNotationPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_ObservedEvent: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfObservedEvent                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfObservedEvent (ASN1CTXT* pctxt,
   _SeqOfObservedEvent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ObservedEvent* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfObservedEvent: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ObservedEvent);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_ObservedEvent (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfObservedEvent: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ObservedEventsDescriptor                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ObservedEventsDescriptor (ASN1CTXT* pctxt,
   ObservedEventsDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_ObservedEventsDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode requestId */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_RequestID (pctxt, 
               &pvalue->requestId, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode observedEventLst */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfObservedEvent (pctxt, 
               &pvalue->observedEventLst, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_ObservedEventsDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotifyRequest                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_NotifyRequest (ASN1CTXT* pctxt,
   NotifyRequest *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_NotifyRequest: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode terminationID */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TerminationIDList (pctxt, 
               &pvalue->terminationID, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode observedEventsDescriptor */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ObservedEventsDescriptor (pctxt, 
               &pvalue->observedEventsDescriptor, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode errorDescriptor */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ErrorDescriptor (pctxt, 
               &pvalue->errorDescriptor, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.errorDescriptorPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_NotifyRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceChangeAddress                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ServiceChangeAddress (ASN1CTXT* pctxt,
   ServiceChangeAddress *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_ServiceChangeAddress: start\n");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
         stat = xd_uint16 (pctxt, &pvalue->u.portNumber, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.ip4Address = rtMemAllocTypeZ (pctxt, IP4Address);
         if (pvalue->u.ip4Address== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_IP4Address (pctxt, 
            pvalue->u.ip4Address, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.ip6Address = rtMemAllocTypeZ (pctxt, IP6Address);
         if (pvalue->u.ip6Address== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_IP6Address (pctxt, 
            pvalue->u.ip6Address, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.domainName = rtMemAllocTypeZ (pctxt, DomainName);
         if (pvalue->u.domainName== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_DomainName (pctxt, 
            pvalue->u.domainName, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_PRIM|4):
      case (TM_CTXT|TM_CONS|4):
         stat = asn1D_PathName (pctxt, 
            &pvalue->u.deviceName, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 5;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|5):
      case (TM_CTXT|TM_CONS|5):
         pvalue->u.mtpAddress = rtMemAllocTypeZ (pctxt, ServiceChangeAddress_mtpAddress);
         if (pvalue->u.mtpAddress== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_ServiceChangeAddress_mtpAddress (pctxt, 
            pvalue->u.mtpAddress, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 6;
         ccb.len = 0;
         break;

      default:
         ASN1BUF_RESTORE (pctxt);
         pvalue->u.extElem1 = rtMemAllocTypeZ (pctxt, ASN1OpenType);
         if (pvalue->u.extElem1== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = xd_OpenType (pctxt, &pvalue->u.extElem1->data, &pvalue->u.extElem1->numocts);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         pvalue->t = 7;
         ccb.len = 0;
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_ServiceChangeAddress: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceChangeProfile                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ServiceChangeProfile (ASN1CTXT* pctxt,
   ServiceChangeProfile *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_ServiceChangeProfile: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode profileName */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_charstr (pctxt,
               &pvalue->profileName,
               ASN1IMPL, (TM_UNIV|TM_PRIM|22), length);
            if (stat == 0) {
               { size_t nchars = strlen (pvalue->profileName);
               if (!((nchars >= 1 && nchars <= 67))) {
                  rtErrAddStrParm (&pctxt->errInfo, "ServiceChangeProfile.profileName");
                  rtErrAddIntParm (&pctxt->errInfo, (int)nchars);
                  return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
               }

               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_ServiceChangeProfile: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceChangeParm                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ServiceChangeParm (ASN1CTXT* pctxt,
   ServiceChangeParm *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_ServiceChangeParm: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode serviceChangeMethod */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ServiceChangeMethod (pctxt, 
               &pvalue->serviceChangeMethod, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode serviceChangeAddress */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ServiceChangeAddress (pctxt, 
               &pvalue->serviceChangeAddress, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.serviceChangeAddressPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode serviceChangeVersion */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_uint8 (pctxt, &pvalue->serviceChangeVersion, ASN1IMPL, length);
            if (stat == 0) {
               if (!((pvalue->serviceChangeVersion <= 99))) {
                  rtErrAddStrParm (&pctxt->errInfo, "ServiceChangeParm.serviceChangeVersion");
                  rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->serviceChangeVersion);
                  return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
               }

               pvalue->m.serviceChangeVersionPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode serviceChangeProfile */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ServiceChangeProfile (pctxt, 
               &pvalue->serviceChangeProfile, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.serviceChangeProfilePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode serviceChangeReason */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_Value (pctxt, 
               &pvalue->serviceChangeReason, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode serviceChangeDelay */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->serviceChangeDelay, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.serviceChangeDelayPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode serviceChangeMgcId */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_MId (pctxt, 
               &pvalue->serviceChangeMgcId, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.serviceChangeMgcIdPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TimeNotation (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode nonStandardData */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_NonStandardData (pctxt, 
               &pvalue->nonStandardData, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.nonStandardDataPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_ServiceChangeParm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceChangeRequest                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ServiceChangeRequest (ASN1CTXT* pctxt,
   ServiceChangeRequest *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_ServiceChangeRequest: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode terminationID */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TerminationIDList (pctxt, 
               &pvalue->terminationID, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode serviceChangeParms */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ServiceChangeParm (pctxt, 
               &pvalue->serviceChangeParms, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_ServiceChangeRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Command                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Command (ASN1CTXT* pctxt,
   Command *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_Command: start\n");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.addReq = rtMemAllocTypeZ (pctxt, AmmRequest);
         if (pvalue->u.addReq== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_AmmRequest (pctxt, 
            pvalue->u.addReq, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.moveReq = rtMemAllocTypeZ (pctxt, AmmRequest);
         if (pvalue->u.moveReq== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_AmmRequest (pctxt, 
            pvalue->u.moveReq, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.modReq = rtMemAllocTypeZ (pctxt, AmmRequest);
         if (pvalue->u.modReq== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_AmmRequest (pctxt, 
            pvalue->u.modReq, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.subtractReq = rtMemAllocTypeZ (pctxt, SubtractRequest);
         if (pvalue->u.subtractReq== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_SubtractRequest (pctxt, 
            pvalue->u.subtractReq, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.auditCapRequest = rtMemAllocTypeZ (pctxt, AuditRequest);
         if (pvalue->u.auditCapRequest== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_AuditRequest (pctxt, 
            pvalue->u.auditCapRequest, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.auditValueRequest = rtMemAllocTypeZ (pctxt, AuditRequest);
         if (pvalue->u.auditValueRequest== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_AuditRequest (pctxt, 
            pvalue->u.auditValueRequest, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.notifyReq = rtMemAllocTypeZ (pctxt, NotifyRequest);
         if (pvalue->u.notifyReq== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_NotifyRequest (pctxt, 
            pvalue->u.notifyReq, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.serviceChangeReq = rtMemAllocTypeZ (pctxt, ServiceChangeRequest);
         if (pvalue->u.serviceChangeReq== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_ServiceChangeRequest (pctxt, 
            pvalue->u.serviceChangeReq, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 8;
         break;

      default:
         ASN1BUF_RESTORE (pctxt);
         pvalue->u.extElem1 = rtMemAllocTypeZ (pctxt, ASN1OpenType);
         if (pvalue->u.extElem1== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = xd_OpenType (pctxt, &pvalue->u.extElem1->data, &pvalue->u.extElem1->numocts);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         pvalue->t = 9;
         ccb.len = 0;
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_Command: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommandRequest                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CommandRequest (ASN1CTXT* pctxt,
   CommandRequest *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_CommandRequest: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode command */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_Command (pctxt, 
               &pvalue->command, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode optional */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_null (pctxt, ASN1IMPL);
            if (stat == 0) {
               pvalue->m.optionalPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode wildcardReturn */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_null (pctxt, ASN1IMPL);
            if (stat == 0) {
               pvalue->m.wildcardReturnPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_CommandRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfCommandRequest                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfCommandRequest (ASN1CTXT* pctxt,
   _SeqOfCommandRequest *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   CommandRequest* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfCommandRequest: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CommandRequest);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_CommandRequest (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfCommandRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ActionRequest                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ActionRequest (ASN1CTXT* pctxt,
   ActionRequest *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_ActionRequest: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode contextId */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ContextID (pctxt, 
               &pvalue->contextId, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode contextRequest */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ContextRequest (pctxt, 
               &pvalue->contextRequest, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.contextRequestPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode contextAttrAuditReq */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ContextAttrAuditRequest (pctxt, 
               &pvalue->contextAttrAuditReq, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.contextAttrAuditReqPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode commandRequests */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfCommandRequest (pctxt, 
               &pvalue->commandRequests, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_ActionRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfActionRequest                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfActionRequest (ASN1CTXT* pctxt,
   _SeqOfActionRequest *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ActionRequest* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfActionRequest: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ActionRequest);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_ActionRequest (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfActionRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransactionRequest                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TransactionRequest (ASN1CTXT* pctxt,
   TransactionRequest *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_TransactionRequest: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode transactionId */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TransactionId (pctxt, 
               &pvalue->transactionId, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode actions */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfActionRequest (pctxt, 
               &pvalue->actions, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_TransactionRequest: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransactionPending                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TransactionPending (ASN1CTXT* pctxt,
   TransactionPending *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_TransactionPending: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode transactionId */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TransactionId (pctxt, 
               &pvalue->transactionId, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_TransactionPending: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StatisticsParameter                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_StatisticsParameter (ASN1CTXT* pctxt,
   StatisticsParameter *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_StatisticsParameter: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode statName */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_PkgdName (pctxt, 
               &pvalue->statName, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode statValue */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_Value (pctxt, 
               &pvalue->statValue, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.statValuePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_StatisticsParameter: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StatisticsDescriptor                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_StatisticsDescriptor (ASN1CTXT* pctxt,
   StatisticsDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   StatisticsParameter* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_StatisticsDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, StatisticsParameter);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_StatisticsParameter (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_StatisticsDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PackagesItem                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PackagesItem (ASN1CTXT* pctxt,
   PackagesItem *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_PackagesItem: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode packageName */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_Name (pctxt, 
               &pvalue->packageName, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode packageVersion */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_uint8 (pctxt, &pvalue->packageVersion, ASN1IMPL, length);
            if (stat == 0) {
               if (!((pvalue->packageVersion <= 99))) {
                  rtErrAddStrParm (&pctxt->errInfo, "PackagesItem.packageVersion");
                  rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->packageVersion);
                  return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
               }

            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_PackagesItem: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PackagesDescriptor                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PackagesDescriptor (ASN1CTXT* pctxt,
   PackagesDescriptor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   PackagesItem* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_PackagesDescriptor: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, PackagesItem);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_PackagesItem (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_PackagesDescriptor: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuditReturnParameter                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AuditReturnParameter (ASN1CTXT* pctxt,
   AuditReturnParameter *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_AuditReturnParameter: start\n");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.errorDescriptor = rtMemAllocTypeZ (pctxt, ErrorDescriptor);
         if (pvalue->u.errorDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_ErrorDescriptor (pctxt, 
            pvalue->u.errorDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.mediaDescriptor = rtMemAllocTypeZ (pctxt, MediaDescriptor);
         if (pvalue->u.mediaDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_MediaDescriptor (pctxt, 
            pvalue->u.mediaDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.modemDescriptor = rtMemAllocTypeZ (pctxt, ModemDescriptor);
         if (pvalue->u.modemDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_ModemDescriptor (pctxt, 
            pvalue->u.modemDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.muxDescriptor = rtMemAllocTypeZ (pctxt, MuxDescriptor);
         if (pvalue->u.muxDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_MuxDescriptor (pctxt, 
            pvalue->u.muxDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.eventsDescriptor = rtMemAllocTypeZ (pctxt, EventsDescriptor);
         if (pvalue->u.eventsDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_EventsDescriptor (pctxt, 
            pvalue->u.eventsDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.eventBufferDescriptor = rtMemAllocTypeZ (pctxt, EventBufferDescriptor);
         if (pvalue->u.eventBufferDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_EventBufferDescriptor (pctxt, 
            pvalue->u.eventBufferDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.signalsDescriptor = rtMemAllocTypeZ (pctxt, SignalsDescriptor);
         if (pvalue->u.signalsDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_SignalsDescriptor (pctxt, 
            pvalue->u.signalsDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.digitMapDescriptor = rtMemAllocTypeZ (pctxt, DigitMapDescriptor);
         if (pvalue->u.digitMapDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_DigitMapDescriptor (pctxt, 
            pvalue->u.digitMapDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.observedEventsDescriptor = rtMemAllocTypeZ (pctxt, ObservedEventsDescriptor);
         if (pvalue->u.observedEventsDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_ObservedEventsDescriptor (pctxt, 
            pvalue->u.observedEventsDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.statisticsDescriptor = rtMemAllocTypeZ (pctxt, StatisticsDescriptor);
         if (pvalue->u.statisticsDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_StatisticsDescriptor (pctxt, 
            pvalue->u.statisticsDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.packagesDescriptor = rtMemAllocTypeZ (pctxt, PackagesDescriptor);
         if (pvalue->u.packagesDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_PackagesDescriptor (pctxt, 
            pvalue->u.packagesDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.emptyDescriptors = rtMemAllocTypeZ (pctxt, AuditDescriptor);
         if (pvalue->u.emptyDescriptors== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_AuditDescriptor (pctxt, 
            pvalue->u.emptyDescriptors, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 12;
         break;

      default:
         ASN1BUF_RESTORE (pctxt);
         pvalue->u.extElem1 = rtMemAllocTypeZ (pctxt, ASN1OpenType);
         if (pvalue->u.extElem1== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = xd_OpenType (pctxt, &pvalue->u.extElem1->data, &pvalue->u.extElem1->numocts);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         pvalue->t = 13;
         ccb.len = 0;
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_AuditReturnParameter: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminationAudit                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TerminationAudit (ASN1CTXT* pctxt,
   TerminationAudit *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   AuditReturnParameter* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_TerminationAudit: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, AuditReturnParameter);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_AuditReturnParameter (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_TerminationAudit: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AmmsReply                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AmmsReply (ASN1CTXT* pctxt,
   AmmsReply *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_AmmsReply: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode terminationID */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TerminationIDList (pctxt, 
               &pvalue->terminationID, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode terminationAudit */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TerminationAudit (pctxt, 
               &pvalue->terminationAudit, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.terminationAuditPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_AmmsReply: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuditResult                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AuditResult (ASN1CTXT* pctxt,
   AuditResult *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_AuditResult: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode terminationID */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TerminationID (pctxt, 
               &pvalue->terminationID, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode terminationAuditResult */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TerminationAudit (pctxt, 
               &pvalue->terminationAuditResult, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_AuditResult: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuditReply                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AuditReply (ASN1CTXT* pctxt,
   AuditReply *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_AuditReply: start\n");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.contextAuditResult = rtMemAllocTypeZ (pctxt, TerminationIDList);
         if (pvalue->u.contextAuditResult== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_TerminationIDList (pctxt, 
            pvalue->u.contextAuditResult, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.error = rtMemAllocTypeZ (pctxt, ErrorDescriptor);
         if (pvalue->u.error== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_ErrorDescriptor (pctxt, 
            pvalue->u.error, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.auditResult = rtMemAllocTypeZ (pctxt, AuditResult);
         if (pvalue->u.auditResult== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_AuditResult (pctxt, 
            pvalue->u.auditResult, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         ASN1BUF_RESTORE (pctxt);
         pvalue->u.extElem1 = rtMemAllocTypeZ (pctxt, ASN1OpenType);
         if (pvalue->u.extElem1== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = xd_OpenType (pctxt, &pvalue->u.extElem1->data, &pvalue->u.extElem1->numocts);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         pvalue->t = 4;
         ccb.len = 0;
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_AuditReply: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotifyReply                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_NotifyReply (ASN1CTXT* pctxt,
   NotifyReply *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_NotifyReply: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode terminationID */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TerminationIDList (pctxt, 
               &pvalue->terminationID, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode errorDescriptor */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ErrorDescriptor (pctxt, 
               &pvalue->errorDescriptor, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.errorDescriptorPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_NotifyReply: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceChangeResParm                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ServiceChangeResParm (ASN1CTXT* pctxt,
   ServiceChangeResParm *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_ServiceChangeResParm: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode serviceChangeMgcId */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_MId (pctxt, 
               &pvalue->serviceChangeMgcId, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.serviceChangeMgcIdPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode serviceChangeAddress */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ServiceChangeAddress (pctxt, 
               &pvalue->serviceChangeAddress, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.serviceChangeAddressPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode serviceChangeVersion */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_uint8 (pctxt, &pvalue->serviceChangeVersion, ASN1IMPL, length);
            if (stat == 0) {
               if (!((pvalue->serviceChangeVersion <= 99))) {
                  rtErrAddStrParm (&pctxt->errInfo, "ServiceChangeResParm.serviceChangeVersion");
                  rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->serviceChangeVersion);
                  return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
               }

               pvalue->m.serviceChangeVersionPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode serviceChangeProfile */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ServiceChangeProfile (pctxt, 
               &pvalue->serviceChangeProfile, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.serviceChangeProfilePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode timestamp */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TimeNotation (pctxt, 
               &pvalue->timestamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timestampPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_ServiceChangeResParm: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceChangeResult                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ServiceChangeResult (ASN1CTXT* pctxt,
   ServiceChangeResult *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_ServiceChangeResult: start\n");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.errorDescriptor = rtMemAllocTypeZ (pctxt, ErrorDescriptor);
         if (pvalue->u.errorDescriptor== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_ErrorDescriptor (pctxt, 
            pvalue->u.errorDescriptor, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.serviceChangeResParms = rtMemAllocTypeZ (pctxt, ServiceChangeResParm);
         if (pvalue->u.serviceChangeResParms== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_ServiceChangeResParm (pctxt, 
            pvalue->u.serviceChangeResParms, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_ServiceChangeResult: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceChangeReply                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ServiceChangeReply (ASN1CTXT* pctxt,
   ServiceChangeReply *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_ServiceChangeReply: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode terminationID */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TerminationIDList (pctxt, 
               &pvalue->terminationID, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode serviceChangeResult */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ServiceChangeResult (pctxt, 
               &pvalue->serviceChangeResult, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_ServiceChangeReply: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommandReply                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CommandReply (ASN1CTXT* pctxt,
   CommandReply *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_CommandReply: start\n");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.addReply = rtMemAllocTypeZ (pctxt, AmmsReply);
         if (pvalue->u.addReply== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_AmmsReply (pctxt, 
            pvalue->u.addReply, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.moveReply = rtMemAllocTypeZ (pctxt, AmmsReply);
         if (pvalue->u.moveReply== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_AmmsReply (pctxt, 
            pvalue->u.moveReply, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.modReply = rtMemAllocTypeZ (pctxt, AmmsReply);
         if (pvalue->u.modReply== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_AmmsReply (pctxt, 
            pvalue->u.modReply, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.subtractReply = rtMemAllocTypeZ (pctxt, AmmsReply);
         if (pvalue->u.subtractReply== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_AmmsReply (pctxt, 
            pvalue->u.subtractReply, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.auditCapReply = rtMemAllocTypeZ (pctxt, AuditReply);
         if (pvalue->u.auditCapReply== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_AuditReply (pctxt, 
            pvalue->u.auditCapReply, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.auditValueReply = rtMemAllocTypeZ (pctxt, AuditReply);
         if (pvalue->u.auditValueReply== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_AuditReply (pctxt, 
            pvalue->u.auditValueReply, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.notifyReply = rtMemAllocTypeZ (pctxt, NotifyReply);
         if (pvalue->u.notifyReply== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_NotifyReply (pctxt, 
            pvalue->u.notifyReply, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.serviceChangeReply = rtMemAllocTypeZ (pctxt, ServiceChangeReply);
         if (pvalue->u.serviceChangeReply== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_ServiceChangeReply (pctxt, 
            pvalue->u.serviceChangeReply, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 8;
         break;

      default:
         ASN1BUF_RESTORE (pctxt);
         pvalue->u.extElem1 = rtMemAllocTypeZ (pctxt, ASN1OpenType);
         if (pvalue->u.extElem1== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = xd_OpenType (pctxt, &pvalue->u.extElem1->data, &pvalue->u.extElem1->numocts);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         pvalue->t = 9;
         ccb.len = 0;
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_CommandReply: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfCommandReply                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfCommandReply (ASN1CTXT* pctxt,
   _SeqOfCommandReply *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   CommandReply* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfCommandReply: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, CommandReply);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_CommandReply (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfCommandReply: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ActionReply                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ActionReply (ASN1CTXT* pctxt,
   ActionReply *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_ActionReply: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode contextId */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ContextID (pctxt, 
               &pvalue->contextId, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode errorDescriptor */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ErrorDescriptor (pctxt, 
               &pvalue->errorDescriptor, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.errorDescriptorPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode contextReply */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_ContextRequest (pctxt, 
               &pvalue->contextReply, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.contextReplyPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode commandReply */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D__SeqOfCommandReply (pctxt, 
               &pvalue->commandReply, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_ActionReply: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfActionReply                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfActionReply (ASN1CTXT* pctxt,
   _SeqOfActionReply *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ActionReply* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfActionReply: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, ActionReply);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_ActionReply (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfActionReply: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransactionReply_transactionResult                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TransactionReply_transactionResult (ASN1CTXT* pctxt,
   TransactionReply_transactionResult *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_TransactionReply_transactionResult: start\n");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.transactionError = rtMemAllocTypeZ (pctxt, ErrorDescriptor);
         if (pvalue->u.transactionError== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_ErrorDescriptor (pctxt, 
            pvalue->u.transactionError, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.actionReplies = rtMemAllocTypeZ (pctxt, _SeqOfActionReply);
         if (pvalue->u.actionReplies== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D__SeqOfActionReply (pctxt, 
            pvalue->u.actionReplies, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_TransactionReply_transactionResult: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransactionReply                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TransactionReply (ASN1CTXT* pctxt,
   TransactionReply *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_TransactionReply: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode transactionId */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TransactionId (pctxt, 
               &pvalue->transactionId, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode immAckRequired */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_null (pctxt, ASN1IMPL);
            if (stat == 0) {
               pvalue->m.immAckRequiredPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode transactionResult */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TransactionReply_transactionResult (pctxt, 
               &pvalue->transactionResult, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_TransactionReply: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransactionAck                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TransactionAck (ASN1CTXT* pctxt,
   TransactionAck *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_TransactionAck: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode firstAck */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TransactionId (pctxt, 
               &pvalue->firstAck, ASN1IMPL, length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode lastAck */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_TransactionId (pctxt, 
               &pvalue->lastAck, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.lastAckPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_TransactionAck: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransactionResponseAck                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TransactionResponseAck (ASN1CTXT* pctxt,
   TransactionResponseAck *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   TransactionAck* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_TransactionResponseAck: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, TransactionAck);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_TransactionAck (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_TransactionResponseAck: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transaction                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Transaction (ASN1CTXT* pctxt,
   Transaction *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_Transaction: start\n");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.transactionRequest = rtMemAllocTypeZ (pctxt, TransactionRequest);
         if (pvalue->u.transactionRequest== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_TransactionRequest (pctxt, 
            pvalue->u.transactionRequest, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.transactionPending = rtMemAllocTypeZ (pctxt, TransactionPending);
         if (pvalue->u.transactionPending== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_TransactionPending (pctxt, 
            pvalue->u.transactionPending, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.transactionReply = rtMemAllocTypeZ (pctxt, TransactionReply);
         if (pvalue->u.transactionReply== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_TransactionReply (pctxt, 
            pvalue->u.transactionReply, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.transactionResponseAck = rtMemAllocTypeZ (pctxt, TransactionResponseAck);
         if (pvalue->u.transactionResponseAck== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_TransactionResponseAck (pctxt, 
            pvalue->u.transactionResponseAck, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         ASN1BUF_RESTORE (pctxt);
         pvalue->u.extElem1 = rtMemAllocTypeZ (pctxt, ASN1OpenType);
         if (pvalue->u.extElem1== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = xd_OpenType (pctxt, &pvalue->u.extElem1->data, &pvalue->u.extElem1->numocts);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         pvalue->t = 5;
         ccb.len = 0;
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_Transaction: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfTransaction                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D__SeqOfTransaction (ASN1CTXT* pctxt,
   _SeqOfTransaction *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   Transaction* pdata;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfTransaction: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, Transaction);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1D_Transaction (pctxt, 
         pdata, ASN1EXPL, length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      rtDListAppendNode (pctxt, pvalue, pdata);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D__SeqOfTransaction: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Message_messageBody                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Message_messageBody (ASN1CTXT* pctxt,
   Message_messageBody *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_Message_messageBody: start\n");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.messageError = rtMemAllocTypeZ (pctxt, ErrorDescriptor);
         if (pvalue->u.messageError== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D_ErrorDescriptor (pctxt, 
            pvalue->u.messageError, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.transactions = rtMemAllocTypeZ (pctxt, _SeqOfTransaction);
         if (pvalue->u.transactions== NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1D__SeqOfTransaction (pctxt, 
            pvalue->u.transactions, ASN1IMPL, length);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }

   RTDIAGSTRM2 (pctxt,"asn1D_Message_messageBody: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Message                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Message (ASN1CTXT* pctxt,
   Message *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_Message: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   rtDListInit (&pvalue->extElem1);

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = xd_uint8 (pctxt, &pvalue->version, ASN1IMPL, length);
            if (stat == 0) {
               if (!((pvalue->version <= 99))) {
                  rtErrAddStrParm (&pctxt->errInfo, "Message.version");
                  rtErrAddIntParm (&pctxt->errInfo, (int)pvalue->version);
                  return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);
               }

            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode mId */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_MId (pctxt, 
               &pvalue->mId, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode messageBody */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_Message_messageBody (pctxt, 
               &pvalue->messageBody, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode extElem1 */
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = xd_OpenTypeExt (pctxt, &ccb, ASN_K_NOTAG, &pvalue->extElem1);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            break;
         }}
         break;

      default:
         stat = ASN_E_SEQOVFLW;
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_Message: end\n");

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MegacoMessage                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MegacoMessage (ASN1CTXT* pctxt,
   MegacoMessage *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTDIAGSTRM2 (pctxt,"asn1D_MegacoMessage: start\n");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = ASN1BUF_PTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode authHeader */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_AuthenticationHeader (pctxt, 
               &pvalue->authHeader, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.authHeaderPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode mess */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1D_Message (pctxt, 
               &pvalue->mess, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_ASN1ERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = ASN_E_SEQORDER;
            break;
         default:
            stat = ASN_E_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_ASN1ERR (pctxt, ASN_E_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_ASN1ERR (pctxt, ASN_E_INVLEN);
   }
   RTDIAGSTRM2 (pctxt,"asn1D_MegacoMessage: end\n");

   return (stat);
}

