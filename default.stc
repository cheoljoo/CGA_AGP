FileName : ut.c
Set : iterate_comments = ON

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "struct.h"
#include "parser.h"

ITERATE %gColStruct +<<+ ITKEY  ITVALUE
void set_ITKEY_struct(struct +<+$gColStruct{ITKEY}{Name}+>+ *p) // ITKEY :  +<+$gColStruct{ITKEY}{Name}+>+
{
	ITERATE %gStructUnitTest{ITKEY} +<<+ IT2KEY  IT2VALUE
	// ITKEY IT2KEY +<+$gStructUnitTest{ITKEY}{IT2KEY}{varType}+>+
	// ITKEY IT2KEY +<+$gStructUnitTest{ITKEY}{IT2KEY}{varName}+>+
	// ITKEY IT2KEY +<+$gStructUnitTest{ITKEY}{IT2KEY}{varValue}+>+
	IFEQUAL(+<+$gStructUnitTest{ITKEY}{IT2KEY}{varType}+>+  eq "char"){
		p->+<+$gStructUnitTest{ITKEY}{IT2KEY}{varName}+>+  = (char) +<+$gStructUnitTest{ITKEY}{IT2KEY}{varValue}+>+  ;
	}
	IFEQUAL(+<+$gStructUnitTest{ITKEY}{IT2KEY}{varType}+>+  eq "short"){
		p->+<+$gStructUnitTest{ITKEY}{IT2KEY}{varName}+>+  = (short) +<+$gStructUnitTest{ITKEY}{IT2KEY}{varValue}+>+  ;
	}
	IFEQUAL(+<+$gStructUnitTest{ITKEY}{IT2KEY}{varType}+>+  eq "int"){
		p->+<+$gStructUnitTest{ITKEY}{IT2KEY}{varName}+>+  = (int) +<+$gStructUnitTest{ITKEY}{IT2KEY}{varValue}+>+  ;
	}
#ifdef DEBUG
		printf("Sets +<+$gStructUnitTest{ITKEY}{IT2KEY}{varType}+>+   +<+$gStructUnitTest{ITKEY}{IT2KEY}{varName}+>+ : value %x\n",p->+<+$gStructUnitTest{ITKEY}{IT2KEY}{varName}+>+);
#endif
	+>>+

#ifdef DEBUG
	{
		int i=0;
		unsigned char *ch;
		ch = (unsigned char *)p;
		printf("Buffer = ");
		for(i=0;i<20;i++){
			printf("%2x ",ch[i]);
		}
		printf("\n");
	}
#endif
}
+>>+

int main()
{
	char buf[BUFSIZ];

	ITERATE %gColStruct +<<+ ITKEY  ITVALUE
	{
		struct +<+$gColStruct{ITKEY}{Name}+>+ *p;
		p = (struct +<+$gColStruct{ITKEY}{Name}+>+ *) buf;
		{
			int ret;
			memset(buf , 0 , BUFSIZ);
			set_ITKEY_struct(p);
			ret = parser((unsigned char *) p);
			printf("ITKEY +<+$gColStruct{ITKEY}{Name}+>+ success RET : %d\n",ret);
		}
		ITERATE %gStructUnitTest{ITKEY} +<<+ IT2KEY  IT2VALUE
		{
			int ret;
			memset(buf , (int) 0 , BUFSIZ);
			set_ITKEY_struct(p);
			p->+<+$gStructUnitTest{ITKEY}{IT2KEY}{varName}+>+  = ( +<+$gStructUnitTest{ITKEY}{IT2KEY}{varType}+>+ ) 0xff; // orgValue: +<+$gStructUnitTest{ITKEY}{IT2KEY}{varValue}+>+ 
			ret = parser((unsigned char *) p);
			printf("ITKEY +<+$gColStruct{ITKEY}{Name}+>+ fail RET : %d\n",ret);
		}
		+>>+

	}
	+>>+

	return 0;
}


FileName : parser.c
Set : iterate_comments = ON
#include "parser.h"

ITERATE -V%gColShortStructName +<<+ ITKEY  ITVALUE
#define PARSER_RETURN_ITKEY     ITVALUE
				// Structure Index (It will be returned) : ITKEY [  +<+$gColShortStructName{ITKEY}+>+  ]
+>>+

ITERATE V%gLongDefine{Name} +<<+ ITKEY  ITVALUE
#define ITKEY   +<+$gLongDefine{Name}{ITKEY}+>+
+>>+

int parser(unsigned char *p){
	return parser_level+<+$gParserMinY+>+(-1,"INIT",p);
}

ITERATE %gParserRow +<<+ ITKEY  ITVALUE
int parser_levelITKEY(int FromStatus, const char *s,unsigned char *p){
	//  unsigned char / short / int value = (unsigned char / short / int) (p + LENGTH)
	unsigned char *pcvalue; pcvalue = (unsigned char *) (p+ITKEY);
	short *psvalue; psvalue = (short *) (p+ITKEY);
	int *pivalue; pivalue = (int *) (p+ITKEY);

#ifdef DEBUG
	printf("parser_levelITKEY : FromStatus %s\n",s);
		printf("*pcvalue [0x%x] ",*pcvalue);
		printf("*psvalue [0x%x] ",*psvalue);
		printf("*pivalue [0x%x]\n",*pivalue);
#endif

	IFEQUAL( ITKEY eq +<+$gParserMinY+>+){
		if(0){
		}
		ITERATE %gParserRow{ITKEY} +<<+ IT2KEY  IT2VALUE
		else if(
			IFEQUAL($gParserRow{ITKEY}{IT2KEY}{Len} eq 1){ *pcvalue == (unsigned char) +<+$gParserRow{ITKEY}{IT2KEY}{Value}+>+ }
			IFEQUAL($gParserRow{ITKEY}{IT2KEY}{Len} eq 2){ *psvalue == (short) +<+$gParserRow{ITKEY}{IT2KEY}{Value}+>+ }
			IFEQUAL($gParserRow{ITKEY}{IT2KEY}{Len} eq 4){ *pivalue == (int) +<+$gParserRow{ITKEY}{IT2KEY}{Value}+>+ }
		){
			IFEQUAL($gParserRow{ITKEY}{IT2KEY}{ShortStruct} eq "O"){
				return +<+$gParserRow{ITKEY}{IT2KEY}{LongDefine}+>+ ;         // X : IT2KEY, Y : ITKEY
			}
			IFNOTEQUAL($gParserRow{ITKEY}{IT2KEY}{ShortStruct} eq "O"){
				return parser_level+<+$gParserRow{ITKEY}{IT2KEY}{NextY}+>+(+<+$gParserRow{ITKEY}{IT2KEY}{LongDefine}+>+, "+<+$gParserRow{ITKEY}{IT2KEY}{LongDefine}+>+", p );  // X : IT2KEY, Y : ITKEY
			}
		}
		+>>+
	}
	IFNOTEQUAL( ITKEY eq +<+$gParserMinY+>+){
		if(0){
		}
		ITERATE %gParserRow{ITKEY} +<<+ IT2KEY  IT2VALUE
		else if( (FromStatus == +<+$gParserRow{$gParserRow{ITKEY}{IT2KEY}{ParserParentY}}{$gParserRow{ITKEY}{IT2KEY}{ParserParentX}}{LongDefine}+>+)  && 
			IFEQUAL($gParserRow{ITKEY}{IT2KEY}{Len} eq 1){ (*pcvalue == +<+$gParserRow{ITKEY}{IT2KEY}{Value}+>+) }
			IFEQUAL($gParserRow{ITKEY}{IT2KEY}{Len} eq 2){ (*psvalue == +<+$gParserRow{ITKEY}{IT2KEY}{Value}+>+) }
			IFEQUAL($gParserRow{ITKEY}{IT2KEY}{Len} eq 4){ (*pivalue == +<+$gParserRow{ITKEY}{IT2KEY}{Value}+>+) }
		){
			//FromStatus == $gParserRow{$gParserRow{ITKEY}{IT2KEY}{ParserParentY}}{$gParserRow{ITKEY}{IT2KEY}{ParserParentX}}{LongDefine}
			//FromStatus == $gParserRow{+<+$gParserRow{ITKEY}{IT2KEY}{ParserParentY}+>+}{+<+$gParserRow{ITKEY}{IT2KEY}{ParserParentX}+>+}{LongDefine}
			//FromStatus == +<+$gParserRow{$gParserRow{ITKEY}{IT2KEY}{ParserParentY}}{$gParserRow{ITKEY}{IT2KEY}{ParserParentX}}{LongDefine}+>+
			//FromStatus == +<+$gParserRow{+<+$gParserRow{ITKEY}{IT2KEY}{ParserParentY}+>+}{+<+$gParserRow{ITKEY}{IT2KEY}{ParserParentX}+>+}{LongDefine}+>+
			IFEQUAL($gParserRow{ITKEY}{IT2KEY}{ShortStruct} eq "O"){
				return PARSER_RETURN_+<+$gParserRow{ITKEY}{IT2KEY}{LongDefine}+>+ ;         // X : IT2KEY, Y : ITKEY
				// Structure Index : +<+$gParserRow{ITKEY}{IT2KEY}{LongDefine}+>+ [  +<+$gColShortStructName{+<+$gParserRow{ITKEY}{IT2KEY}{LongDefine}+>+}+>+  ]
			}
			IFNOTEQUAL($gParserRow{ITKEY}{IT2KEY}{ShortStruct} eq "O"){
				//return parser_level$gParserRow{ITKEY}{IT2KEY}{NextY}($gParserRow{ITKEY}{IT2KEY}{LongDefine}, p + 1);
				return parser_level+<+$gParserRow{ITKEY}{IT2KEY}{NextY}+>+(+<+$gParserRow{ITKEY}{IT2KEY}{LongDefine}+>+,"+<+$gParserRow{ITKEY}{IT2KEY}{LongDefine}+>+", p );  // X : IT2KEY, Y : ITKEY
				// Structure Index : +<+$gParserRow{ITKEY}{IT2KEY}{LongDefine}+>+ [  +<+$gColShortStructName{+<+$gParserRow{ITKEY}{IT2KEY}{LongDefine}+>+}+>+  ]
			}
		}
		+>>+
	}

	return -1;
}

+>>+


FileName : parser.h
Set : iterate_comments = ON
int parser(unsigned char *p);
ITERATE %gParserRow +<<+ ITKEY  ITVALUE
int parser_levelITKEY(int FromStatus, const char *s,unsigned char *p);
+>>+



FileName : struct.h

#pragma pack(1)
ITERATE %gColStruct +<<+ ITKEY  ITVALUE
+<+$gColStruct{ITKEY}{Struct}+>+
+>>+





FileName : table_protocol.html
Set : iterate_comments = OFF

<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8">
<title>Table</title>
</head> 
<STYLE TYPE="text/css">
table {font-size: 75%;}
</STYLE>
<body>
 <h1>Data Table Caption</h1>
  <table border="1">


ITERATE +gRow +<<+ ITKEY  ITVALUE
	<tr height=35px><td>ITKEY</td>
	ITERATE %gRow{ITKEY} +<<+ IT2KEY  IT2VALUE
		<!-- itkey ITKEY , it2key IT2KEY (+<+$gRow{ITKEY}{IT2KEY}{Len}+>+ >= 1) && (+<+$gRow{ITKEY}{IT2KEY}{Span}+>+ >= 1) -->
		IFEQUAL( (+<+$gRow{ITKEY}{IT2KEY}{Len}+>+ >= 1) && (+<+$gRow{ITKEY}{IT2KEY}{Span}+>+ >= 1)) {
			<td align=center border=1 bgcolor=beige rowspan="+<+$gRow{ITKEY}{IT2KEY}{Len}+>+"  colspan="+<+$gRow{ITKEY}{IT2KEY}{Span}+>+" >
				+<+$gRow{ITKEY}{IT2KEY}{Value}+>+ <br> +<+$gRow{ITKEY}{IT2KEY}{Description}+>+
			</td>
		}	
		IFEQUAL( (+<+$gRow{ITKEY}{IT2KEY}{Len}+>+ >= 1) && (+<+$gRow{ITKEY}{IT2KEY}{Span}+>+ == -1)){
			<td border=0 
			IFEQUAL(+<+$gRow{ITKEY}{IT2KEY}{Len}+>+ >= 1){
				rowspan="+<+$gRow{ITKEY}{IT2KEY}{Len}+>+"
			}
			>    </td>
		}	
	+>>+
	</tr>
+>>+



  </table>
  </body>
  </html>
