/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.83, Date: 20-Mar-2007.
 */
#include "asn1intl.h"
#include "RANAP-PDU-ContentsTable.h"
#include "RANAP-IEsTable.h"

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseCommandIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__Iu_ReleaseCommandIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Iu_ReleaseCommandIEs_Value *pvalue = (_Iu_ReleaseCommandIEs_Value*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Iu_ReleaseCommand_protocolIEs_element (ASN1CTXT* pctxt, Iu_ReleaseCommand_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_Iu_ReleaseCommand_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_Iu_ReleaseCommand_protocolIEs_element (ASN1CTXT* pctxt,
   Iu_ReleaseCommand_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Iu_ReleaseCommandIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseCommandIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseCommandIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = Iu_ReleaseCommandIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Iu_ReleaseCommand_protocolIEs (ASN1CTXT* pctxt, Iu_ReleaseCommand_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_Iu_ReleaseCommand_protocolIEs_element (pctxt, ((Iu_ReleaseCommand_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Iu_ReleaseCommand_protocolExtensions_element (ASN1CTXT* pctxt, Iu_ReleaseCommand_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_Iu_ReleaseCommand_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_Iu_ReleaseCommand_protocolExtensions_element (ASN1CTXT* pctxt,
   Iu_ReleaseCommand_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Iu_ReleaseCommandExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseCommandExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseCommandExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = Iu_ReleaseCommandExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Iu_ReleaseCommand_protocolExtensions (ASN1CTXT* pctxt, Iu_ReleaseCommand_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_Iu_ReleaseCommand_protocolExtensions_element (pctxt, ((Iu_ReleaseCommand_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseCommand                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Iu_ReleaseCommand (ASN1CTXT* pctxt, Iu_ReleaseCommand* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_Iu_ReleaseCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_Iu_ReleaseCommand_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeList_element_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DataVolumeList_element_iE_Extensions_element (ASN1CTXT* pctxt, DataVolumeList_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_DataVolumeList_element_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeList_element_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_DataVolumeList_element_iE_Extensions_element (ASN1CTXT* pctxt,
   DataVolumeList_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DataVolumeList_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeList_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeList_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = DataVolumeList_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DataVolumeList_element_iE_Extensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DataVolumeList_element_iE_Extensions (ASN1CTXT* pctxt, DataVolumeList_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_DataVolumeList_element_iE_Extensions_element (pctxt, ((DataVolumeList_element_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeList_element                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DataVolumeList_element (ASN1CTXT* pctxt, DataVolumeList_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dataVolumeReferencePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode dl_UnsuccessfullyTransmittedDataVolume */

   stat = asn1PE_UnsuccessfullyTransmittedDataVolume (pctxt, pvalue->dl_UnsuccessfullyTransmittedDataVolume);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode dataVolumeReference */

   if (pvalue->m.dataVolumeReferencePresent) {
      stat = asn1PE_DataVolumeReference (pctxt, pvalue->dataVolumeReference);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_DataVolumeList_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeList                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DataVolumeList (ASN1CTXT* pctxt, DataVolumeList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_DataVolumeList_element (pctxt, ((DataVolumeList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportItem_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataVolumeReportItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_DataVolumeReportItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_DataVolumeReportItem_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportItem_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_DataVolumeReportItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_DataVolumeReportItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataVolumeReportItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataVolumeReportItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataVolumeReportItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_DataVolumeReportItem_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportItem_iE_Extensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataVolumeReportItem_iE_Extensions (ASN1CTXT* pctxt, RAB_DataVolumeReportItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_DataVolumeReportItem_iE_Extensions_element (pctxt, ((RAB_DataVolumeReportItem_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportItem                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataVolumeReportItem (ASN1CTXT* pctxt, RAB_DataVolumeReportItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dl_UnsuccessfullyTransmittedDataVolumePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode dl_UnsuccessfullyTransmittedDataVolume */

   if (pvalue->m.dl_UnsuccessfullyTransmittedDataVolumePresent) {
      stat = asn1PE_DataVolumeList (pctxt, &pvalue->dl_UnsuccessfullyTransmittedDataVolume);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_DataVolumeReportItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataVolumeReportItemIEs_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_DataVolumeReportItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_DataVolumeReportItemIEs_Value *pvalue = (_RAB_DataVolumeReportItemIEs_Value*) pvalue_;
   stat = asn1PE_RAB_DataVolumeReportItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportList_element_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataVolumeReportList_element_element (ASN1CTXT* pctxt, RAB_DataVolumeReportList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_DataVolumeReportList_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportList_element_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_DataVolumeReportList_element_element (ASN1CTXT* pctxt,
   RAB_DataVolumeReportList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataVolumeReportItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataVolumeReportItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataVolumeReportItemIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_DataVolumeReportItemIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportList_element                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataVolumeReportList_element (ASN1CTXT* pctxt, RAB_DataVolumeReportList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_DataVolumeReportList_element_element (pctxt, ((RAB_DataVolumeReportList_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportList                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataVolumeReportList (ASN1CTXT* pctxt, RAB_DataVolumeReportList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_DataVolumeReportList_element (pctxt, ((RAB_DataVolumeReportList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseCompleteIEs_Value                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__Iu_ReleaseCompleteIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Iu_ReleaseCompleteIEs_Value *pvalue = (_Iu_ReleaseCompleteIEs_Value*) pvalue_;
   stat = asn1PE_RAB_DataVolumeReportList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_IuRelComp_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleasedItem_IuRelComp_iE_Extensions_element (ASN1CTXT* pctxt, RAB_ReleasedItem_IuRelComp_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_ReleasedItem_IuRelComp_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_IuRelComp_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_ReleasedItem_IuRelComp_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_ReleasedItem_IuRelComp_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleasedItem_IuRelComp_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleasedItem_IuRelComp_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleasedItem_IuRelComp_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_ReleasedItem_IuRelComp_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_IuRelComp_iE_Extensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleasedItem_IuRelComp_iE_Extensions (ASN1CTXT* pctxt, RAB_ReleasedItem_IuRelComp_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ReleasedItem_IuRelComp_iE_Extensions_element (pctxt, ((RAB_ReleasedItem_IuRelComp_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_IuRelComp                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleasedItem_IuRelComp (ASN1CTXT* pctxt, RAB_ReleasedItem_IuRelComp* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dL_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.uL_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode dL_GTP_PDU_SequenceNumber */

   if (pvalue->m.dL_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PE_DL_GTP_PDU_SequenceNumber (pctxt, pvalue->dL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode uL_GTP_PDU_SequenceNumber */

   if (pvalue->m.uL_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PE_UL_GTP_PDU_SequenceNumber (pctxt, pvalue->uL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_ReleasedItem_IuRelComp_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ReleasedItem_IuRelComp_IEs_Value                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_ReleasedItem_IuRelComp_IEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ReleasedItem_IuRelComp_IEs_Value *pvalue = (_RAB_ReleasedItem_IuRelComp_IEs_Value*) pvalue_;
   stat = asn1PE_RAB_ReleasedItem_IuRelComp (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_IuRelComp_element_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleasedList_IuRelComp_element_element (ASN1CTXT* pctxt, RAB_ReleasedList_IuRelComp_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_ReleasedList_IuRelComp_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_IuRelComp_element_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_ReleasedList_IuRelComp_element_element (ASN1CTXT* pctxt,
   RAB_ReleasedList_IuRelComp_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleasedItem_IuRelComp_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleasedItem_IuRelComp_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleasedItem_IuRelComp_IEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_ReleasedItem_IuRelComp_IEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_IuRelComp_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleasedList_IuRelComp_element (ASN1CTXT* pctxt, RAB_ReleasedList_IuRelComp_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ReleasedList_IuRelComp_element_element (pctxt, ((RAB_ReleasedList_IuRelComp_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_IuRelComp                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleasedList_IuRelComp (ASN1CTXT* pctxt, RAB_ReleasedList_IuRelComp* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ReleasedList_IuRelComp_element (pctxt, ((RAB_ReleasedList_IuRelComp_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseCompleteIEs_Value_1                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__Iu_ReleaseCompleteIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Iu_ReleaseCompleteIEs_Value_1 *pvalue = (_Iu_ReleaseCompleteIEs_Value_1*) pvalue_;
   stat = asn1PE_RAB_ReleasedList_IuRelComp (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseCompleteIEs_Value_2                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__Iu_ReleaseCompleteIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Iu_ReleaseCompleteIEs_Value_2 *pvalue = (_Iu_ReleaseCompleteIEs_Value_2*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Iu_ReleaseComplete_protocolIEs_element (ASN1CTXT* pctxt, Iu_ReleaseComplete_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_Iu_ReleaseComplete_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_Iu_ReleaseComplete_protocolIEs_element (ASN1CTXT* pctxt,
   Iu_ReleaseComplete_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Iu_ReleaseCompleteIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseCompleteIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseCompleteIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = Iu_ReleaseCompleteIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolIEs                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Iu_ReleaseComplete_protocolIEs (ASN1CTXT* pctxt, Iu_ReleaseComplete_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_Iu_ReleaseComplete_protocolIEs_element (pctxt, ((Iu_ReleaseComplete_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Iu_ReleaseComplete_protocolExtensions_element (ASN1CTXT* pctxt, Iu_ReleaseComplete_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_Iu_ReleaseComplete_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_Iu_ReleaseComplete_protocolExtensions_element (ASN1CTXT* pctxt,
   Iu_ReleaseComplete_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Iu_ReleaseCompleteExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseCompleteExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseCompleteExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = Iu_ReleaseCompleteExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete_protocolExtensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Iu_ReleaseComplete_protocolExtensions (ASN1CTXT* pctxt, Iu_ReleaseComplete_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_Iu_ReleaseComplete_protocolExtensions_element (pctxt, ((Iu_ReleaseComplete_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseComplete                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Iu_ReleaseComplete (ASN1CTXT* pctxt, Iu_ReleaseComplete* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_Iu_ReleaseComplete_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_Iu_ReleaseComplete_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequiredIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value value = *((_RelocationRequiredIEs_Value*)pvalue_);
   stat = asn1PE_RelocationType (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_1                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequiredIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_1 *pvalue = (_RelocationRequiredIEs_Value_1*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_2                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequiredIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_2 *pvalue = (_RelocationRequiredIEs_Value_2*) pvalue_;
   stat = asn1PE_SourceID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_3                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequiredIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_3 *pvalue = (_RelocationRequiredIEs_Value_3*) pvalue_;
   stat = asn1PE_TargetID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_4                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequiredIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_4 value = *((_RelocationRequiredIEs_Value_4*)pvalue_);
   stat = asn1PE_ClassmarkInformation2 (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_5                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequiredIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_5 value = *((_RelocationRequiredIEs_Value_5*)pvalue_);
   stat = asn1PE_ClassmarkInformation3 (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_6                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequiredIEs_Value_6 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_6 *pvalue = (_RelocationRequiredIEs_Value_6*) pvalue_;
   stat = asn1PE_SourceRNC_ToTargetRNC_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredIEs_Value_7                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequiredIEs_Value_7 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredIEs_Value_7 value = *((_RelocationRequiredIEs_Value_7*)pvalue_);
   stat = asn1PE_OldBSS_ToNewBSS_Information (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationRequired_protocolIEs_element (ASN1CTXT* pctxt, RelocationRequired_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationRequired_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationRequired_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationRequired_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationRequiredIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequiredIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequiredIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationRequiredIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolIEs                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationRequired_protocolIEs (ASN1CTXT* pctxt, RelocationRequired_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationRequired_protocolIEs_element (pctxt, ((RelocationRequired_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredExtensions_Extension                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequiredExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredExtensions_Extension value = *((_RelocationRequiredExtensions_Extension*)pvalue_);
   stat = asn1PE_GERAN_Classmark (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequiredExtensions_Extension_1                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequiredExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequiredExtensions_Extension_1 value = *((_RelocationRequiredExtensions_Extension_1*)pvalue_);
   stat = asn1PE_SourceBSS_ToTargetBSS_TransparentContainer (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationRequired_protocolExtensions_element (ASN1CTXT* pctxt, RelocationRequired_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationRequired_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationRequired_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationRequired_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationRequiredExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequiredExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequiredExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationRequiredExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired_protocolExtensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationRequired_protocolExtensions (ASN1CTXT* pctxt, RelocationRequired_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationRequired_protocolExtensions_element (pctxt, ((RelocationRequired_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequired                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationRequired (ASN1CTXT* pctxt, RelocationRequired* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_RelocationRequired_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_RelocationRequired_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationCommandIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandIEs_Value *pvalue = (_RelocationCommandIEs_Value*) pvalue_;
   stat = asn1PE_TargetRNC_ToSourceRNC_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value_1                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationCommandIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandIEs_Value_1 value = *((_RelocationCommandIEs_Value_1*)pvalue_);
   stat = asn1PE_L3_Information (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseItem_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_RelocationReleaseItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_RelocationReleaseItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_RelocationReleaseItem_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseItem_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_RelocationReleaseItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_RelocationReleaseItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_RelocationReleaseItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_RelocationReleaseItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_RelocationReleaseItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_RelocationReleaseItem_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseItem_iE_Extensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_RelocationReleaseItem_iE_Extensions (ASN1CTXT* pctxt, RAB_RelocationReleaseItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_RelocationReleaseItem_iE_Extensions_element (pctxt, ((RAB_RelocationReleaseItem_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseItem                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_RelocationReleaseItem (ASN1CTXT* pctxt, RAB_RelocationReleaseItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_RelocationReleaseItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_RelocationReleaseItemIEs_Value                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_RelocationReleaseItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_RelocationReleaseItemIEs_Value *pvalue = (_RAB_RelocationReleaseItemIEs_Value*) pvalue_;
   stat = asn1PE_RAB_RelocationReleaseItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseList_element_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_RelocationReleaseList_element_element (ASN1CTXT* pctxt, RAB_RelocationReleaseList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_RelocationReleaseList_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseList_element_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_RelocationReleaseList_element_element (ASN1CTXT* pctxt,
   RAB_RelocationReleaseList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_RelocationReleaseItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_RelocationReleaseItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_RelocationReleaseItemIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_RelocationReleaseItemIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseList_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_RelocationReleaseList_element (ASN1CTXT* pctxt, RAB_RelocationReleaseList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_RelocationReleaseList_element_element (pctxt, ((RAB_RelocationReleaseList_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_RelocationReleaseList                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_RelocationReleaseList (ASN1CTXT* pctxt, RAB_RelocationReleaseList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_RelocationReleaseList_element (pctxt, ((RAB_RelocationReleaseList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value_2                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationCommandIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandIEs_Value_2 *pvalue = (_RelocationCommandIEs_Value_2*) pvalue_;
   stat = asn1PE_RAB_RelocationReleaseList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataForwardingItem_ExtIEs_Extension                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_DataForwardingItem_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_DataForwardingItem_ExtIEs_Extension value = *((_RAB_DataForwardingItem_ExtIEs_Extension*)pvalue_);
   stat = asn1PE_TransportLayerAddress (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataForwardingItem_ExtIEs_Extension_1                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_DataForwardingItem_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_DataForwardingItem_ExtIEs_Extension_1 *pvalue = (_RAB_DataForwardingItem_ExtIEs_Extension_1*) pvalue_;
   stat = asn1PE_IuTransportAssociation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataForwardingItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_DataForwardingItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_DataForwardingItem_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_DataForwardingItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_DataForwardingItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataForwardingItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataForwardingItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataForwardingItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_DataForwardingItem_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_iE_Extensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataForwardingItem_iE_Extensions (ASN1CTXT* pctxt, RAB_DataForwardingItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_DataForwardingItem_iE_Extensions_element (pctxt, ((RAB_DataForwardingItem_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataForwardingItem (ASN1CTXT* pctxt, RAB_DataForwardingItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode transportLayerAddress */

   stat = asn1PE_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iuTransportAssociation */

   stat = asn1PE_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_DataForwardingItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataForwardingItemIEs_Value                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_DataForwardingItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_DataForwardingItemIEs_Value *pvalue = (_RAB_DataForwardingItemIEs_Value*) pvalue_;
   stat = asn1PE_RAB_DataForwardingItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_element_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataForwardingList_element_element (ASN1CTXT* pctxt, RAB_DataForwardingList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_DataForwardingList_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_element_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_DataForwardingList_element_element (ASN1CTXT* pctxt,
   RAB_DataForwardingList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataForwardingItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataForwardingItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataForwardingItemIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_DataForwardingItemIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataForwardingList_element (ASN1CTXT* pctxt, RAB_DataForwardingList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_DataForwardingList_element_element (pctxt, ((RAB_DataForwardingList_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataForwardingList (ASN1CTXT* pctxt, RAB_DataForwardingList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_DataForwardingList_element (pctxt, ((RAB_DataForwardingList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value_3                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationCommandIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandIEs_Value_3 *pvalue = (_RelocationCommandIEs_Value_3*) pvalue_;
   stat = asn1PE_RAB_DataForwardingList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandIEs_Value_4                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationCommandIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandIEs_Value_4 *pvalue = (_RelocationCommandIEs_Value_4*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationCommand_protocolIEs_element (ASN1CTXT* pctxt, RelocationCommand_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationCommand_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationCommand_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationCommand_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCommandIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCommandIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCommandIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationCommandIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationCommand_protocolIEs (ASN1CTXT* pctxt, RelocationCommand_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationCommand_protocolIEs_element (pctxt, ((RelocationCommand_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandExtensions_Extension                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationCommandExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandExtensions_Extension *pvalue = (_RelocationCommandExtensions_Extension*) pvalue_;
   stat = asn1PE_InterSystemInformation_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCommandExtensions_Extension_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationCommandExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCommandExtensions_Extension_1 value = *((_RelocationCommandExtensions_Extension_1*)pvalue_);
   stat = asn1PE_TargetBSS_ToSourceBSS_TransparentContainer (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationCommand_protocolExtensions_element (ASN1CTXT* pctxt, RelocationCommand_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationCommand_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationCommand_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationCommand_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCommandExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCommandExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCommandExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationCommandExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationCommand_protocolExtensions (ASN1CTXT* pctxt, RelocationCommand_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationCommand_protocolExtensions_element (pctxt, ((RelocationCommand_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCommand                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationCommand (ASN1CTXT* pctxt, RelocationCommand* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_RelocationCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_RelocationCommand_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationPreparationFailureIEs_Value                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationPreparationFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationPreparationFailureIEs_Value *pvalue = (_RelocationPreparationFailureIEs_Value*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationPreparationFailureIEs_Value_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationPreparationFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationPreparationFailureIEs_Value_1 *pvalue = (_RelocationPreparationFailureIEs_Value_1*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolIEs_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationPreparationFailure_protocolIEs_element (ASN1CTXT* pctxt, RelocationPreparationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationPreparationFailure_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolIEs_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationPreparationFailure_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationPreparationFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationPreparationFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationPreparationFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationPreparationFailureIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationPreparationFailureIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolIEs                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationPreparationFailure_protocolIEs (ASN1CTXT* pctxt, RelocationPreparationFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationPreparationFailure_protocolIEs_element (pctxt, ((RelocationPreparationFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationPreparationFailureExtensions_Extension         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationPreparationFailureExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationPreparationFailureExtensions_Extension *pvalue = (_RelocationPreparationFailureExtensions_Extension*) pvalue_;
   stat = asn1PE_InterSystemInformation_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationPreparationFailure_protocolExtensions_element (ASN1CTXT* pctxt, RelocationPreparationFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationPreparationFailure_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationPreparationFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationPreparationFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationPreparationFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationPreparationFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationPreparationFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationPreparationFailureExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure_protocolExtensions           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationPreparationFailure_protocolExtensions (ASN1CTXT* pctxt, RelocationPreparationFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationPreparationFailure_protocolExtensions_element (pctxt, ((RelocationPreparationFailure_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationPreparationFailure                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationPreparationFailure (ASN1CTXT* pctxt, RelocationPreparationFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_RelocationPreparationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_RelocationPreparationFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value *pvalue = (_RelocationRequestIEs_Value*) pvalue_;
   stat = asn1PE_PermanentNAS_UE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_1                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_1 *pvalue = (_RelocationRequestIEs_Value_1*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_2                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_2 value = *((_RelocationRequestIEs_Value_2*)pvalue_);
   stat = asn1PE_CN_DomainIndicator (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_3                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_3 *pvalue = (_RelocationRequestIEs_Value_3*) pvalue_;
   stat = asn1PE_SourceRNC_ToTargetRNC_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserPlaneInformation_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UserPlaneInformation_iE_Extensions_element (ASN1CTXT* pctxt, UserPlaneInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_UserPlaneInformation_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserPlaneInformation_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_UserPlaneInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   UserPlaneInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UserPlaneInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UserPlaneInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UserPlaneInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = UserPlaneInformation_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UserPlaneInformation_iE_Extensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UserPlaneInformation_iE_Extensions (ASN1CTXT* pctxt, UserPlaneInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_UserPlaneInformation_iE_Extensions_element (pctxt, ((UserPlaneInformation_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserPlaneInformation                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UserPlaneInformation (ASN1CTXT* pctxt, UserPlaneInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode userPlaneMode */

   stat = asn1PE_UserPlaneMode (pctxt, pvalue->userPlaneMode);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode uP_ModeVersions */

   stat = asn1PE_UP_ModeVersions (pctxt, &pvalue->uP_ModeVersions);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_UserPlaneInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReq_ExtIEs_Extension                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_SetupItem_RelocReq_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReq_ExtIEs_Extension *pvalue = (_RAB_SetupItem_RelocReq_ExtIEs_Extension*) pvalue_;
   stat = asn1PE_Alt_RAB_Parameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReq_ExtIEs_Extension_1                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_SetupItem_RelocReq_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReq_ExtIEs_Extension_1 value = *((_RAB_SetupItem_RelocReq_ExtIEs_Extension_1*)pvalue_);
   stat = asn1PE_GERAN_BSC_Container (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReq_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupItem_RelocReq_iE_Extensions_element (ASN1CTXT* pctxt, RAB_SetupItem_RelocReq_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_SetupItem_RelocReq_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReq_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_SetupItem_RelocReq_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_SetupItem_RelocReq_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupItem_RelocReq_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupItem_RelocReq_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupItem_RelocReq_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_SetupItem_RelocReq_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReq_iE_Extensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupItem_RelocReq_iE_Extensions (ASN1CTXT* pctxt, RAB_SetupItem_RelocReq_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_SetupItem_RelocReq_iE_Extensions_element (pctxt, ((RAB_SetupItem_RelocReq_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReq                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupItem_RelocReq (ASN1CTXT* pctxt, RAB_SetupItem_RelocReq* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.nAS_SynchronisationIndicatorPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dataVolumeReportingIndicationPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.pDP_TypeInformationPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.service_HandoverPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode nAS_SynchronisationIndicator */

   if (pvalue->m.nAS_SynchronisationIndicatorPresent) {
      stat = asn1PE_NAS_SynchronisationIndicator (pctxt, &pvalue->nAS_SynchronisationIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode rAB_Parameters */

   stat = asn1PE_RAB_Parameters (pctxt, &pvalue->rAB_Parameters);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode dataVolumeReportingIndication */

   if (pvalue->m.dataVolumeReportingIndicationPresent) {
      stat = asn1PE_DataVolumeReportingIndication (pctxt, pvalue->dataVolumeReportingIndication);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode pDP_TypeInformation */

   if (pvalue->m.pDP_TypeInformationPresent) {
      stat = asn1PE_PDP_TypeInformation (pctxt, &pvalue->pDP_TypeInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode userPlaneInformation */

   stat = asn1PE_UserPlaneInformation (pctxt, &pvalue->userPlaneInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode transportLayerAddress */

   stat = asn1PE_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iuTransportAssociation */

   stat = asn1PE_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode service_Handover */

   if (pvalue->m.service_HandoverPresent) {
      stat = asn1PE_Service_Handover (pctxt, pvalue->service_Handover);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_SetupItem_RelocReq_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReq_IEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_SetupItem_RelocReq_IEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReq_IEs_Value *pvalue = (_RAB_SetupItem_RelocReq_IEs_Value*) pvalue_;
   stat = asn1PE_RAB_SetupItem_RelocReq (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReq_element_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupList_RelocReq_element_element (ASN1CTXT* pctxt, RAB_SetupList_RelocReq_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_SetupList_RelocReq_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReq_element_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_SetupList_RelocReq_element_element (ASN1CTXT* pctxt,
   RAB_SetupList_RelocReq_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupItem_RelocReq_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupItem_RelocReq_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupItem_RelocReq_IEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_SetupItem_RelocReq_IEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReq_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupList_RelocReq_element (ASN1CTXT* pctxt, RAB_SetupList_RelocReq_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_SetupList_RelocReq_element_element (pctxt, ((RAB_SetupList_RelocReq_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReq                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupList_RelocReq (ASN1CTXT* pctxt, RAB_SetupList_RelocReq* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_SetupList_RelocReq_element (pctxt, ((RAB_SetupList_RelocReq_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_4                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_4 *pvalue = (_RelocationRequestIEs_Value_4*) pvalue_;
   stat = asn1PE_RAB_SetupList_RelocReq (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_5                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_5 *pvalue = (_RelocationRequestIEs_Value_5*) pvalue_;
   stat = asn1PE_IntegrityProtectionInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_6                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestIEs_Value_6 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_6 *pvalue = (_RelocationRequestIEs_Value_6*) pvalue_;
   stat = asn1PE_EncryptionInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestIEs_Value_7                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestIEs_Value_7 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestIEs_Value_7 *pvalue = (_RelocationRequestIEs_Value_7*) pvalue_;
   stat = asn1PE_IuSignallingConnectionIdentifier (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationRequest_protocolIEs_element (ASN1CTXT* pctxt, RelocationRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationRequest_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationRequest_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequestIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationRequestIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationRequest_protocolIEs (ASN1CTXT* pctxt, RelocationRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationRequest_protocolIEs_element (pctxt, ((RelocationRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestExtensions_Extension *pvalue = (_RelocationRequestExtensions_Extension*) pvalue_;
   stat = asn1PE_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestExtensions_Extension_1 *pvalue = (_RelocationRequestExtensions_Extension_1*) pvalue_;
   stat = asn1PE_SNA_Access_Information (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension_2                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestExtensions_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestExtensions_Extension_2 *pvalue = (_RelocationRequestExtensions_Extension_2*) pvalue_;
   stat = asn1PE_UESBI_Iu (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension_3                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestExtensions_Extension_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestExtensions_Extension_3 value = *((_RelocationRequestExtensions_Extension_3*)pvalue_);
   stat = asn1PE_PLMNidentity (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs_element_iE_Extensions_elemen  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_JoinedMBMSBearerService_IEs_element_iE_Extensions_element (ASN1CTXT* pctxt, JoinedMBMSBearerService_IEs_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_JoinedMBMSBearerService_IEs_element_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs_element_iE_Extensions_elemen  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_JoinedMBMSBearerService_IEs_element_iE_Extensions_element (ASN1CTXT* pctxt,
   JoinedMBMSBearerService_IEs_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < JoinedMBMSBearerService_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &JoinedMBMSBearerService_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == JoinedMBMSBearerService_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = JoinedMBMSBearerService_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs_element_iE_Extensions         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_JoinedMBMSBearerService_IEs_element_iE_Extensions (ASN1CTXT* pctxt, JoinedMBMSBearerService_IEs_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_JoinedMBMSBearerService_IEs_element_iE_Extensions_element (pctxt, ((JoinedMBMSBearerService_IEs_element_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_JoinedMBMSBearerService_IEs_element (ASN1CTXT* pctxt, JoinedMBMSBearerService_IEs_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode tMGI */

   stat = asn1PE_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode mBMS_PTP_RAB_ID */

   stat = asn1PE_MBMS_PTP_RAB_ID (pctxt, &pvalue->mBMS_PTP_RAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_JoinedMBMSBearerService_IEs_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  JoinedMBMSBearerService_IEs                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_JoinedMBMSBearerService_IEs (ASN1CTXT* pctxt, JoinedMBMSBearerService_IEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_JoinedMBMSBearerService_IEs_element (pctxt, ((JoinedMBMSBearerService_IEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CNMBMSLinkingInformation_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CNMBMSLinkingInformation_iE_Extensions_element (ASN1CTXT* pctxt, CNMBMSLinkingInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_CNMBMSLinkingInformation_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CNMBMSLinkingInformation_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_CNMBMSLinkingInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   CNMBMSLinkingInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CNMBMSLinkingInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CNMBMSLinkingInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CNMBMSLinkingInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = CNMBMSLinkingInformation_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CNMBMSLinkingInformation_iE_Extensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CNMBMSLinkingInformation_iE_Extensions (ASN1CTXT* pctxt, CNMBMSLinkingInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_CNMBMSLinkingInformation_iE_Extensions_element (pctxt, ((CNMBMSLinkingInformation_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CNMBMSLinkingInformation                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CNMBMSLinkingInformation (ASN1CTXT* pctxt, CNMBMSLinkingInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode joinedMBMSBearerService_IEs */

   stat = asn1PE_JoinedMBMSBearerService_IEs (pctxt, &pvalue->joinedMBMSBearerService_IEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_CNMBMSLinkingInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestExtensions_Extension_4                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestExtensions_Extension_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestExtensions_Extension_4 *pvalue = (_RelocationRequestExtensions_Extension_4*) pvalue_;
   stat = asn1PE_CNMBMSLinkingInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationRequest_protocolExtensions_element (ASN1CTXT* pctxt, RelocationRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationRequest_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationRequestExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationRequest_protocolExtensions (ASN1CTXT* pctxt, RelocationRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationRequest_protocolExtensions_element (pctxt, ((RelocationRequest_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequest                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationRequest (ASN1CTXT* pctxt, RelocationRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_RelocationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_RelocationRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestAcknowledgeIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeIEs_Value *pvalue = (_RelocationRequestAcknowledgeIEs_Value*) pvalue_;
   stat = asn1PE_TargetRNC_ToSourceRNC_TransparentContainer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReqAck_ExtIEs_Extension               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_SetupItem_RelocReqAck_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReqAck_ExtIEs_Extension *pvalue = (_RAB_SetupItem_RelocReqAck_ExtIEs_Extension*) pvalue_;
   stat = asn1PE_Ass_RAB_Parameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1 value = *((_RAB_SetupItem_RelocReqAck_ExtIEs_Extension_1*)pvalue_);
   stat = asn1PE_TransportLayerAddress (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2 *pvalue = (_RAB_SetupItem_RelocReqAck_ExtIEs_Extension_2*) pvalue_;
   stat = asn1PE_IuTransportAssociation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReqAck_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupItem_RelocReqAck_iE_Extensions_element (ASN1CTXT* pctxt, RAB_SetupItem_RelocReqAck_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_SetupItem_RelocReqAck_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReqAck_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_SetupItem_RelocReqAck_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_SetupItem_RelocReqAck_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupItem_RelocReqAck_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupItem_RelocReqAck_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupItem_RelocReqAck_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_SetupItem_RelocReqAck_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReqAck_iE_Extensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupItem_RelocReqAck_iE_Extensions (ASN1CTXT* pctxt, RAB_SetupItem_RelocReqAck_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_SetupItem_RelocReqAck_iE_Extensions_element (pctxt, ((RAB_SetupItem_RelocReqAck_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupItem_RelocReqAck                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupItem_RelocReqAck (ASN1CTXT* pctxt, RAB_SetupItem_RelocReqAck* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transportLayerAddressPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iuTransportAssociationPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      stat = asn1PE_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iuTransportAssociation */

   if (pvalue->m.iuTransportAssociationPresent) {
      stat = asn1PE_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_SetupItem_RelocReqAck_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupItem_RelocReqAck_IEs_Value                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_SetupItem_RelocReqAck_IEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupItem_RelocReqAck_IEs_Value *pvalue = (_RAB_SetupItem_RelocReqAck_IEs_Value*) pvalue_;
   stat = asn1PE_RAB_SetupItem_RelocReqAck (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReqAck_element_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupList_RelocReqAck_element_element (ASN1CTXT* pctxt, RAB_SetupList_RelocReqAck_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_SetupList_RelocReqAck_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReqAck_element_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_SetupList_RelocReqAck_element_element (ASN1CTXT* pctxt,
   RAB_SetupList_RelocReqAck_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupItem_RelocReqAck_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupItem_RelocReqAck_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupItem_RelocReqAck_IEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_SetupItem_RelocReqAck_IEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReqAck_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupList_RelocReqAck_element (ASN1CTXT* pctxt, RAB_SetupList_RelocReqAck_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_SetupList_RelocReqAck_element_element (pctxt, ((RAB_SetupList_RelocReqAck_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupList_RelocReqAck                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupList_RelocReqAck (ASN1CTXT* pctxt, RAB_SetupList_RelocReqAck* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_SetupList_RelocReqAck_element (pctxt, ((RAB_SetupList_RelocReqAck_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestAcknowledgeIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeIEs_Value_1 *pvalue = (_RelocationRequestAcknowledgeIEs_Value_1*) pvalue_;
   stat = asn1PE_RAB_SetupList_RelocReqAck (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_FailedItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_FailedItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_FailedItem_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_FailedItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_FailedItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_FailedItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_FailedItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_FailedItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_FailedItem_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedItem_iE_Extensions                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_FailedItem_iE_Extensions (ASN1CTXT* pctxt, RAB_FailedItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_FailedItem_iE_Extensions_element (pctxt, ((RAB_FailedItem_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedItem                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_FailedItem (ASN1CTXT* pctxt, RAB_FailedItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode cause */

   stat = asn1PE_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_FailedItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_FailedItemIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_FailedItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_FailedItemIEs_Value *pvalue = (_RAB_FailedItemIEs_Value*) pvalue_;
   stat = asn1PE_RAB_FailedItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedList_element_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_FailedList_element_element (ASN1CTXT* pctxt, RAB_FailedList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_FailedList_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedList_element_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_FailedList_element_element (ASN1CTXT* pctxt,
   RAB_FailedList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_FailedItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_FailedItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_FailedItemIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_FailedItemIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedList_element                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_FailedList_element (ASN1CTXT* pctxt, RAB_FailedList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_FailedList_element_element (pctxt, ((RAB_FailedList_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedList                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_FailedList (ASN1CTXT* pctxt, RAB_FailedList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_FailedList_element (pctxt, ((RAB_FailedList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_2                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestAcknowledgeIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeIEs_Value_2 *pvalue = (_RelocationRequestAcknowledgeIEs_Value_2*) pvalue_;
   stat = asn1PE_RAB_FailedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_3                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestAcknowledgeIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeIEs_Value_3 value = *((_RelocationRequestAcknowledgeIEs_Value_3*)pvalue_);
   stat = asn1PE_ChosenIntegrityProtectionAlgorithm (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_4                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestAcknowledgeIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeIEs_Value_4 value = *((_RelocationRequestAcknowledgeIEs_Value_4*)pvalue_);
   stat = asn1PE_ChosenEncryptionAlgorithm (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeIEs_Value_5                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestAcknowledgeIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeIEs_Value_5 *pvalue = (_RelocationRequestAcknowledgeIEs_Value_5*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolIEs_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationRequestAcknowledge_protocolIEs_element (ASN1CTXT* pctxt, RelocationRequestAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationRequestAcknowledge_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolIEs_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationRequestAcknowledge_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationRequestAcknowledge_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationRequestAcknowledgeIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequestAcknowledgeIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequestAcknowledgeIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationRequestAcknowledgeIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolIEs                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationRequestAcknowledge_protocolIEs (ASN1CTXT* pctxt, RelocationRequestAcknowledge_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationRequestAcknowledge_protocolIEs_element (pctxt, ((RelocationRequestAcknowledge_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationRequestAcknowledgeExtensions_Extension         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationRequestAcknowledgeExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationRequestAcknowledgeExtensions_Extension value = *((_RelocationRequestAcknowledgeExtensions_Extension*)pvalue_);
   stat = asn1PE_NewBSS_To_OldBSS_Information (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationRequestAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt, RelocationRequestAcknowledge_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationRequestAcknowledge_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationRequestAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationRequestAcknowledge_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationRequestAcknowledgeExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationRequestAcknowledgeExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationRequestAcknowledgeExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationRequestAcknowledgeExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge_protocolExtensions           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationRequestAcknowledge_protocolExtensions (ASN1CTXT* pctxt, RelocationRequestAcknowledge_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationRequestAcknowledge_protocolExtensions_element (pctxt, ((RelocationRequestAcknowledge_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequestAcknowledge                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationRequestAcknowledge (ASN1CTXT* pctxt, RelocationRequestAcknowledge* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_RelocationRequestAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_RelocationRequestAcknowledge_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationFailureIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationFailureIEs_Value *pvalue = (_RelocationFailureIEs_Value*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationFailureIEs_Value_1                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationFailureIEs_Value_1 *pvalue = (_RelocationFailureIEs_Value_1*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationFailure_protocolIEs_element (ASN1CTXT* pctxt, RelocationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationFailure_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationFailure_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationFailureIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationFailureIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationFailure_protocolIEs (ASN1CTXT* pctxt, RelocationFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationFailure_protocolIEs_element (pctxt, ((RelocationFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationFailureExtensions_Extension                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationFailureExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationFailureExtensions_Extension value = *((_RelocationFailureExtensions_Extension*)pvalue_);
   stat = asn1PE_NewBSS_To_OldBSS_Information (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationFailureExtensions_Extension_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationFailureExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationFailureExtensions_Extension_1 value = *((_RelocationFailureExtensions_Extension_1*)pvalue_);
   stat = asn1PE_GERAN_Classmark (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationFailure_protocolExtensions_element (ASN1CTXT* pctxt, RelocationFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationFailure_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationFailureExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationFailure_protocolExtensions (ASN1CTXT* pctxt, RelocationFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationFailure_protocolExtensions_element (pctxt, ((RelocationFailure_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationFailure                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationFailure (ASN1CTXT* pctxt, RelocationFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_RelocationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_RelocationFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCancelIEs_Value                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationCancelIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCancelIEs_Value *pvalue = (_RelocationCancelIEs_Value*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationCancel_protocolIEs_element (ASN1CTXT* pctxt, RelocationCancel_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationCancel_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationCancel_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationCancel_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCancelIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCancelIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCancelIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationCancelIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolIEs                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationCancel_protocolIEs (ASN1CTXT* pctxt, RelocationCancel_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationCancel_protocolIEs_element (pctxt, ((RelocationCancel_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationCancel_protocolExtensions_element (ASN1CTXT* pctxt, RelocationCancel_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationCancel_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationCancel_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationCancel_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCancelExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCancelExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCancelExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationCancelExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel_protocolExtensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationCancel_protocolExtensions (ASN1CTXT* pctxt, RelocationCancel_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationCancel_protocolExtensions_element (pctxt, ((RelocationCancel_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancel                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationCancel (ASN1CTXT* pctxt, RelocationCancel* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_RelocationCancel_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_RelocationCancel_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RelocationCancelAcknowledgeIEs_Value                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RelocationCancelAcknowledgeIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RelocationCancelAcknowledgeIEs_Value *pvalue = (_RelocationCancelAcknowledgeIEs_Value*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolIEs_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationCancelAcknowledge_protocolIEs_element (ASN1CTXT* pctxt, RelocationCancelAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationCancelAcknowledge_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolIEs_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationCancelAcknowledge_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationCancelAcknowledge_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCancelAcknowledgeIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCancelAcknowledgeIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCancelAcknowledgeIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationCancelAcknowledgeIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolIEs                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationCancelAcknowledge_protocolIEs (ASN1CTXT* pctxt, RelocationCancelAcknowledge_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationCancelAcknowledge_protocolIEs_element (pctxt, ((RelocationCancelAcknowledge_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationCancelAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt, RelocationCancelAcknowledge_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationCancelAcknowledge_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationCancelAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationCancelAcknowledge_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCancelAcknowledgeExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCancelAcknowledgeExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCancelAcknowledgeExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationCancelAcknowledgeExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge_protocolExtensions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationCancelAcknowledge_protocolExtensions (ASN1CTXT* pctxt, RelocationCancelAcknowledge_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationCancelAcknowledge_protocolExtensions_element (pctxt, ((RelocationCancelAcknowledge_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationCancelAcknowledge                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationCancelAcknowledge (ASN1CTXT* pctxt, RelocationCancelAcknowledge* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_RelocationCancelAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_RelocationCancelAcknowledge_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element (ASN1CTXT* pctxt, RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_DataForwardingItem_SRNS_CtxReq_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions (ASN1CTXT* pctxt, RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element (pctxt, ((RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingItem_SRNS_CtxReq                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataForwardingItem_SRNS_CtxReq (ASN1CTXT* pctxt, RAB_DataForwardingItem_SRNS_CtxReq* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_DataForwardingItem_SRNS_CtxReq_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value *pvalue = (_RAB_DataForwardingItem_SRNS_CtxReq_IEs_Value*) pvalue_;
   stat = asn1PE_RAB_DataForwardingItem_SRNS_CtxReq (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_SRNS_CtxReq_element_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataForwardingList_SRNS_CtxReq_element_element (ASN1CTXT* pctxt, RAB_DataForwardingList_SRNS_CtxReq_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_DataForwardingList_SRNS_CtxReq_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_SRNS_CtxReq_element_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_DataForwardingList_SRNS_CtxReq_element_element (ASN1CTXT* pctxt,
   RAB_DataForwardingList_SRNS_CtxReq_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataForwardingItem_SRNS_CtxReq_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataForwardingItem_SRNS_CtxReq_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataForwardingItem_SRNS_CtxReq_IEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_DataForwardingItem_SRNS_CtxReq_IEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_SRNS_CtxReq_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataForwardingList_SRNS_CtxReq_element (ASN1CTXT* pctxt, RAB_DataForwardingList_SRNS_CtxReq_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_DataForwardingList_SRNS_CtxReq_element_element (pctxt, ((RAB_DataForwardingList_SRNS_CtxReq_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataForwardingList_SRNS_CtxReq                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataForwardingList_SRNS_CtxReq (ASN1CTXT* pctxt, RAB_DataForwardingList_SRNS_CtxReq* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_DataForwardingList_SRNS_CtxReq_element (pctxt, ((RAB_DataForwardingList_SRNS_CtxReq_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SRNS_ContextRequestIEs_Value                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__SRNS_ContextRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SRNS_ContextRequestIEs_Value *pvalue = (_SRNS_ContextRequestIEs_Value*) pvalue_;
   stat = asn1PE_RAB_DataForwardingList_SRNS_CtxReq (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRNS_ContextRequest_protocolIEs_element (ASN1CTXT* pctxt, SRNS_ContextRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SRNS_ContextRequest_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SRNS_ContextRequest_protocolIEs_element (ASN1CTXT* pctxt,
   SRNS_ContextRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRNS_ContextRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_ContextRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_ContextRequestIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SRNS_ContextRequestIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolIEs                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRNS_ContextRequest_protocolIEs (ASN1CTXT* pctxt, SRNS_ContextRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SRNS_ContextRequest_protocolIEs_element (pctxt, ((SRNS_ContextRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRNS_ContextRequest_protocolExtensions_element (ASN1CTXT* pctxt, SRNS_ContextRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SRNS_ContextRequest_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SRNS_ContextRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   SRNS_ContextRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRNS_ContextRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_ContextRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_ContextRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SRNS_ContextRequestExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest_protocolExtensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRNS_ContextRequest_protocolExtensions (ASN1CTXT* pctxt, SRNS_ContextRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SRNS_ContextRequest_protocolExtensions_element (pctxt, ((SRNS_ContextRequest_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextRequest                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRNS_ContextRequest (ASN1CTXT* pctxt, SRNS_ContextRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_SRNS_ContextRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_SRNS_ContextRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ContextItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_ContextItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_ContextItem_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_ContextItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_ContextItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ContextItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ContextItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ContextItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_ContextItem_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_iE_Extensions                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ContextItem_iE_Extensions (ASN1CTXT* pctxt, RAB_ContextItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ContextItem_iE_Extensions_element (pctxt, ((RAB_ContextItem_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ContextItem (ASN1CTXT* pctxt, RAB_ContextItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dl_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ul_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dl_N_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ul_N_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode dl_GTP_PDU_SequenceNumber */

   if (pvalue->m.dl_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PE_DL_GTP_PDU_SequenceNumber (pctxt, pvalue->dl_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode ul_GTP_PDU_SequenceNumber */

   if (pvalue->m.ul_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PE_UL_GTP_PDU_SequenceNumber (pctxt, pvalue->ul_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode dl_N_PDU_SequenceNumber */

   if (pvalue->m.dl_N_PDU_SequenceNumberPresent) {
      stat = asn1PE_DL_N_PDU_SequenceNumber (pctxt, pvalue->dl_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode ul_N_PDU_SequenceNumber */

   if (pvalue->m.ul_N_PDU_SequenceNumberPresent) {
      stat = asn1PE_UL_N_PDU_SequenceNumber (pctxt, pvalue->ul_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_ContextItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ContextItemIEs_Value                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_ContextItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ContextItemIEs_Value *pvalue = (_RAB_ContextItemIEs_Value*) pvalue_;
   stat = asn1PE_RAB_ContextItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_element_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ContextList_element_element (ASN1CTXT* pctxt, RAB_ContextList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_ContextList_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_element_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_ContextList_element_element (ASN1CTXT* pctxt,
   RAB_ContextList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ContextItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ContextItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ContextItemIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_ContextItemIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_element                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ContextList_element (ASN1CTXT* pctxt, RAB_ContextList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ContextList_element_element (pctxt, ((RAB_ContextList_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ContextList (ASN1CTXT* pctxt, RAB_ContextList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ContextList_element (pctxt, ((RAB_ContextList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SRNS_ContextResponseIEs_Value                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__SRNS_ContextResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SRNS_ContextResponseIEs_Value *pvalue = (_SRNS_ContextResponseIEs_Value*) pvalue_;
   stat = asn1PE_RAB_ContextList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RABs_ContextFailedtoTransferItem_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RABs_ContextFailedtoTransferItem_iE_Extensions_element (ASN1CTXT* pctxt, RABs_ContextFailedtoTransferItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RABs_ContextFailedtoTransferItem_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RABs_ContextFailedtoTransferItem_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RABs_ContextFailedtoTransferItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RABs_ContextFailedtoTransferItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RABs_ContextFailedtoTransferItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RABs_ContextFailedtoTransferItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RABs_ContextFailedtoTransferItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RABs_ContextFailedtoTransferItem_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RABs_ContextFailedtoTransferItem_iE_Extensions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RABs_ContextFailedtoTransferItem_iE_Extensions (ASN1CTXT* pctxt, RABs_ContextFailedtoTransferItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RABs_ContextFailedtoTransferItem_iE_Extensions_element (pctxt, ((RABs_ContextFailedtoTransferItem_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RABs_ContextFailedtoTransferItem                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RABs_ContextFailedtoTransferItem (ASN1CTXT* pctxt, RABs_ContextFailedtoTransferItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode cause */

   stat = asn1PE_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RABs_ContextFailedtoTransferItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RABs_ContextFailedtoTransferItemIEs_Value                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RABs_ContextFailedtoTransferItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RABs_ContextFailedtoTransferItemIEs_Value *pvalue = (_RABs_ContextFailedtoTransferItemIEs_Value*) pvalue_;
   stat = asn1PE_RABs_ContextFailedtoTransferItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextFailedtoTransferList_element_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ContextFailedtoTransferList_element_element (ASN1CTXT* pctxt, RAB_ContextFailedtoTransferList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_ContextFailedtoTransferList_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextFailedtoTransferList_element_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_ContextFailedtoTransferList_element_element (ASN1CTXT* pctxt,
   RAB_ContextFailedtoTransferList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RABs_ContextFailedtoTransferItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RABs_ContextFailedtoTransferItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RABs_ContextFailedtoTransferItemIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RABs_ContextFailedtoTransferItemIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextFailedtoTransferList_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ContextFailedtoTransferList_element (ASN1CTXT* pctxt, RAB_ContextFailedtoTransferList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ContextFailedtoTransferList_element_element (pctxt, ((RAB_ContextFailedtoTransferList_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextFailedtoTransferList                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ContextFailedtoTransferList (ASN1CTXT* pctxt, RAB_ContextFailedtoTransferList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ContextFailedtoTransferList_element (pctxt, ((RAB_ContextFailedtoTransferList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SRNS_ContextResponseIEs_Value_1                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__SRNS_ContextResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SRNS_ContextResponseIEs_Value_1 *pvalue = (_SRNS_ContextResponseIEs_Value_1*) pvalue_;
   stat = asn1PE_RAB_ContextFailedtoTransferList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SRNS_ContextResponseIEs_Value_2                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__SRNS_ContextResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SRNS_ContextResponseIEs_Value_2 *pvalue = (_SRNS_ContextResponseIEs_Value_2*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRNS_ContextResponse_protocolIEs_element (ASN1CTXT* pctxt, SRNS_ContextResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SRNS_ContextResponse_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SRNS_ContextResponse_protocolIEs_element (ASN1CTXT* pctxt,
   SRNS_ContextResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRNS_ContextResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_ContextResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_ContextResponseIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SRNS_ContextResponseIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolIEs                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRNS_ContextResponse_protocolIEs (ASN1CTXT* pctxt, SRNS_ContextResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SRNS_ContextResponse_protocolIEs_element (pctxt, ((SRNS_ContextResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRNS_ContextResponse_protocolExtensions_element (ASN1CTXT* pctxt, SRNS_ContextResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SRNS_ContextResponse_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SRNS_ContextResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   SRNS_ContextResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRNS_ContextResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_ContextResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_ContextResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SRNS_ContextResponseExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse_protocolExtensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRNS_ContextResponse_protocolExtensions (ASN1CTXT* pctxt, SRNS_ContextResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SRNS_ContextResponse_protocolExtensions_element (pctxt, ((SRNS_ContextResponse_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_ContextResponse                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRNS_ContextResponse (ASN1CTXT* pctxt, SRNS_ContextResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_SRNS_ContextResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_SRNS_ContextResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCommandIEs_Value                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__SecurityModeCommandIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeCommandIEs_Value *pvalue = (_SecurityModeCommandIEs_Value*) pvalue_;
   stat = asn1PE_IntegrityProtectionInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCommandIEs_Value_1                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__SecurityModeCommandIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeCommandIEs_Value_1 *pvalue = (_SecurityModeCommandIEs_Value_1*) pvalue_;
   stat = asn1PE_EncryptionInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCommandIEs_Value_2                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__SecurityModeCommandIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeCommandIEs_Value_2 value = *((_SecurityModeCommandIEs_Value_2*)pvalue_);
   stat = asn1PE_KeyStatus (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SecurityModeCommand_protocolIEs_element (ASN1CTXT* pctxt, SecurityModeCommand_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SecurityModeCommand_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SecurityModeCommand_protocolIEs_element (ASN1CTXT* pctxt,
   SecurityModeCommand_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SecurityModeCommandIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeCommandIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeCommandIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SecurityModeCommandIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolIEs                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SecurityModeCommand_protocolIEs (ASN1CTXT* pctxt, SecurityModeCommand_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SecurityModeCommand_protocolIEs_element (pctxt, ((SecurityModeCommand_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SecurityModeCommand_protocolExtensions_element (ASN1CTXT* pctxt, SecurityModeCommand_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SecurityModeCommand_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SecurityModeCommand_protocolExtensions_element (ASN1CTXT* pctxt,
   SecurityModeCommand_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SecurityModeCommandExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeCommandExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeCommandExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SecurityModeCommandExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand_protocolExtensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SecurityModeCommand_protocolExtensions (ASN1CTXT* pctxt, SecurityModeCommand_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SecurityModeCommand_protocolExtensions_element (pctxt, ((SecurityModeCommand_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeCommand                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SecurityModeCommand (ASN1CTXT* pctxt, SecurityModeCommand* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_SecurityModeCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_SecurityModeCommand_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCompleteIEs_Value                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__SecurityModeCompleteIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeCompleteIEs_Value value = *((_SecurityModeCompleteIEs_Value*)pvalue_);
   stat = asn1PE_ChosenIntegrityProtectionAlgorithm (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCompleteIEs_Value_1                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__SecurityModeCompleteIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeCompleteIEs_Value_1 value = *((_SecurityModeCompleteIEs_Value_1*)pvalue_);
   stat = asn1PE_ChosenEncryptionAlgorithm (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeCompleteIEs_Value_2                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__SecurityModeCompleteIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeCompleteIEs_Value_2 *pvalue = (_SecurityModeCompleteIEs_Value_2*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SecurityModeComplete_protocolIEs_element (ASN1CTXT* pctxt, SecurityModeComplete_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SecurityModeComplete_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SecurityModeComplete_protocolIEs_element (ASN1CTXT* pctxt,
   SecurityModeComplete_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SecurityModeCompleteIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeCompleteIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeCompleteIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SecurityModeCompleteIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolIEs                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SecurityModeComplete_protocolIEs (ASN1CTXT* pctxt, SecurityModeComplete_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SecurityModeComplete_protocolIEs_element (pctxt, ((SecurityModeComplete_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SecurityModeComplete_protocolExtensions_element (ASN1CTXT* pctxt, SecurityModeComplete_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SecurityModeComplete_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SecurityModeComplete_protocolExtensions_element (ASN1CTXT* pctxt,
   SecurityModeComplete_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SecurityModeCompleteExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeCompleteExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeCompleteExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SecurityModeCompleteExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete_protocolExtensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SecurityModeComplete_protocolExtensions (ASN1CTXT* pctxt, SecurityModeComplete_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SecurityModeComplete_protocolExtensions_element (pctxt, ((SecurityModeComplete_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeComplete                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SecurityModeComplete (ASN1CTXT* pctxt, SecurityModeComplete* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_SecurityModeComplete_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_SecurityModeComplete_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeRejectIEs_Value                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__SecurityModeRejectIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeRejectIEs_Value *pvalue = (_SecurityModeRejectIEs_Value*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SecurityModeRejectIEs_Value_1                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__SecurityModeRejectIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SecurityModeRejectIEs_Value_1 *pvalue = (_SecurityModeRejectIEs_Value_1*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SecurityModeReject_protocolIEs_element (ASN1CTXT* pctxt, SecurityModeReject_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SecurityModeReject_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SecurityModeReject_protocolIEs_element (ASN1CTXT* pctxt,
   SecurityModeReject_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SecurityModeRejectIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeRejectIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeRejectIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SecurityModeRejectIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolIEs                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SecurityModeReject_protocolIEs (ASN1CTXT* pctxt, SecurityModeReject_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SecurityModeReject_protocolIEs_element (pctxt, ((SecurityModeReject_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SecurityModeReject_protocolExtensions_element (ASN1CTXT* pctxt, SecurityModeReject_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SecurityModeReject_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SecurityModeReject_protocolExtensions_element (ASN1CTXT* pctxt,
   SecurityModeReject_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SecurityModeRejectExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SecurityModeRejectExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SecurityModeRejectExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SecurityModeRejectExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject_protocolExtensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SecurityModeReject_protocolExtensions (ASN1CTXT* pctxt, SecurityModeReject_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SecurityModeReject_protocolExtensions_element (pctxt, ((SecurityModeReject_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityModeReject                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SecurityModeReject (ASN1CTXT* pctxt, SecurityModeReject* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_SecurityModeReject_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_SecurityModeReject_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestItem_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataVolumeReportRequestItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_DataVolumeReportRequestItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_DataVolumeReportRequestItem_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestItem_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_DataVolumeReportRequestItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_DataVolumeReportRequestItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataVolumeReportRequestItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataVolumeReportRequestItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataVolumeReportRequestItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_DataVolumeReportRequestItem_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestItem_iE_Extensions             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataVolumeReportRequestItem_iE_Extensions (ASN1CTXT* pctxt, RAB_DataVolumeReportRequestItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_DataVolumeReportRequestItem_iE_Extensions_element (pctxt, ((RAB_DataVolumeReportRequestItem_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestItem                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataVolumeReportRequestItem (ASN1CTXT* pctxt, RAB_DataVolumeReportRequestItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_DataVolumeReportRequestItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_DataVolumeReportRequestItemIEs_Value                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_DataVolumeReportRequestItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_DataVolumeReportRequestItemIEs_Value *pvalue = (_RAB_DataVolumeReportRequestItemIEs_Value*) pvalue_;
   stat = asn1PE_RAB_DataVolumeReportRequestItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestList_element_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataVolumeReportRequestList_element_element (ASN1CTXT* pctxt, RAB_DataVolumeReportRequestList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_DataVolumeReportRequestList_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestList_element_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_DataVolumeReportRequestList_element_element (ASN1CTXT* pctxt,
   RAB_DataVolumeReportRequestList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_DataVolumeReportRequestItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_DataVolumeReportRequestItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_DataVolumeReportRequestItemIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_DataVolumeReportRequestItemIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestList_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataVolumeReportRequestList_element (ASN1CTXT* pctxt, RAB_DataVolumeReportRequestList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_DataVolumeReportRequestList_element_element (pctxt, ((RAB_DataVolumeReportRequestList_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_DataVolumeReportRequestList                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_DataVolumeReportRequestList (ASN1CTXT* pctxt, RAB_DataVolumeReportRequestList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_DataVolumeReportRequestList_element (pctxt, ((RAB_DataVolumeReportRequestList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DataVolumeReportRequestIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__DataVolumeReportRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DataVolumeReportRequestIEs_Value *pvalue = (_DataVolumeReportRequestIEs_Value*) pvalue_;
   stat = asn1PE_RAB_DataVolumeReportRequestList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DataVolumeReportRequest_protocolIEs_element (ASN1CTXT* pctxt, DataVolumeReportRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_DataVolumeReportRequest_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_DataVolumeReportRequest_protocolIEs_element (ASN1CTXT* pctxt,
   DataVolumeReportRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DataVolumeReportRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeReportRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeReportRequestIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = DataVolumeReportRequestIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolIEs                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DataVolumeReportRequest_protocolIEs (ASN1CTXT* pctxt, DataVolumeReportRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_DataVolumeReportRequest_protocolIEs_element (pctxt, ((DataVolumeReportRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DataVolumeReportRequest_protocolExtensions_element (ASN1CTXT* pctxt, DataVolumeReportRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_DataVolumeReportRequest_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_DataVolumeReportRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   DataVolumeReportRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DataVolumeReportRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeReportRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeReportRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = DataVolumeReportRequestExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest_protocolExtensions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DataVolumeReportRequest_protocolExtensions (ASN1CTXT* pctxt, DataVolumeReportRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_DataVolumeReportRequest_protocolExtensions_element (pctxt, ((DataVolumeReportRequest_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportRequest                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DataVolumeReportRequest (ASN1CTXT* pctxt, DataVolumeReportRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_DataVolumeReportRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_DataVolumeReportRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DataVolumeReportIEs_Value                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__DataVolumeReportIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DataVolumeReportIEs_Value *pvalue = (_DataVolumeReportIEs_Value*) pvalue_;
   stat = asn1PE_RAB_DataVolumeReportList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RABs_failed_to_reportItem_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RABs_failed_to_reportItem_iE_Extensions_element (ASN1CTXT* pctxt, RABs_failed_to_reportItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RABs_failed_to_reportItem_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RABs_failed_to_reportItem_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RABs_failed_to_reportItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RABs_failed_to_reportItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RABs_failed_to_reportItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RABs_failed_to_reportItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RABs_failed_to_reportItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RABs_failed_to_reportItem_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RABs_failed_to_reportItem_iE_Extensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RABs_failed_to_reportItem_iE_Extensions (ASN1CTXT* pctxt, RABs_failed_to_reportItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RABs_failed_to_reportItem_iE_Extensions_element (pctxt, ((RABs_failed_to_reportItem_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RABs_failed_to_reportItem                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RABs_failed_to_reportItem (ASN1CTXT* pctxt, RABs_failed_to_reportItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode cause */

   stat = asn1PE_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RABs_failed_to_reportItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RABs_failed_to_reportItemIEs_Value                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RABs_failed_to_reportItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RABs_failed_to_reportItemIEs_Value *pvalue = (_RABs_failed_to_reportItemIEs_Value*) pvalue_;
   stat = asn1PE_RABs_failed_to_reportItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedtoReportList_element_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_FailedtoReportList_element_element (ASN1CTXT* pctxt, RAB_FailedtoReportList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_FailedtoReportList_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedtoReportList_element_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_FailedtoReportList_element_element (ASN1CTXT* pctxt,
   RAB_FailedtoReportList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RABs_failed_to_reportItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RABs_failed_to_reportItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RABs_failed_to_reportItemIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RABs_failed_to_reportItemIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedtoReportList_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_FailedtoReportList_element (ASN1CTXT* pctxt, RAB_FailedtoReportList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_FailedtoReportList_element_element (pctxt, ((RAB_FailedtoReportList_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_FailedtoReportList                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_FailedtoReportList (ASN1CTXT* pctxt, RAB_FailedtoReportList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_FailedtoReportList_element (pctxt, ((RAB_FailedtoReportList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DataVolumeReportIEs_Value_1                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__DataVolumeReportIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DataVolumeReportIEs_Value_1 *pvalue = (_DataVolumeReportIEs_Value_1*) pvalue_;
   stat = asn1PE_RAB_FailedtoReportList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DataVolumeReportIEs_Value_2                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__DataVolumeReportIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DataVolumeReportIEs_Value_2 *pvalue = (_DataVolumeReportIEs_Value_2*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DataVolumeReport_protocolIEs_element (ASN1CTXT* pctxt, DataVolumeReport_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_DataVolumeReport_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_DataVolumeReport_protocolIEs_element (ASN1CTXT* pctxt,
   DataVolumeReport_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DataVolumeReportIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeReportIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeReportIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = DataVolumeReportIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolIEs                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DataVolumeReport_protocolIEs (ASN1CTXT* pctxt, DataVolumeReport_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_DataVolumeReport_protocolIEs_element (pctxt, ((DataVolumeReport_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DataVolumeReport_protocolExtensions_element (ASN1CTXT* pctxt, DataVolumeReport_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_DataVolumeReport_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_DataVolumeReport_protocolExtensions_element (ASN1CTXT* pctxt,
   DataVolumeReport_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DataVolumeReportExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DataVolumeReportExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == DataVolumeReportExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = DataVolumeReportExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport_protocolExtensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DataVolumeReport_protocolExtensions (ASN1CTXT* pctxt, DataVolumeReport_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_DataVolumeReport_protocolExtensions_element (pctxt, ((DataVolumeReport_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReport                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DataVolumeReport (ASN1CTXT* pctxt, DataVolumeReport* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_DataVolumeReport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_DataVolumeReport_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetIEs_Value                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetIEs_Value *pvalue = (_ResetIEs_Value*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetIEs_Value_1                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetIEs_Value_1 value = *((_ResetIEs_Value_1*)pvalue_);
   stat = asn1PE_CN_DomainIndicator (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetIEs_Value_2                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetIEs_Value_2 *pvalue = (_ResetIEs_Value_2*) pvalue_;
   stat = asn1PE_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolIEs_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Reset_protocolIEs_element (ASN1CTXT* pctxt, Reset_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_Reset_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolIEs_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_Reset_protocolIEs_element (ASN1CTXT* pctxt,
   Reset_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = ResetIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolIEs                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Reset_protocolIEs (ASN1CTXT* pctxt, Reset_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_Reset_protocolIEs_element (pctxt, ((Reset_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetExtensions_Extension                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetExtensions_Extension *pvalue = (_ResetExtensions_Extension*) pvalue_;
   stat = asn1PE_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolExtensions_element                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Reset_protocolExtensions_element (ASN1CTXT* pctxt, Reset_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_Reset_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolExtensions_element                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_Reset_protocolExtensions_element (ASN1CTXT* pctxt,
   Reset_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ResetExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = ResetExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Reset_protocolExtensions                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Reset_protocolExtensions (ASN1CTXT* pctxt, Reset_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_Reset_protocolExtensions_element (pctxt, ((Reset_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reset                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Reset (ASN1CTXT* pctxt, Reset* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_Reset_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_Reset_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetAcknowledgeIEs_Value                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetAcknowledgeIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetAcknowledgeIEs_Value value = *((_ResetAcknowledgeIEs_Value*)pvalue_);
   stat = asn1PE_CN_DomainIndicator (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetAcknowledgeIEs_Value_1                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetAcknowledgeIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetAcknowledgeIEs_Value_1 *pvalue = (_ResetAcknowledgeIEs_Value_1*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetAcknowledgeIEs_Value_2                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetAcknowledgeIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetAcknowledgeIEs_Value_2 *pvalue = (_ResetAcknowledgeIEs_Value_2*) pvalue_;
   stat = asn1PE_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetAcknowledge_protocolIEs_element (ASN1CTXT* pctxt, ResetAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_ResetAcknowledge_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_ResetAcknowledge_protocolIEs_element (ASN1CTXT* pctxt,
   ResetAcknowledge_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetAcknowledgeIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetAcknowledgeIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetAcknowledgeIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = ResetAcknowledgeIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolIEs                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetAcknowledge_protocolIEs (ASN1CTXT* pctxt, ResetAcknowledge_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_ResetAcknowledge_protocolIEs_element (pctxt, ((ResetAcknowledge_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetAcknowledgeExtensions_Extension                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetAcknowledgeExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetAcknowledgeExtensions_Extension *pvalue = (_ResetAcknowledgeExtensions_Extension*) pvalue_;
   stat = asn1PE_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt, ResetAcknowledge_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_ResetAcknowledge_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_ResetAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt,
   ResetAcknowledge_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetAcknowledgeExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetAcknowledgeExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ResetAcknowledgeExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = ResetAcknowledgeExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge_protocolExtensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetAcknowledge_protocolExtensions (ASN1CTXT* pctxt, ResetAcknowledge_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_ResetAcknowledge_protocolExtensions_element (pctxt, ((ResetAcknowledge_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetAcknowledge                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetAcknowledge (ASN1CTXT* pctxt, ResetAcknowledge* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_ResetAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_ResetAcknowledge_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseItem_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleaseItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_ReleaseItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_ReleaseItem_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseItem_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_ReleaseItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_ReleaseItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleaseItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleaseItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleaseItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_ReleaseItem_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseItem_iE_Extensions                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleaseItem_iE_Extensions (ASN1CTXT* pctxt, RAB_ReleaseItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ReleaseItem_iE_Extensions_element (pctxt, ((RAB_ReleaseItem_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseItem                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleaseItem (ASN1CTXT* pctxt, RAB_ReleaseItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode cause */

   stat = asn1PE_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_ReleaseItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ReleaseItemIEs_Value                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_ReleaseItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ReleaseItemIEs_Value *pvalue = (_RAB_ReleaseItemIEs_Value*) pvalue_;
   stat = asn1PE_RAB_ReleaseItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseList_element_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleaseList_element_element (ASN1CTXT* pctxt, RAB_ReleaseList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_ReleaseList_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseList_element_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_ReleaseList_element_element (ASN1CTXT* pctxt,
   RAB_ReleaseList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleaseItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleaseItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleaseItemIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_ReleaseItemIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseList_element                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleaseList_element (ASN1CTXT* pctxt, RAB_ReleaseList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ReleaseList_element_element (pctxt, ((RAB_ReleaseList_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseList                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleaseList (ASN1CTXT* pctxt, RAB_ReleaseList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ReleaseList_element (pctxt, ((RAB_ReleaseList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ReleaseRequestIEs_Value                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_ReleaseRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ReleaseRequestIEs_Value *pvalue = (_RAB_ReleaseRequestIEs_Value*) pvalue_;
   stat = asn1PE_RAB_ReleaseList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleaseRequest_protocolIEs_element (ASN1CTXT* pctxt, RAB_ReleaseRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_ReleaseRequest_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_ReleaseRequest_protocolIEs_element (ASN1CTXT* pctxt,
   RAB_ReleaseRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleaseRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleaseRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleaseRequestIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_ReleaseRequestIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolIEs                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleaseRequest_protocolIEs (ASN1CTXT* pctxt, RAB_ReleaseRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ReleaseRequest_protocolIEs_element (pctxt, ((RAB_ReleaseRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleaseRequest_protocolExtensions_element (ASN1CTXT* pctxt, RAB_ReleaseRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_ReleaseRequest_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_ReleaseRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   RAB_ReleaseRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleaseRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleaseRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleaseRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_ReleaseRequestExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest_protocolExtensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleaseRequest_protocolExtensions (ASN1CTXT* pctxt, RAB_ReleaseRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ReleaseRequest_protocolExtensions_element (pctxt, ((RAB_ReleaseRequest_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseRequest                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleaseRequest (ASN1CTXT* pctxt, RAB_ReleaseRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_RAB_ReleaseRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_RAB_ReleaseRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _Iu_ReleaseRequestIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__Iu_ReleaseRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Iu_ReleaseRequestIEs_Value *pvalue = (_Iu_ReleaseRequestIEs_Value*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Iu_ReleaseRequest_protocolIEs_element (ASN1CTXT* pctxt, Iu_ReleaseRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_Iu_ReleaseRequest_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_Iu_ReleaseRequest_protocolIEs_element (ASN1CTXT* pctxt,
   Iu_ReleaseRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Iu_ReleaseRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseRequestIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = Iu_ReleaseRequestIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Iu_ReleaseRequest_protocolIEs (ASN1CTXT* pctxt, Iu_ReleaseRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_Iu_ReleaseRequest_protocolIEs_element (pctxt, ((Iu_ReleaseRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Iu_ReleaseRequest_protocolExtensions_element (ASN1CTXT* pctxt, Iu_ReleaseRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_Iu_ReleaseRequest_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_Iu_ReleaseRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   Iu_ReleaseRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Iu_ReleaseRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Iu_ReleaseRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == Iu_ReleaseRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = Iu_ReleaseRequestExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Iu_ReleaseRequest_protocolExtensions (ASN1CTXT* pctxt, Iu_ReleaseRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_Iu_ReleaseRequest_protocolExtensions_element (pctxt, ((Iu_ReleaseRequest_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iu_ReleaseRequest                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Iu_ReleaseRequest (ASN1CTXT* pctxt, Iu_ReleaseRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_Iu_ReleaseRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_Iu_ReleaseRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationDetect_protocolIEs_element (ASN1CTXT* pctxt, RelocationDetect_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationDetect_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationDetect_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationDetect_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationDetectIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationDetectIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationDetectIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationDetectIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolIEs                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationDetect_protocolIEs (ASN1CTXT* pctxt, RelocationDetect_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationDetect_protocolIEs_element (pctxt, ((RelocationDetect_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationDetect_protocolExtensions_element (ASN1CTXT* pctxt, RelocationDetect_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationDetect_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationDetect_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationDetect_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationDetectExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationDetectExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationDetectExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationDetectExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect_protocolExtensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationDetect_protocolExtensions (ASN1CTXT* pctxt, RelocationDetect_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationDetect_protocolExtensions_element (pctxt, ((RelocationDetect_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationDetect                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationDetect (ASN1CTXT* pctxt, RelocationDetect* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_RelocationDetect_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_RelocationDetect_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationComplete_protocolIEs_element (ASN1CTXT* pctxt, RelocationComplete_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationComplete_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationComplete_protocolIEs_element (ASN1CTXT* pctxt,
   RelocationComplete_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCompleteIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCompleteIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCompleteIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationCompleteIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolIEs                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationComplete_protocolIEs (ASN1CTXT* pctxt, RelocationComplete_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationComplete_protocolIEs_element (pctxt, ((RelocationComplete_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationComplete_protocolExtensions_element (ASN1CTXT* pctxt, RelocationComplete_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RelocationComplete_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RelocationComplete_protocolExtensions_element (ASN1CTXT* pctxt,
   RelocationComplete_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RelocationCompleteExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RelocationCompleteExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RelocationCompleteExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RelocationCompleteExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete_protocolExtensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationComplete_protocolExtensions (ASN1CTXT* pctxt, RelocationComplete_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RelocationComplete_protocolExtensions_element (pctxt, ((RelocationComplete_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationComplete                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationComplete (ASN1CTXT* pctxt, RelocationComplete* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_RelocationComplete_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_RelocationComplete_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__PagingIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value value = *((_PagingIEs_Value*)pvalue_);
   stat = asn1PE_CN_DomainIndicator (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_1                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__PagingIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value_1 *pvalue = (_PagingIEs_Value_1*) pvalue_;
   stat = asn1PE_PermanentNAS_UE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_2                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__PagingIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value_2 *pvalue = (_PagingIEs_Value_2*) pvalue_;
   stat = asn1PE_TemporaryUE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_3                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__PagingIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value_3 *pvalue = (_PagingIEs_Value_3*) pvalue_;
   stat = asn1PE_PagingAreaID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_4                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__PagingIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value_4 value = *((_PagingIEs_Value_4*)pvalue_);
   stat = asn1PE_PagingCause (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_5                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__PagingIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value_5 value = *((_PagingIEs_Value_5*)pvalue_);
   stat = asn1PE_NonSearchingIndication (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingIEs_Value_6                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__PagingIEs_Value_6 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingIEs_Value_6 value = *((_PagingIEs_Value_6*)pvalue_);
   stat = asn1PE_DRX_CycleLengthCoefficient (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolIEs_element                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Paging_protocolIEs_element (ASN1CTXT* pctxt, Paging_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_Paging_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolIEs_element                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_Paging_protocolIEs_element (ASN1CTXT* pctxt,
   Paging_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < PagingIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &PagingIEs[index].id) == 0) {
         break;
      }
   }
   if(index == PagingIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = PagingIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolIEs                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Paging_protocolIEs (ASN1CTXT* pctxt, Paging_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_Paging_protocolIEs_element (pctxt, ((Paging_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _PagingExtensions_Extension                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__PagingExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PagingExtensions_Extension *pvalue = (_PagingExtensions_Extension*) pvalue_;
   stat = asn1PE_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolExtensions_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Paging_protocolExtensions_element (ASN1CTXT* pctxt, Paging_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_Paging_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolExtensions_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_Paging_protocolExtensions_element (ASN1CTXT* pctxt,
   Paging_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < PagingExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &PagingExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == PagingExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = PagingExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Paging_protocolExtensions                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Paging_protocolExtensions (ASN1CTXT* pctxt, Paging_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_Paging_protocolExtensions_element (pctxt, ((Paging_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Paging                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Paging (ASN1CTXT* pctxt, Paging* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_Paging_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_Paging_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CommonID_IEs_Value                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__CommonID_IEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CommonID_IEs_Value *pvalue = (_CommonID_IEs_Value*) pvalue_;
   stat = asn1PE_PermanentNAS_UE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolIEs_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CommonID_protocolIEs_element (ASN1CTXT* pctxt, CommonID_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_CommonID_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolIEs_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_CommonID_protocolIEs_element (ASN1CTXT* pctxt,
   CommonID_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CommonID_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CommonID_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == CommonID_IEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = CommonID_IEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolIEs                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CommonID_protocolIEs (ASN1CTXT* pctxt, CommonID_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_CommonID_protocolIEs_element (pctxt, ((CommonID_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CommonIDExtensions_Extension                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__CommonIDExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CommonIDExtensions_Extension *pvalue = (_CommonIDExtensions_Extension*) pvalue_;
   stat = asn1PE_SNA_Access_Information (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CommonIDExtensions_Extension_1                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__CommonIDExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CommonIDExtensions_Extension_1 *pvalue = (_CommonIDExtensions_Extension_1*) pvalue_;
   stat = asn1PE_UESBI_Iu (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CommonIDExtensions_Extension_2                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__CommonIDExtensions_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CommonIDExtensions_Extension_2 value = *((_CommonIDExtensions_Extension_2*)pvalue_);
   stat = asn1PE_PLMNidentity (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolExtensions_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CommonID_protocolExtensions_element (ASN1CTXT* pctxt, CommonID_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_CommonID_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolExtensions_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_CommonID_protocolExtensions_element (ASN1CTXT* pctxt,
   CommonID_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CommonIDExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CommonIDExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == CommonIDExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = CommonIDExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CommonID_protocolExtensions                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CommonID_protocolExtensions (ASN1CTXT* pctxt, CommonID_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_CommonID_protocolExtensions_element (pctxt, ((CommonID_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommonID                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CommonID (ASN1CTXT* pctxt, CommonID* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_CommonID_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_CommonID_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__CN_InvokeTraceIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_InvokeTraceIEs_Value *pvalue = (_CN_InvokeTraceIEs_Value*) pvalue_;
   stat = asn1PE_TraceType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value_1                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__CN_InvokeTraceIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_InvokeTraceIEs_Value_1 *pvalue = (_CN_InvokeTraceIEs_Value_1*) pvalue_;
   stat = asn1PE_TraceReference (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value_2                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__CN_InvokeTraceIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_InvokeTraceIEs_Value_2 *pvalue = (_CN_InvokeTraceIEs_Value_2*) pvalue_;
   stat = asn1PE_TriggerID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value_3                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__CN_InvokeTraceIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_InvokeTraceIEs_Value_3 *pvalue = (_CN_InvokeTraceIEs_Value_3*) pvalue_;
   stat = asn1PE_UE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceIEs_Value_4                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__CN_InvokeTraceIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_InvokeTraceIEs_Value_4 *pvalue = (_CN_InvokeTraceIEs_Value_4*) pvalue_;
   stat = asn1PE_OMC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CN_InvokeTrace_protocolIEs_element (ASN1CTXT* pctxt, CN_InvokeTrace_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_CN_InvokeTrace_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_CN_InvokeTrace_protocolIEs_element (ASN1CTXT* pctxt,
   CN_InvokeTrace_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CN_InvokeTraceIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CN_InvokeTraceIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CN_InvokeTraceIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = CN_InvokeTraceIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolIEs                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CN_InvokeTrace_protocolIEs (ASN1CTXT* pctxt, CN_InvokeTrace_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_CN_InvokeTrace_protocolIEs_element (pctxt, ((CN_InvokeTrace_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_InvokeTraceExtensions_Extension                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__CN_InvokeTraceExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_InvokeTraceExtensions_Extension *pvalue = (_CN_InvokeTraceExtensions_Extension*) pvalue_;
   stat = asn1PE_TracePropagationParameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CN_InvokeTrace_protocolExtensions_element (ASN1CTXT* pctxt, CN_InvokeTrace_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_CN_InvokeTrace_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_CN_InvokeTrace_protocolExtensions_element (ASN1CTXT* pctxt,
   CN_InvokeTrace_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CN_InvokeTraceExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CN_InvokeTraceExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == CN_InvokeTraceExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = CN_InvokeTraceExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace_protocolExtensions                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CN_InvokeTrace_protocolExtensions (ASN1CTXT* pctxt, CN_InvokeTrace_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_CN_InvokeTrace_protocolExtensions_element (pctxt, ((CN_InvokeTrace_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_InvokeTrace                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CN_InvokeTrace (ASN1CTXT* pctxt, CN_InvokeTrace* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_CN_InvokeTrace_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_CN_InvokeTrace_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_DeactivateTraceIEs_Value                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__CN_DeactivateTraceIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_DeactivateTraceIEs_Value *pvalue = (_CN_DeactivateTraceIEs_Value*) pvalue_;
   stat = asn1PE_TraceReference (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CN_DeactivateTraceIEs_Value_1                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__CN_DeactivateTraceIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CN_DeactivateTraceIEs_Value_1 *pvalue = (_CN_DeactivateTraceIEs_Value_1*) pvalue_;
   stat = asn1PE_TriggerID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CN_DeactivateTrace_protocolIEs_element (ASN1CTXT* pctxt, CN_DeactivateTrace_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_CN_DeactivateTrace_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolIEs_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_CN_DeactivateTrace_protocolIEs_element (ASN1CTXT* pctxt,
   CN_DeactivateTrace_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CN_DeactivateTraceIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CN_DeactivateTraceIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CN_DeactivateTraceIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = CN_DeactivateTraceIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolIEs                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CN_DeactivateTrace_protocolIEs (ASN1CTXT* pctxt, CN_DeactivateTrace_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_CN_DeactivateTrace_protocolIEs_element (pctxt, ((CN_DeactivateTrace_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CN_DeactivateTrace_protocolExtensions_element (ASN1CTXT* pctxt, CN_DeactivateTrace_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_CN_DeactivateTrace_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolExtensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_CN_DeactivateTrace_protocolExtensions_element (ASN1CTXT* pctxt,
   CN_DeactivateTrace_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CN_DeactivateTraceExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CN_DeactivateTraceExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == CN_DeactivateTraceExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = CN_DeactivateTraceExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace_protocolExtensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CN_DeactivateTrace_protocolExtensions (ASN1CTXT* pctxt, CN_DeactivateTrace_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_CN_DeactivateTrace_protocolExtensions_element (pctxt, ((CN_DeactivateTrace_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_DeactivateTrace                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CN_DeactivateTrace (ASN1CTXT* pctxt, CN_DeactivateTrace* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_CN_DeactivateTrace_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_CN_DeactivateTrace_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlIEs_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__LocationReportingControlIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportingControlIEs_Value *pvalue = (_LocationReportingControlIEs_Value*) pvalue_;
   stat = asn1PE_RequestType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationReportingControl_protocolIEs_element (ASN1CTXT* pctxt, LocationReportingControl_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_LocationReportingControl_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_LocationReportingControl_protocolIEs_element (ASN1CTXT* pctxt,
   LocationReportingControl_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationReportingControlIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationReportingControlIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationReportingControlIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = LocationReportingControlIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolIEs                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationReportingControl_protocolIEs (ASN1CTXT* pctxt, LocationReportingControl_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_LocationReportingControl_protocolIEs_element (pctxt, ((LocationReportingControl_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlExtensions_Extension             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__LocationReportingControlExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportingControlExtensions_Extension value = *((_LocationReportingControlExtensions_Extension*)pvalue_);
   stat = asn1PE_VerticalAccuracyCode (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlExtensions_Extension_1           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__LocationReportingControlExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportingControlExtensions_Extension_1 value = *((_LocationReportingControlExtensions_Extension_1*)pvalue_);
   stat = asn1PE_ResponseTime (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlExtensions_Extension_2           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__LocationReportingControlExtensions_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportingControlExtensions_Extension_2 value = *((_LocationReportingControlExtensions_Extension_2*)pvalue_);
   stat = asn1PE_PositioningPriority (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportingControlExtensions_Extension_3           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__LocationReportingControlExtensions_Extension_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportingControlExtensions_Extension_3 value = *((_LocationReportingControlExtensions_Extension_3*)pvalue_);
   stat = asn1PE_ClientType (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationReportingControl_protocolExtensions_element (ASN1CTXT* pctxt, LocationReportingControl_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_LocationReportingControl_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_LocationReportingControl_protocolExtensions_element (ASN1CTXT* pctxt,
   LocationReportingControl_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationReportingControlExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationReportingControlExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationReportingControlExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = LocationReportingControlExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl_protocolExtensions               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationReportingControl_protocolExtensions (ASN1CTXT* pctxt, LocationReportingControl_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_LocationReportingControl_protocolExtensions_element (pctxt, ((LocationReportingControl_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReportingControl                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationReportingControl (ASN1CTXT* pctxt, LocationReportingControl* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_LocationReportingControl_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_LocationReportingControl_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__LocationReportIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportIEs_Value *pvalue = (_LocationReportIEs_Value*) pvalue_;
   stat = asn1PE_AreaIdentity (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportIEs_Value_1                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__LocationReportIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportIEs_Value_1 *pvalue = (_LocationReportIEs_Value_1*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportIEs_Value_2                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__LocationReportIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportIEs_Value_2 *pvalue = (_LocationReportIEs_Value_2*) pvalue_;
   stat = asn1PE_RequestType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationReport_protocolIEs_element (ASN1CTXT* pctxt, LocationReport_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_LocationReport_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_LocationReport_protocolIEs_element (ASN1CTXT* pctxt,
   LocationReport_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationReportIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationReportIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationReportIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = LocationReportIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolIEs                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationReport_protocolIEs (ASN1CTXT* pctxt, LocationReport_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_LocationReport_protocolIEs_element (pctxt, ((LocationReport_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportExtensions_Extension                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__LocationReportExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportExtensions_Extension *pvalue = (_LocationReportExtensions_Extension*) pvalue_;
   stat = asn1PE_LastKnownServiceArea (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportExtensions_Extension_1                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__LocationReportExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportExtensions_Extension_1 *pvalue = (_LocationReportExtensions_Extension_1*) pvalue_;
   stat = asn1PE_PositionData (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportExtensions_Extension_2                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__LocationReportExtensions_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportExtensions_Extension_2 value = *((_LocationReportExtensions_Extension_2*)pvalue_);
   stat = asn1PE_PositionDataSpecificToGERANIuMode (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationReportExtensions_Extension_3                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__LocationReportExtensions_Extension_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationReportExtensions_Extension_3 value = *((_LocationReportExtensions_Extension_3*)pvalue_);
   stat = asn1PE_AccuracyFulfilmentIndicator (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationReport_protocolExtensions_element (ASN1CTXT* pctxt, LocationReport_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_LocationReport_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_LocationReport_protocolExtensions_element (ASN1CTXT* pctxt,
   LocationReport_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationReportExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationReportExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationReportExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = LocationReportExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationReport_protocolExtensions                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationReport_protocolExtensions (ASN1CTXT* pctxt, LocationReport_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_LocationReport_protocolExtensions_element (pctxt, ((LocationReport_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationReport                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationReport (ASN1CTXT* pctxt, LocationReport* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_LocationReport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_LocationReport_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InitialUE_MessageIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value value = *((_InitialUE_MessageIEs_Value*)pvalue_);
   stat = asn1PE_CN_DomainIndicator (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_1                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InitialUE_MessageIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value_1 *pvalue = (_InitialUE_MessageIEs_Value_1*) pvalue_;
   stat = asn1PE_LAI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_2                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InitialUE_MessageIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value_2 *pvalue = (_InitialUE_MessageIEs_Value_2*) pvalue_;
   stat = asn1PE_RAC (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_3                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InitialUE_MessageIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value_3 *pvalue = (_InitialUE_MessageIEs_Value_3*) pvalue_;
   stat = asn1PE_SAI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_4                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InitialUE_MessageIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value_4 value = *((_InitialUE_MessageIEs_Value_4*)pvalue_);
   stat = asn1PE_NAS_PDU (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_5                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InitialUE_MessageIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value_5 *pvalue = (_InitialUE_MessageIEs_Value_5*) pvalue_;
   stat = asn1PE_IuSignallingConnectionIdentifier (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageIEs_Value_6                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InitialUE_MessageIEs_Value_6 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageIEs_Value_6 *pvalue = (_InitialUE_MessageIEs_Value_6*) pvalue_;
   stat = asn1PE_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InitialUE_Message_protocolIEs_element (ASN1CTXT* pctxt, InitialUE_Message_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_InitialUE_Message_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_InitialUE_Message_protocolIEs_element (ASN1CTXT* pctxt,
   InitialUE_Message_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InitialUE_MessageIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InitialUE_MessageIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InitialUE_MessageIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = InitialUE_MessageIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InitialUE_Message_protocolIEs (ASN1CTXT* pctxt, InitialUE_Message_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_InitialUE_Message_protocolIEs_element (pctxt, ((InitialUE_Message_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageExtensions_Extension                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InitialUE_MessageExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageExtensions_Extension value = *((_InitialUE_MessageExtensions_Extension*)pvalue_);
   stat = asn1PE_GERAN_Classmark (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageExtensions_Extension_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InitialUE_MessageExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageExtensions_Extension_1 value = *((_InitialUE_MessageExtensions_Extension_1*)pvalue_);
   stat = asn1PE_PLMNidentity (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageExtensions_Extension_2                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InitialUE_MessageExtensions_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageExtensions_Extension_2 *pvalue = (_InitialUE_MessageExtensions_Extension_2*) pvalue_;
   stat = asn1PE_PermanentNAS_UE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InitialUE_MessageExtensions_Extension_3                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InitialUE_MessageExtensions_Extension_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InitialUE_MessageExtensions_Extension_3 *pvalue = (_InitialUE_MessageExtensions_Extension_3*) pvalue_;
   stat = asn1PE_NAS_SequenceNumber (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InitialUE_Message_protocolExtensions_element (ASN1CTXT* pctxt, InitialUE_Message_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_InitialUE_Message_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_InitialUE_Message_protocolExtensions_element (ASN1CTXT* pctxt,
   InitialUE_Message_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InitialUE_MessageExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InitialUE_MessageExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == InitialUE_MessageExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = InitialUE_MessageExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InitialUE_Message_protocolExtensions (ASN1CTXT* pctxt, InitialUE_Message_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_InitialUE_Message_protocolExtensions_element (pctxt, ((InitialUE_Message_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InitialUE_Message                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InitialUE_Message (ASN1CTXT* pctxt, InitialUE_Message* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_InitialUE_Message_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_InitialUE_Message_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__DirectTransferIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferIEs_Value value = *((_DirectTransferIEs_Value*)pvalue_);
   stat = asn1PE_NAS_PDU (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value_1                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__DirectTransferIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferIEs_Value_1 *pvalue = (_DirectTransferIEs_Value_1*) pvalue_;
   stat = asn1PE_LAI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value_2                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__DirectTransferIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferIEs_Value_2 *pvalue = (_DirectTransferIEs_Value_2*) pvalue_;
   stat = asn1PE_RAC (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value_3                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__DirectTransferIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferIEs_Value_3 *pvalue = (_DirectTransferIEs_Value_3*) pvalue_;
   stat = asn1PE_SAI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferIEs_Value_4                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__DirectTransferIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferIEs_Value_4 value = *((_DirectTransferIEs_Value_4*)pvalue_);
   stat = asn1PE_SAPI (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DirectTransfer_protocolIEs_element (ASN1CTXT* pctxt, DirectTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_DirectTransfer_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_DirectTransfer_protocolIEs_element (ASN1CTXT* pctxt,
   DirectTransfer_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DirectTransferIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectTransferIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DirectTransferIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = DirectTransferIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolIEs                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DirectTransfer_protocolIEs (ASN1CTXT* pctxt, DirectTransfer_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_DirectTransfer_protocolIEs_element (pctxt, ((DirectTransfer_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RedirectionIndication_IEs_Value                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RedirectionIndication_IEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RedirectionIndication_IEs_Value value = *((_RedirectionIndication_IEs_Value*)pvalue_);
   stat = asn1PE_NAS_PDU (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RedirectionIndication_IEs_Value_1                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RedirectionIndication_IEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RedirectionIndication_IEs_Value_1 value = *((_RedirectionIndication_IEs_Value_1*)pvalue_);
   stat = asn1PE_RejectCauseValue (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RedirectionIndication_IEs_Value_2                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RedirectionIndication_IEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RedirectionIndication_IEs_Value_2 *pvalue = (_RedirectionIndication_IEs_Value_2*) pvalue_;
   stat = asn1PE_NAS_SequenceNumber (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RedirectionIndication_IEs_Value_3                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RedirectionIndication_IEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RedirectionIndication_IEs_Value_3 *pvalue = (_RedirectionIndication_IEs_Value_3*) pvalue_;
   stat = asn1PE_PermanentNAS_UE_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedirectionIndication_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RedirectionIndication_element (ASN1CTXT* pctxt, RedirectionIndication_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RedirectionIndication_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedirectionIndication_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RedirectionIndication_element (ASN1CTXT* pctxt,
   RedirectionIndication_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RedirectionIndication_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RedirectionIndication_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RedirectionIndication_IEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RedirectionIndication_IEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RedirectionIndication                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RedirectionIndication (ASN1CTXT* pctxt, RedirectionIndication* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RedirectionIndication_element (pctxt, ((RedirectionIndication_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferExtensions_Extension                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__DirectTransferExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferExtensions_Extension *pvalue = (_DirectTransferExtensions_Extension*) pvalue_;
   stat = asn1PE_RedirectionIndication (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferExtensions_Extension_1                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__DirectTransferExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferExtensions_Extension_1 value = *((_DirectTransferExtensions_Extension_1*)pvalue_);
   stat = asn1PE_RedirectionCompleted (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DirectTransfer_protocolExtensions_element (ASN1CTXT* pctxt, DirectTransfer_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_DirectTransfer_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_DirectTransfer_protocolExtensions_element (ASN1CTXT* pctxt,
   DirectTransfer_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DirectTransferExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectTransferExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == DirectTransferExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = DirectTransferExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer_protocolExtensions                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DirectTransfer_protocolExtensions (ASN1CTXT* pctxt, DirectTransfer_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_DirectTransfer_protocolExtensions_element (pctxt, ((DirectTransfer_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransfer                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DirectTransfer (ASN1CTXT* pctxt, DirectTransfer* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_DirectTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_DirectTransfer_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _OverloadIEs_Value                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__OverloadIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _OverloadIEs_Value value = *((_OverloadIEs_Value*)pvalue_);
   stat = asn1PE_NumberOfSteps (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _OverloadIEs_Value_1                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__OverloadIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _OverloadIEs_Value_1 *pvalue = (_OverloadIEs_Value_1*) pvalue_;
   stat = asn1PE_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolIEs_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Overload_protocolIEs_element (ASN1CTXT* pctxt, Overload_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_Overload_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolIEs_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_Overload_protocolIEs_element (ASN1CTXT* pctxt,
   Overload_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < OverloadIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &OverloadIEs[index].id) == 0) {
         break;
      }
   }
   if(index == OverloadIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = OverloadIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolIEs                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Overload_protocolIEs (ASN1CTXT* pctxt, Overload_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_Overload_protocolIEs_element (pctxt, ((Overload_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _OverloadExtensions_Extension                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__OverloadExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _OverloadExtensions_Extension value = *((_OverloadExtensions_Extension*)pvalue_);
   stat = asn1PE_CN_DomainIndicator (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _OverloadExtensions_Extension_1                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__OverloadExtensions_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _OverloadExtensions_Extension_1 *pvalue = (_OverloadExtensions_Extension_1*) pvalue_;
   stat = asn1PE_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolExtensions_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Overload_protocolExtensions_element (ASN1CTXT* pctxt, Overload_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_Overload_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolExtensions_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_Overload_protocolExtensions_element (ASN1CTXT* pctxt,
   Overload_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < OverloadExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &OverloadExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == OverloadExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = OverloadExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Overload_protocolExtensions                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Overload_protocolExtensions (ASN1CTXT* pctxt, Overload_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_Overload_protocolExtensions_element (pctxt, ((Overload_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Overload                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Overload (ASN1CTXT* pctxt, Overload* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_Overload_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_Overload_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationIEs_Value                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ErrorIndicationIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ErrorIndicationIEs_Value *pvalue = (_ErrorIndicationIEs_Value*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationIEs_Value_1                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ErrorIndicationIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ErrorIndicationIEs_Value_1 *pvalue = (_ErrorIndicationIEs_Value_1*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationIEs_Value_2                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ErrorIndicationIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ErrorIndicationIEs_Value_2 value = *((_ErrorIndicationIEs_Value_2*)pvalue_);
   stat = asn1PE_CN_DomainIndicator (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationIEs_Value_3                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ErrorIndicationIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ErrorIndicationIEs_Value_3 *pvalue = (_ErrorIndicationIEs_Value_3*) pvalue_;
   stat = asn1PE_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolIEs_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ErrorIndication_protocolIEs_element (ASN1CTXT* pctxt, ErrorIndication_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_ErrorIndication_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolIEs_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_ErrorIndication_protocolIEs_element (ASN1CTXT* pctxt,
   ErrorIndication_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ErrorIndicationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ErrorIndicationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ErrorIndicationIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = ErrorIndicationIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolIEs                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ErrorIndication_protocolIEs (ASN1CTXT* pctxt, ErrorIndication_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_ErrorIndication_protocolIEs_element (pctxt, ((ErrorIndication_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ErrorIndicationExtensions_Extension                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ErrorIndicationExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ErrorIndicationExtensions_Extension *pvalue = (_ErrorIndicationExtensions_Extension*) pvalue_;
   stat = asn1PE_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolExtensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ErrorIndication_protocolExtensions_element (ASN1CTXT* pctxt, ErrorIndication_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_ErrorIndication_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolExtensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_ErrorIndication_protocolExtensions_element (ASN1CTXT* pctxt,
   ErrorIndication_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ErrorIndicationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ErrorIndicationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ErrorIndicationExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = ErrorIndicationExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication_protocolExtensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ErrorIndication_protocolExtensions (ASN1CTXT* pctxt, ErrorIndication_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_ErrorIndication_protocolExtensions_element (pctxt, ((ErrorIndication_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ErrorIndication                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ErrorIndication (ASN1CTXT* pctxt, ErrorIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_ErrorIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_ErrorIndication_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SRNS_DataForwardCommandIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__SRNS_DataForwardCommandIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SRNS_DataForwardCommandIEs_Value *pvalue = (_SRNS_DataForwardCommandIEs_Value*) pvalue_;
   stat = asn1PE_RAB_DataForwardingList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRNS_DataForwardCommand_protocolIEs_element (ASN1CTXT* pctxt, SRNS_DataForwardCommand_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SRNS_DataForwardCommand_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SRNS_DataForwardCommand_protocolIEs_element (ASN1CTXT* pctxt,
   SRNS_DataForwardCommand_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRNS_DataForwardCommandIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_DataForwardCommandIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_DataForwardCommandIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SRNS_DataForwardCommandIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolIEs                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRNS_DataForwardCommand_protocolIEs (ASN1CTXT* pctxt, SRNS_DataForwardCommand_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SRNS_DataForwardCommand_protocolIEs_element (pctxt, ((SRNS_DataForwardCommand_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRNS_DataForwardCommand_protocolExtensions_element (ASN1CTXT* pctxt, SRNS_DataForwardCommand_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SRNS_DataForwardCommand_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SRNS_DataForwardCommand_protocolExtensions_element (ASN1CTXT* pctxt,
   SRNS_DataForwardCommand_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRNS_DataForwardCommandExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRNS_DataForwardCommandExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == SRNS_DataForwardCommandExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SRNS_DataForwardCommandExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand_protocolExtensions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRNS_DataForwardCommand_protocolExtensions (ASN1CTXT* pctxt, SRNS_DataForwardCommand_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SRNS_DataForwardCommand_protocolExtensions_element (pctxt, ((SRNS_DataForwardCommand_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRNS_DataForwardCommand                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRNS_DataForwardCommand (ASN1CTXT* pctxt, SRNS_DataForwardCommand* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_SRNS_DataForwardCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_SRNS_DataForwardCommand_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ForwardSRNS_ContextIEs_Value                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ForwardSRNS_ContextIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ForwardSRNS_ContextIEs_Value *pvalue = (_ForwardSRNS_ContextIEs_Value*) pvalue_;
   stat = asn1PE_RAB_ContextList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ForwardSRNS_Context_protocolIEs_element (ASN1CTXT* pctxt, ForwardSRNS_Context_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_ForwardSRNS_Context_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolIEs_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_ForwardSRNS_Context_protocolIEs_element (ASN1CTXT* pctxt,
   ForwardSRNS_Context_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ForwardSRNS_ContextIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ForwardSRNS_ContextIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ForwardSRNS_ContextIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = ForwardSRNS_ContextIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolIEs                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ForwardSRNS_Context_protocolIEs (ASN1CTXT* pctxt, ForwardSRNS_Context_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_ForwardSRNS_Context_protocolIEs_element (pctxt, ((ForwardSRNS_Context_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ForwardSRNS_ContextExtensions_Extension                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ForwardSRNS_ContextExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ForwardSRNS_ContextExtensions_Extension value = *((_ForwardSRNS_ContextExtensions_Extension*)pvalue_);
   stat = asn1PE_RRC_Container (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ForwardSRNS_Context_protocolExtensions_element (ASN1CTXT* pctxt, ForwardSRNS_Context_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_ForwardSRNS_Context_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolExtensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_ForwardSRNS_Context_protocolExtensions_element (ASN1CTXT* pctxt,
   ForwardSRNS_Context_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ForwardSRNS_ContextExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ForwardSRNS_ContextExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ForwardSRNS_ContextExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = ForwardSRNS_ContextExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context_protocolExtensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ForwardSRNS_Context_protocolExtensions (ASN1CTXT* pctxt, ForwardSRNS_Context_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_ForwardSRNS_Context_protocolExtensions_element (pctxt, ((ForwardSRNS_Context_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ForwardSRNS_Context                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ForwardSRNS_Context (ASN1CTXT* pctxt, ForwardSRNS_Context* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_ForwardSRNS_Context_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_ForwardSRNS_Context_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportLayerInformation_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportLayerInformation_iE_Extensions_element (ASN1CTXT* pctxt, TransportLayerInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_TransportLayerInformation_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportLayerInformation_iE_Extensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_TransportLayerInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   TransportLayerInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TransportLayerInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TransportLayerInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TransportLayerInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = TransportLayerInformation_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TransportLayerInformation_iE_Extensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportLayerInformation_iE_Extensions (ASN1CTXT* pctxt, TransportLayerInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_TransportLayerInformation_iE_Extensions_element (pctxt, ((TransportLayerInformation_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportLayerInformation                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportLayerInformation (ASN1CTXT* pctxt, TransportLayerInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode transportLayerAddress */

   stat = asn1PE_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iuTransportAssociation */

   stat = asn1PE_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_TransportLayerInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemFirst_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupOrModifyItemFirst_iE_Extensions_element (ASN1CTXT* pctxt, RAB_SetupOrModifyItemFirst_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_SetupOrModifyItemFirst_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemFirst_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_SetupOrModifyItemFirst_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_SetupOrModifyItemFirst_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupOrModifyItemFirst_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifyItemFirst_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifyItemFirst_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_SetupOrModifyItemFirst_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemFirst_iE_Extensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupOrModifyItemFirst_iE_Extensions (ASN1CTXT* pctxt, RAB_SetupOrModifyItemFirst_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_SetupOrModifyItemFirst_iE_Extensions_element (pctxt, ((RAB_SetupOrModifyItemFirst_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemFirst                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupOrModifyItemFirst (ASN1CTXT* pctxt, RAB_SetupOrModifyItemFirst* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.nAS_SynchronisationIndicatorPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.rAB_ParametersPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.userPlaneInformationPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transportLayerInformationPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.service_HandoverPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode nAS_SynchronisationIndicator */

   if (pvalue->m.nAS_SynchronisationIndicatorPresent) {
      stat = asn1PE_NAS_SynchronisationIndicator (pctxt, &pvalue->nAS_SynchronisationIndicator);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode rAB_Parameters */

   if (pvalue->m.rAB_ParametersPresent) {
      stat = asn1PE_RAB_Parameters (pctxt, &pvalue->rAB_Parameters);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode userPlaneInformation */

   if (pvalue->m.userPlaneInformationPresent) {
      stat = asn1PE_UserPlaneInformation (pctxt, &pvalue->userPlaneInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode transportLayerInformation */

   if (pvalue->m.transportLayerInformationPresent) {
      stat = asn1PE_TransportLayerInformation (pctxt, &pvalue->transportLayerInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode service_Handover */

   if (pvalue->m.service_HandoverPresent) {
      stat = asn1PE_Service_Handover (pctxt, pvalue->service_Handover);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_SetupOrModifyItemFirst_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifyItem_IEs_FirstValue                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_SetupOrModifyItem_IEs_FirstValue (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupOrModifyItem_IEs_FirstValue *pvalue = (_RAB_SetupOrModifyItem_IEs_FirstValue*) pvalue_;
   stat = asn1PE_RAB_SetupOrModifyItemFirst (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifyItemSecond_ExtIEs_Extension             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_SetupOrModifyItemSecond_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupOrModifyItemSecond_ExtIEs_Extension *pvalue = (_RAB_SetupOrModifyItemSecond_ExtIEs_Extension*) pvalue_;
   stat = asn1PE_Alt_RAB_Parameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1 value = *((_RAB_SetupOrModifyItemSecond_ExtIEs_Extension_1*)pvalue_);
   stat = asn1PE_GERAN_BSC_Container (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemSecond_iE_Extensions_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupOrModifyItemSecond_iE_Extensions_element (ASN1CTXT* pctxt, RAB_SetupOrModifyItemSecond_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_SetupOrModifyItemSecond_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemSecond_iE_Extensions_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_SetupOrModifyItemSecond_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_SetupOrModifyItemSecond_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupOrModifyItemSecond_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifyItemSecond_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifyItemSecond_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_SetupOrModifyItemSecond_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemSecond_iE_Extensions                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupOrModifyItemSecond_iE_Extensions (ASN1CTXT* pctxt, RAB_SetupOrModifyItemSecond_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_SetupOrModifyItemSecond_iE_Extensions_element (pctxt, ((RAB_SetupOrModifyItemSecond_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyItemSecond                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupOrModifyItemSecond (ASN1CTXT* pctxt, RAB_SetupOrModifyItemSecond* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.pDP_TypeInformationPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dataVolumeReportingIndicationPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dl_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ul_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dl_N_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ul_N_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode pDP_TypeInformation */

   if (pvalue->m.pDP_TypeInformationPresent) {
      stat = asn1PE_PDP_TypeInformation (pctxt, &pvalue->pDP_TypeInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode dataVolumeReportingIndication */

   if (pvalue->m.dataVolumeReportingIndicationPresent) {
      stat = asn1PE_DataVolumeReportingIndication (pctxt, pvalue->dataVolumeReportingIndication);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode dl_GTP_PDU_SequenceNumber */

   if (pvalue->m.dl_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PE_DL_GTP_PDU_SequenceNumber (pctxt, pvalue->dl_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode ul_GTP_PDU_SequenceNumber */

   if (pvalue->m.ul_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PE_UL_GTP_PDU_SequenceNumber (pctxt, pvalue->ul_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode dl_N_PDU_SequenceNumber */

   if (pvalue->m.dl_N_PDU_SequenceNumberPresent) {
      stat = asn1PE_DL_N_PDU_SequenceNumber (pctxt, pvalue->dl_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode ul_N_PDU_SequenceNumber */

   if (pvalue->m.ul_N_PDU_SequenceNumberPresent) {
      stat = asn1PE_UL_N_PDU_SequenceNumber (pctxt, pvalue->ul_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_SetupOrModifyItemSecond_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifyItem_IEs_SecondValue                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_SetupOrModifyItem_IEs_SecondValue (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupOrModifyItem_IEs_SecondValue *pvalue = (_RAB_SetupOrModifyItem_IEs_SecondValue*) pvalue_;
   stat = asn1PE_RAB_SetupOrModifyItemSecond (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyList_element_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupOrModifyList_element_element (ASN1CTXT* pctxt, RAB_SetupOrModifyList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_SetupOrModifyList_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode firstCriticality */

   stat = asn1PE_Criticality (pctxt, pvalue->firstCriticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode firstValue */

   stat = pe_OpenType (pctxt, pvalue->firstValue.encoded.numocts, pvalue->firstValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode secondCriticality */

   stat = asn1PE_Criticality (pctxt, pvalue->secondCriticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode secondValue */

   stat = pe_OpenType (pctxt, pvalue->secondValue.encoded.numocts, pvalue->secondValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyList_element_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_SetupOrModifyList_element_element (ASN1CTXT* pctxt,
   RAB_SetupOrModifyList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupOrModifyItem_IEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifyItem_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifyItem_IEs_Size) return 0;

   /* check secondValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_SetupOrModifyItem_IEs[index].encodeSecondValue(pctxt, pvalue->secondValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->secondValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->secondValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "secondCriticality" element */

   /* check firstValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_SetupOrModifyItem_IEs[index].encodeFirstValue(pctxt, pvalue->firstValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->firstValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->firstValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "firstCriticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyList_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupOrModifyList_element (ASN1CTXT* pctxt, RAB_SetupOrModifyList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_SetupOrModifyList_element_element (pctxt, ((RAB_SetupOrModifyList_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifyList                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupOrModifyList (ASN1CTXT* pctxt, RAB_SetupOrModifyList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_SetupOrModifyList_element (pctxt, ((RAB_SetupOrModifyList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentRequestIEs_Value                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_AssignmentRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentRequestIEs_Value *pvalue = (_RAB_AssignmentRequestIEs_Value*) pvalue_;
   stat = asn1PE_RAB_SetupOrModifyList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentRequestIEs_Value_1                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_AssignmentRequestIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentRequestIEs_Value_1 *pvalue = (_RAB_AssignmentRequestIEs_Value_1*) pvalue_;
   stat = asn1PE_RAB_ReleaseList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_AssignmentRequest_protocolIEs_element (ASN1CTXT* pctxt, RAB_AssignmentRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_AssignmentRequest_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_AssignmentRequest_protocolIEs_element (ASN1CTXT* pctxt,
   RAB_AssignmentRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_AssignmentRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_AssignmentRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_AssignmentRequestIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_AssignmentRequestIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolIEs                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_AssignmentRequest_protocolIEs (ASN1CTXT* pctxt, RAB_AssignmentRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_AssignmentRequest_protocolIEs_element (pctxt, ((RAB_AssignmentRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_AssignmentRequest_protocolExtensions_element (ASN1CTXT* pctxt, RAB_AssignmentRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_AssignmentRequest_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_AssignmentRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   RAB_AssignmentRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_AssignmentRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_AssignmentRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_AssignmentRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_AssignmentRequestExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest_protocolExtensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_AssignmentRequest_protocolExtensions (ASN1CTXT* pctxt, RAB_AssignmentRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_AssignmentRequest_protocolExtensions_element (pctxt, ((RAB_AssignmentRequest_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentRequest                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_AssignmentRequest (ASN1CTXT* pctxt, RAB_AssignmentRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_RAB_AssignmentRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_RAB_AssignmentRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifiedItem_ExtIEs_Extension                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_SetupOrModifiedItem_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupOrModifiedItem_ExtIEs_Extension *pvalue = (_RAB_SetupOrModifiedItem_ExtIEs_Extension*) pvalue_;
   stat = asn1PE_Ass_RAB_Parameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedItem_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupOrModifiedItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_SetupOrModifiedItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_SetupOrModifiedItem_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedItem_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_SetupOrModifiedItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_SetupOrModifiedItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupOrModifiedItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifiedItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifiedItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_SetupOrModifiedItem_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedItem_iE_Extensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupOrModifiedItem_iE_Extensions (ASN1CTXT* pctxt, RAB_SetupOrModifiedItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_SetupOrModifiedItem_iE_Extensions_element (pctxt, ((RAB_SetupOrModifiedItem_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedItem                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupOrModifiedItem (ASN1CTXT* pctxt, RAB_SetupOrModifiedItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transportLayerAddressPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iuTransportAssociationPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dl_dataVolumesPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      stat = asn1PE_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iuTransportAssociation */

   if (pvalue->m.iuTransportAssociationPresent) {
      stat = asn1PE_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode dl_dataVolumes */

   if (pvalue->m.dl_dataVolumesPresent) {
      stat = asn1PE_DataVolumeList (pctxt, &pvalue->dl_dataVolumes);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_SetupOrModifiedItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_SetupOrModifiedItemIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_SetupOrModifiedItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_SetupOrModifiedItemIEs_Value *pvalue = (_RAB_SetupOrModifiedItemIEs_Value*) pvalue_;
   stat = asn1PE_RAB_SetupOrModifiedItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedList_element_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupOrModifiedList_element_element (ASN1CTXT* pctxt, RAB_SetupOrModifiedList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_SetupOrModifiedList_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedList_element_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_SetupOrModifiedList_element_element (ASN1CTXT* pctxt,
   RAB_SetupOrModifiedList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_SetupOrModifiedItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_SetupOrModifiedItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_SetupOrModifiedItemIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_SetupOrModifiedItemIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedList_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupOrModifiedList_element (ASN1CTXT* pctxt, RAB_SetupOrModifiedList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_SetupOrModifiedList_element_element (pctxt, ((RAB_SetupOrModifiedList_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SetupOrModifiedList                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SetupOrModifiedList (ASN1CTXT* pctxt, RAB_SetupOrModifiedList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_SetupOrModifiedList_element (pctxt, ((RAB_SetupOrModifiedList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_AssignmentResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseIEs_Value *pvalue = (_RAB_AssignmentResponseIEs_Value*) pvalue_;
   stat = asn1PE_RAB_SetupOrModifiedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_iE_Extensions_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleasedItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_ReleasedItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_ReleasedItem_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_iE_Extensions_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_ReleasedItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_ReleasedItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleasedItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleasedItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleasedItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_ReleasedItem_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem_iE_Extensions                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleasedItem_iE_Extensions (ASN1CTXT* pctxt, RAB_ReleasedItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ReleasedItem_iE_Extensions_element (pctxt, ((RAB_ReleasedItem_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedItem                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleasedItem (ASN1CTXT* pctxt, RAB_ReleasedItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dl_dataVolumesPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dL_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.uL_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode dl_dataVolumes */

   if (pvalue->m.dl_dataVolumesPresent) {
      stat = asn1PE_DataVolumeList (pctxt, &pvalue->dl_dataVolumes);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode dL_GTP_PDU_SequenceNumber */

   if (pvalue->m.dL_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PE_DL_GTP_PDU_SequenceNumber (pctxt, pvalue->dL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode uL_GTP_PDU_SequenceNumber */

   if (pvalue->m.uL_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PE_UL_GTP_PDU_SequenceNumber (pctxt, pvalue->uL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_ReleasedItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ReleasedItemIEs_Value                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_ReleasedItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ReleasedItemIEs_Value *pvalue = (_RAB_ReleasedItemIEs_Value*) pvalue_;
   stat = asn1PE_RAB_ReleasedItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_element_element                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleasedList_element_element (ASN1CTXT* pctxt, RAB_ReleasedList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_ReleasedList_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_element_element                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_ReleasedList_element_element (ASN1CTXT* pctxt,
   RAB_ReleasedList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ReleasedItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ReleasedItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ReleasedItemIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_ReleasedItemIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList_element                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleasedList_element (ASN1CTXT* pctxt, RAB_ReleasedList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ReleasedList_element_element (pctxt, ((RAB_ReleasedList_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleasedList                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleasedList (ASN1CTXT* pctxt, RAB_ReleasedList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ReleasedList_element (pctxt, ((RAB_ReleasedList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_1                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_AssignmentResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseIEs_Value_1 *pvalue = (_RAB_AssignmentResponseIEs_Value_1*) pvalue_;
   stat = asn1PE_RAB_ReleasedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_QueuedItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_QueuedItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_QueuedItem_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_QueuedItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_QueuedItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_QueuedItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_QueuedItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_QueuedItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_QueuedItem_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedItem_iE_Extensions                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_QueuedItem_iE_Extensions (ASN1CTXT* pctxt, RAB_QueuedItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_QueuedItem_iE_Extensions_element (pctxt, ((RAB_QueuedItem_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedItem                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_QueuedItem (ASN1CTXT* pctxt, RAB_QueuedItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_QueuedItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_QueuedItemIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_QueuedItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_QueuedItemIEs_Value *pvalue = (_RAB_QueuedItemIEs_Value*) pvalue_;
   stat = asn1PE_RAB_QueuedItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedList_element_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_QueuedList_element_element (ASN1CTXT* pctxt, RAB_QueuedList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_QueuedList_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedList_element_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_QueuedList_element_element (ASN1CTXT* pctxt,
   RAB_QueuedList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_QueuedItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_QueuedItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_QueuedItemIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_QueuedItemIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedList_element                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_QueuedList_element (ASN1CTXT* pctxt, RAB_QueuedList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_QueuedList_element_element (pctxt, ((RAB_QueuedList_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_QueuedList                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_QueuedList (ASN1CTXT* pctxt, RAB_QueuedList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_QueuedList_element (pctxt, ((RAB_QueuedList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_2                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_AssignmentResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseIEs_Value_2 *pvalue = (_RAB_AssignmentResponseIEs_Value_2*) pvalue_;
   stat = asn1PE_RAB_QueuedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_3                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_AssignmentResponseIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseIEs_Value_3 *pvalue = (_RAB_AssignmentResponseIEs_Value_3*) pvalue_;
   stat = asn1PE_RAB_FailedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ReleaseFailedList                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ReleaseFailedList (ASN1CTXT* pctxt, RAB_ReleaseFailedList* pvalue)
{
   int stat = 0;

   stat = asn1PE_RAB_FailedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_4                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_AssignmentResponseIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseIEs_Value_4 *pvalue = (_RAB_AssignmentResponseIEs_Value_4*) pvalue_;
   stat = asn1PE_RAB_ReleaseFailedList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseIEs_Value_5                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_AssignmentResponseIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseIEs_Value_5 *pvalue = (_RAB_AssignmentResponseIEs_Value_5*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolIEs_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_AssignmentResponse_protocolIEs_element (ASN1CTXT* pctxt, RAB_AssignmentResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_AssignmentResponse_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolIEs_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_AssignmentResponse_protocolIEs_element (ASN1CTXT* pctxt,
   RAB_AssignmentResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_AssignmentResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_AssignmentResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_AssignmentResponseIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_AssignmentResponseIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolIEs                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_AssignmentResponse_protocolIEs (ASN1CTXT* pctxt, RAB_AssignmentResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_AssignmentResponse_protocolIEs_element (pctxt, ((RAB_AssignmentResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extens  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element (ASN1CTXT* pctxt, GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extens  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element (ASN1CTXT* pctxt,
   GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extens  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions (ASN1CTXT* pctxt, GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element (pctxt, ((GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item (ASN1CTXT* pctxt, GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.gERAN_ClassmarkPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode cause */

   stat = asn1PE_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode gERAN_Classmark */

   if (pvalue->m.gERAN_ClassmarkPresent) {
      stat = asn1PE_GERAN_Classmark (pctxt, pvalue->gERAN_Classmark);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value *pvalue = (_GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Value*) pvalue_;
   stat = asn1PE_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_el  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element (ASN1CTXT* pctxt, GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_el  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element (ASN1CTXT* pctxt,
   GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = GERAN_Iumode_RAB_Failed_RABAssgntResponse_ItemIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element (ASN1CTXT* pctxt, GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element (pctxt, ((GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Iumode_RAB_FailedList_RABAssgntResponse             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GERAN_Iumode_RAB_FailedList_RABAssgntResponse (ASN1CTXT* pctxt, GERAN_Iumode_RAB_FailedList_RABAssgntResponse* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element (pctxt, ((GERAN_Iumode_RAB_FailedList_RABAssgntResponse_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_AssignmentResponseExtensions_Extension               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_AssignmentResponseExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_AssignmentResponseExtensions_Extension *pvalue = (_RAB_AssignmentResponseExtensions_Extension*) pvalue_;
   stat = asn1PE_GERAN_Iumode_RAB_FailedList_RABAssgntResponse (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolExtensions_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_AssignmentResponse_protocolExtensions_element (ASN1CTXT* pctxt, RAB_AssignmentResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_AssignmentResponse_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolExtensions_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_AssignmentResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   RAB_AssignmentResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_AssignmentResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_AssignmentResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_AssignmentResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_AssignmentResponseExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse_protocolExtensions                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_AssignmentResponse_protocolExtensions (ASN1CTXT* pctxt, RAB_AssignmentResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_AssignmentResponse_protocolExtensions_element (pctxt, ((RAB_AssignmentResponse_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AssignmentResponse                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_AssignmentResponse (ASN1CTXT* pctxt, RAB_AssignmentResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_RAB_AssignmentResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_RAB_AssignmentResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrivateMessage_privateIEs_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PrivateMessage_privateIEs_element (ASN1CTXT* pctxt, PrivateMessage_privateIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_PrivateMessage_privateIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_PrivateIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrivateMessage_privateIEs_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_PrivateMessage_privateIEs_element (ASN1CTXT* pctxt,
   PrivateMessage_privateIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < PrivateMessage_IEs_Size; index++) {
      if(asn1CmpTC_PrivateIE_ID(&pvalue->id, &PrivateMessage_IEs[index].id) == 0) {
         break;
      }
   }
   if(index == PrivateMessage_IEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = PrivateMessage_IEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  PrivateMessage_privateIEs                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PrivateMessage_privateIEs (ASN1CTXT* pctxt, PrivateMessage_privateIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_PrivateMessage_privateIEs_element (pctxt, ((PrivateMessage_privateIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrivateMessage                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PrivateMessage (ASN1CTXT* pctxt, PrivateMessage* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode privateIEs */

   stat = asn1PE_PrivateMessage_privateIEs (pctxt, &pvalue->privateIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceIEs_Value                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetResourceIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceIEs_Value value = *((_ResetResourceIEs_Value*)pvalue_);
   stat = asn1PE_CN_DomainIndicator (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceIEs_Value_1                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetResourceIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceIEs_Value_1 *pvalue = (_ResetResourceIEs_Value_1*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceItem_iE_Extensions_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResourceItem_iE_Extensions_element (ASN1CTXT* pctxt, ResetResourceItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_ResetResourceItem_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceItem_iE_Extensions_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_ResetResourceItem_iE_Extensions_element (ASN1CTXT* pctxt,
   ResetResourceItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = ResetResourceItem_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResourceItem_iE_Extensions                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResourceItem_iE_Extensions (ASN1CTXT* pctxt, ResetResourceItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_ResetResourceItem_iE_Extensions_element (pctxt, ((ResetResourceItem_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceItem                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResourceItem (ASN1CTXT* pctxt, ResetResourceItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iuSigConId */

   stat = asn1PE_IuSignallingConnectionIdentifier (pctxt, &pvalue->iuSigConId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_ResetResourceItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceItemIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetResourceItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceItemIEs_Value *pvalue = (_ResetResourceItemIEs_Value*) pvalue_;
   stat = asn1PE_ResetResourceItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceList_element_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResourceList_element_element (ASN1CTXT* pctxt, ResetResourceList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_ResetResourceList_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceList_element_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_ResetResourceList_element_element (ASN1CTXT* pctxt,
   ResetResourceList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceItemIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = ResetResourceItemIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResourceList_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResourceList_element (ASN1CTXT* pctxt, ResetResourceList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_ResetResourceList_element_element (pctxt, ((ResetResourceList_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceList                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResourceList (ASN1CTXT* pctxt, ResetResourceList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(250), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_ResetResourceList_element (pctxt, ((ResetResourceList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceIEs_Value_2                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetResourceIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceIEs_Value_2 *pvalue = (_ResetResourceIEs_Value_2*) pvalue_;
   stat = asn1PE_ResetResourceList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceIEs_Value_3                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetResourceIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceIEs_Value_3 *pvalue = (_ResetResourceIEs_Value_3*) pvalue_;
   stat = asn1PE_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolIEs_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResource_protocolIEs_element (ASN1CTXT* pctxt, ResetResource_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_ResetResource_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolIEs_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_ResetResource_protocolIEs_element (ASN1CTXT* pctxt,
   ResetResource_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = ResetResourceIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolIEs                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResource_protocolIEs (ASN1CTXT* pctxt, ResetResource_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_ResetResource_protocolIEs_element (pctxt, ((ResetResource_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceExtensions_Extension                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetResourceExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceExtensions_Extension *pvalue = (_ResetResourceExtensions_Extension*) pvalue_;
   stat = asn1PE_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolExtensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResource_protocolExtensions_element (ASN1CTXT* pctxt, ResetResource_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_ResetResource_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolExtensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_ResetResource_protocolExtensions_element (ASN1CTXT* pctxt,
   ResetResource_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = ResetResourceExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResource_protocolExtensions                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResource_protocolExtensions (ASN1CTXT* pctxt, ResetResource_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_ResetResource_protocolExtensions_element (pctxt, ((ResetResource_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResource                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResource (ASN1CTXT* pctxt, ResetResource* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_ResetResource_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_ResetResource_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeIEs_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetResourceAcknowledgeIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceAcknowledgeIEs_Value value = *((_ResetResourceAcknowledgeIEs_Value*)pvalue_);
   stat = asn1PE_CN_DomainIndicator (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResourceAckItem_iE_Extensions_element (ASN1CTXT* pctxt, ResetResourceAckItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_ResetResourceAckItem_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_ResetResourceAckItem_iE_Extensions_element (ASN1CTXT* pctxt,
   ResetResourceAckItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceAckItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceAckItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceAckItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = ResetResourceAckItem_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckItem_iE_Extensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResourceAckItem_iE_Extensions (ASN1CTXT* pctxt, ResetResourceAckItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_ResetResourceAckItem_iE_Extensions_element (pctxt, ((ResetResourceAckItem_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckItem                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResourceAckItem (ASN1CTXT* pctxt, ResetResourceAckItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iuSigConId */

   stat = asn1PE_IuSignallingConnectionIdentifier (pctxt, &pvalue->iuSigConId);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_ResetResourceAckItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAckItemIEs_Value                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetResourceAckItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceAckItemIEs_Value *pvalue = (_ResetResourceAckItemIEs_Value*) pvalue_;
   stat = asn1PE_ResetResourceAckItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckList_element_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResourceAckList_element_element (ASN1CTXT* pctxt, ResetResourceAckList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_ResetResourceAckList_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckList_element_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_ResetResourceAckList_element_element (ASN1CTXT* pctxt,
   ResetResourceAckList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceAckItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceAckItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceAckItemIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = ResetResourceAckItemIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckList_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResourceAckList_element (ASN1CTXT* pctxt, ResetResourceAckList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_ResetResourceAckList_element_element (pctxt, ((ResetResourceAckList_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAckList                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResourceAckList (ASN1CTXT* pctxt, ResetResourceAckList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(250), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_ResetResourceAckList_element (pctxt, ((ResetResourceAckList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeIEs_Value_1                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetResourceAcknowledgeIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceAcknowledgeIEs_Value_1 *pvalue = (_ResetResourceAcknowledgeIEs_Value_1*) pvalue_;
   stat = asn1PE_ResetResourceAckList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeIEs_Value_2                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetResourceAcknowledgeIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceAcknowledgeIEs_Value_2 *pvalue = (_ResetResourceAcknowledgeIEs_Value_2*) pvalue_;
   stat = asn1PE_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeIEs_Value_3                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetResourceAcknowledgeIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceAcknowledgeIEs_Value_3 *pvalue = (_ResetResourceAcknowledgeIEs_Value_3*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResourceAcknowledge_protocolIEs_element (ASN1CTXT* pctxt, ResetResourceAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_ResetResourceAcknowledge_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_ResetResourceAcknowledge_protocolIEs_element (ASN1CTXT* pctxt,
   ResetResourceAcknowledge_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceAcknowledgeIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceAcknowledgeIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceAcknowledgeIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = ResetResourceAcknowledgeIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolIEs                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResourceAcknowledge_protocolIEs (ASN1CTXT* pctxt, ResetResourceAcknowledge_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_ResetResourceAcknowledge_protocolIEs_element (pctxt, ((ResetResourceAcknowledge_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _ResetResourceAcknowledgeExtensions_Extension             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__ResetResourceAcknowledgeExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _ResetResourceAcknowledgeExtensions_Extension *pvalue = (_ResetResourceAcknowledgeExtensions_Extension*) pvalue_;
   stat = asn1PE_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResourceAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt, ResetResourceAcknowledge_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_ResetResourceAcknowledge_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_ResetResourceAcknowledge_protocolExtensions_element (ASN1CTXT* pctxt,
   ResetResourceAcknowledge_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResetResourceAcknowledgeExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResetResourceAcknowledgeExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == ResetResourceAcknowledgeExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = ResetResourceAcknowledgeExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge_protocolExtensions               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResourceAcknowledge_protocolExtensions (ASN1CTXT* pctxt, ResetResourceAcknowledge_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_ResetResourceAcknowledge_protocolExtensions_element (pctxt, ((ResetResourceAcknowledge_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetResourceAcknowledge                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResetResourceAcknowledge (ASN1CTXT* pctxt, ResetResourceAcknowledge* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_ResetResourceAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_ResetResourceAcknowledge_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationItem_RANAP_RelocInf_iE_Extensio  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element (ASN1CTXT* pctxt, DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationItem_RANAP_RelocInf_iE_Extensio  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element (ASN1CTXT* pctxt,
   DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf[index].id) == 0) {
         break;
      }
   }
   if(index == RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RANAP_DirectTransferInformationItem_ExtIEs_RANAP_RelocInf[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationItem_RANAP_RelocInf_iE_Extensio  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions (ASN1CTXT* pctxt, DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element (pctxt, ((DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationItem_RANAP_RelocInf              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DirectTransferInformationItem_RANAP_RelocInf (ASN1CTXT* pctxt, DirectTransferInformationItem_RANAP_RelocInf* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode nAS_PDU */

   stat = asn1PE_NAS_PDU (pctxt, pvalue->nAS_PDU);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode sAPI */

   stat = asn1PE_SAPI (pctxt, pvalue->sAPI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode cN_DomainIndicator */

   stat = asn1PE_CN_DomainIndicator (pctxt, pvalue->cN_DomainIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_DirectTransferInformationItem_RANAP_RelocInf_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectTransferInformationItemIEs_RANAP_RelocInf_Value    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__DirectTransferInformationItemIEs_RANAP_RelocInf_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectTransferInformationItemIEs_RANAP_RelocInf_Value *pvalue = (_DirectTransferInformationItemIEs_RANAP_RelocInf_Value*) pvalue_;
   stat = asn1PE_DirectTransferInformationItem_RANAP_RelocInf (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationList_RANAP_RelocInf_element_ele  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DirectTransferInformationList_RANAP_RelocInf_element_element (ASN1CTXT* pctxt, DirectTransferInformationList_RANAP_RelocInf_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_DirectTransferInformationList_RANAP_RelocInf_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationList_RANAP_RelocInf_element_ele  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_DirectTransferInformationList_RANAP_RelocInf_element_element (ASN1CTXT* pctxt,
   DirectTransferInformationList_RANAP_RelocInf_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DirectTransferInformationItemIEs_RANAP_RelocInf_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectTransferInformationItemIEs_RANAP_RelocInf[index].id) == 0) {
         break;
      }
   }
   if(index == DirectTransferInformationItemIEs_RANAP_RelocInf_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = DirectTransferInformationItemIEs_RANAP_RelocInf[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationList_RANAP_RelocInf_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DirectTransferInformationList_RANAP_RelocInf_element (ASN1CTXT* pctxt, DirectTransferInformationList_RANAP_RelocInf_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_DirectTransferInformationList_RANAP_RelocInf_element_element (pctxt, ((DirectTransferInformationList_RANAP_RelocInf_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectTransferInformationList_RANAP_RelocInf              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DirectTransferInformationList_RANAP_RelocInf (ASN1CTXT* pctxt, DirectTransferInformationList_RANAP_RelocInf* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_DirectTransferInformationList_RANAP_RelocInf_element (pctxt, ((DirectTransferInformationList_RANAP_RelocInf_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RANAP_RelocationInformationIEs_Value                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RANAP_RelocationInformationIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RANAP_RelocationInformationIEs_Value *pvalue = (_RANAP_RelocationInformationIEs_Value*) pvalue_;
   stat = asn1PE_DirectTransferInformationList_RANAP_RelocInf (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element (ASN1CTXT* pctxt, RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ContextItem_ExtIEs_RANAP_RelocInf_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ContextItem_ExtIEs_RANAP_RelocInf[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ContextItem_ExtIEs_RANAP_RelocInf_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_ContextItem_ExtIEs_RANAP_RelocInf[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_RANAP_RelocInf_iE_Extensions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ContextItem_RANAP_RelocInf_iE_Extensions (ASN1CTXT* pctxt, RAB_ContextItem_RANAP_RelocInf_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element (pctxt, ((RAB_ContextItem_RANAP_RelocInf_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextItem_RANAP_RelocInf                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ContextItem_RANAP_RelocInf (ASN1CTXT* pctxt, RAB_ContextItem_RANAP_RelocInf* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dl_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ul_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dl_N_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.ul_N_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode dl_GTP_PDU_SequenceNumber */

   if (pvalue->m.dl_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PE_DL_GTP_PDU_SequenceNumber (pctxt, pvalue->dl_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode ul_GTP_PDU_SequenceNumber */

   if (pvalue->m.ul_GTP_PDU_SequenceNumberPresent) {
      stat = asn1PE_UL_GTP_PDU_SequenceNumber (pctxt, pvalue->ul_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode dl_N_PDU_SequenceNumber */

   if (pvalue->m.dl_N_PDU_SequenceNumberPresent) {
      stat = asn1PE_DL_N_PDU_SequenceNumber (pctxt, pvalue->dl_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode ul_N_PDU_SequenceNumber */

   if (pvalue->m.ul_N_PDU_SequenceNumberPresent) {
      stat = asn1PE_UL_N_PDU_SequenceNumber (pctxt, pvalue->ul_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_ContextItem_RANAP_RelocInf_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ContextItemIEs_RANAP_RelocInf_Value                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_ContextItemIEs_RANAP_RelocInf_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ContextItemIEs_RANAP_RelocInf_Value *pvalue = (_RAB_ContextItemIEs_RANAP_RelocInf_Value*) pvalue_;
   stat = asn1PE_RAB_ContextItem_RANAP_RelocInf (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_RANAP_RelocInf_element_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ContextList_RANAP_RelocInf_element_element (ASN1CTXT* pctxt, RAB_ContextList_RANAP_RelocInf_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_ContextList_RANAP_RelocInf_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_RANAP_RelocInf_element_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_ContextList_RANAP_RelocInf_element_element (ASN1CTXT* pctxt,
   RAB_ContextList_RANAP_RelocInf_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ContextItemIEs_RANAP_RelocInf_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ContextItemIEs_RANAP_RelocInf[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ContextItemIEs_RANAP_RelocInf_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_ContextItemIEs_RANAP_RelocInf[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_RANAP_RelocInf_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ContextList_RANAP_RelocInf_element (ASN1CTXT* pctxt, RAB_ContextList_RANAP_RelocInf_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ContextList_RANAP_RelocInf_element_element (pctxt, ((RAB_ContextList_RANAP_RelocInf_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ContextList_RANAP_RelocInf                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ContextList_RANAP_RelocInf (ASN1CTXT* pctxt, RAB_ContextList_RANAP_RelocInf* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ContextList_RANAP_RelocInf_element (pctxt, ((RAB_ContextList_RANAP_RelocInf_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RANAP_RelocationInformationIEs_Value_1                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RANAP_RelocationInformationIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RANAP_RelocationInformationIEs_Value_1 *pvalue = (_RANAP_RelocationInformationIEs_Value_1*) pvalue_;
   stat = asn1PE_RAB_ContextList_RANAP_RelocInf (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolIEs_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RANAP_RelocationInformation_protocolIEs_element (ASN1CTXT* pctxt, RANAP_RelocationInformation_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RANAP_RelocationInformation_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolIEs_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RANAP_RelocationInformation_protocolIEs_element (ASN1CTXT* pctxt,
   RANAP_RelocationInformation_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RANAP_RelocationInformationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RANAP_RelocationInformationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RANAP_RelocationInformationIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RANAP_RelocationInformationIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolIEs                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RANAP_RelocationInformation_protocolIEs (ASN1CTXT* pctxt, RANAP_RelocationInformation_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RANAP_RelocationInformation_protocolIEs_element (pctxt, ((RANAP_RelocationInformation_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RANAP_RelocationInformationExtensions_Extension          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RANAP_RelocationInformationExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RANAP_RelocationInformationExtensions_Extension value = *((_RANAP_RelocationInformationExtensions_Extension*)pvalue_);
   stat = asn1PE_RRC_Container (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RANAP_RelocationInformation_protocolExtensions_element (ASN1CTXT* pctxt, RANAP_RelocationInformation_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RANAP_RelocationInformation_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RANAP_RelocationInformation_protocolExtensions_element (ASN1CTXT* pctxt,
   RANAP_RelocationInformation_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RANAP_RelocationInformationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RANAP_RelocationInformationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RANAP_RelocationInformationExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RANAP_RelocationInformationExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation_protocolExtensions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RANAP_RelocationInformation_protocolExtensions (ASN1CTXT* pctxt, RANAP_RelocationInformation_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RANAP_RelocationInformation_protocolExtensions_element (pctxt, ((RANAP_RelocationInformation_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RANAP_RelocationInformation                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RANAP_RelocationInformation (ASN1CTXT* pctxt, RANAP_RelocationInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_RANAP_RelocationInformation_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_RANAP_RelocationInformation_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ModifyItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_ModifyItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_ModifyItem_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyItem_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_ModifyItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_ModifyItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ModifyItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ModifyItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ModifyItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_ModifyItem_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyItem_iE_Extensions                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ModifyItem_iE_Extensions (ASN1CTXT* pctxt, RAB_ModifyItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ModifyItem_iE_Extensions_element (pctxt, ((RAB_ModifyItem_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyItem                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ModifyItem (ASN1CTXT* pctxt, RAB_ModifyItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode requested_RAB_Parameter_Values */

   stat = asn1PE_Requested_RAB_Parameter_Values (pctxt, &pvalue->requested_RAB_Parameter_Values);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_ModifyItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ModifyItemIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_ModifyItemIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ModifyItemIEs_Value *pvalue = (_RAB_ModifyItemIEs_Value*) pvalue_;
   stat = asn1PE_RAB_ModifyItem (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyList_element_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ModifyList_element_element (ASN1CTXT* pctxt, RAB_ModifyList_element_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_ModifyList_element_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyList_element_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_ModifyList_element_element (ASN1CTXT* pctxt,
   RAB_ModifyList_element_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ModifyItemIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ModifyItemIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ModifyItemIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_ModifyItemIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyList_element                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ModifyList_element (ASN1CTXT* pctxt, RAB_ModifyList_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ModifyList_element_element (pctxt, ((RAB_ModifyList_element_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyList                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ModifyList (ASN1CTXT* pctxt, RAB_ModifyList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ModifyList_element (pctxt, ((RAB_ModifyList_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_ModifyRequestIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_ModifyRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_ModifyRequestIEs_Value *pvalue = (_RAB_ModifyRequestIEs_Value*) pvalue_;
   stat = asn1PE_RAB_ModifyList (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ModifyRequest_protocolIEs_element (ASN1CTXT* pctxt, RAB_ModifyRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_ModifyRequest_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_ModifyRequest_protocolIEs_element (ASN1CTXT* pctxt,
   RAB_ModifyRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ModifyRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ModifyRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ModifyRequestIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_ModifyRequestIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ModifyRequest_protocolIEs (ASN1CTXT* pctxt, RAB_ModifyRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ModifyRequest_protocolIEs_element (pctxt, ((RAB_ModifyRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ModifyRequest_protocolExtensions_element (ASN1CTXT* pctxt, RAB_ModifyRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_ModifyRequest_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_ModifyRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   RAB_ModifyRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_ModifyRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_ModifyRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_ModifyRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_ModifyRequestExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ModifyRequest_protocolExtensions (ASN1CTXT* pctxt, RAB_ModifyRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_ModifyRequest_protocolExtensions_element (pctxt, ((RAB_ModifyRequest_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ModifyRequest                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ModifyRequest (ASN1CTXT* pctxt, RAB_ModifyRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_RAB_ModifyRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_RAB_ModifyRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataRequestIEs_Value                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__LocationRelatedDataRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationRelatedDataRequestIEs_Value *pvalue = (_LocationRelatedDataRequestIEs_Value*) pvalue_;
   stat = asn1PE_LocationRelatedDataRequestType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolIEs_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationRelatedDataRequest_protocolIEs_element (ASN1CTXT* pctxt, LocationRelatedDataRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_LocationRelatedDataRequest_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolIEs_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_LocationRelatedDataRequest_protocolIEs_element (ASN1CTXT* pctxt,
   LocationRelatedDataRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationRelatedDataRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataRequestIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = LocationRelatedDataRequestIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolIEs                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationRelatedDataRequest_protocolIEs (ASN1CTXT* pctxt, LocationRelatedDataRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_LocationRelatedDataRequest_protocolIEs_element (pctxt, ((LocationRelatedDataRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataRequestExtensions_Extension           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__LocationRelatedDataRequestExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationRelatedDataRequestExtensions_Extension value = *((_LocationRelatedDataRequestExtensions_Extension*)pvalue_);
   stat = asn1PE_LocationRelatedDataRequestTypeSpecificToGERANIuMode (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationRelatedDataRequest_protocolExtensions_element (ASN1CTXT* pctxt, LocationRelatedDataRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_LocationRelatedDataRequest_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_LocationRelatedDataRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   LocationRelatedDataRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationRelatedDataRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = LocationRelatedDataRequestExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest_protocolExtensions             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationRelatedDataRequest_protocolExtensions (ASN1CTXT* pctxt, LocationRelatedDataRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_LocationRelatedDataRequest_protocolExtensions_element (pctxt, ((LocationRelatedDataRequest_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequest                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationRelatedDataRequest (ASN1CTXT* pctxt, LocationRelatedDataRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_LocationRelatedDataRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_LocationRelatedDataRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataResponseIEs_Value                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__LocationRelatedDataResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationRelatedDataResponseIEs_Value *pvalue = (_LocationRelatedDataResponseIEs_Value*) pvalue_;
   stat = asn1PE_BroadcastAssistanceDataDecipheringKeys (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolIEs_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationRelatedDataResponse_protocolIEs_element (ASN1CTXT* pctxt, LocationRelatedDataResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_LocationRelatedDataResponse_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolIEs_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_LocationRelatedDataResponse_protocolIEs_element (ASN1CTXT* pctxt,
   LocationRelatedDataResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationRelatedDataResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataResponseIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = LocationRelatedDataResponseIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolIEs                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationRelatedDataResponse_protocolIEs (ASN1CTXT* pctxt, LocationRelatedDataResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_LocationRelatedDataResponse_protocolIEs_element (pctxt, ((LocationRelatedDataResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataResponseExtensions_Extension          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__LocationRelatedDataResponseExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationRelatedDataResponseExtensions_Extension *pvalue = (_LocationRelatedDataResponseExtensions_Extension*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationRelatedDataResponse_protocolExtensions_element (ASN1CTXT* pctxt, LocationRelatedDataResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_LocationRelatedDataResponse_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolExtensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_LocationRelatedDataResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   LocationRelatedDataResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationRelatedDataResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = LocationRelatedDataResponseExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse_protocolExtensions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationRelatedDataResponse_protocolExtensions (ASN1CTXT* pctxt, LocationRelatedDataResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_LocationRelatedDataResponse_protocolExtensions_element (pctxt, ((LocationRelatedDataResponse_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataResponse                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationRelatedDataResponse (ASN1CTXT* pctxt, LocationRelatedDataResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_LocationRelatedDataResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_LocationRelatedDataResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataFailureIEs_Value                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__LocationRelatedDataFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationRelatedDataFailureIEs_Value *pvalue = (_LocationRelatedDataFailureIEs_Value*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolIEs_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationRelatedDataFailure_protocolIEs_element (ASN1CTXT* pctxt, LocationRelatedDataFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_LocationRelatedDataFailure_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolIEs_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_LocationRelatedDataFailure_protocolIEs_element (ASN1CTXT* pctxt,
   LocationRelatedDataFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationRelatedDataFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataFailureIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = LocationRelatedDataFailureIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolIEs                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationRelatedDataFailure_protocolIEs (ASN1CTXT* pctxt, LocationRelatedDataFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_LocationRelatedDataFailure_protocolIEs_element (pctxt, ((LocationRelatedDataFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _LocationRelatedDataFailureExtensions_Extension           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__LocationRelatedDataFailureExtensions_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _LocationRelatedDataFailureExtensions_Extension *pvalue = (_LocationRelatedDataFailureExtensions_Extension*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationRelatedDataFailure_protocolExtensions_element (ASN1CTXT* pctxt, LocationRelatedDataFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_LocationRelatedDataFailure_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_LocationRelatedDataFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   LocationRelatedDataFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LocationRelatedDataFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LocationRelatedDataFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == LocationRelatedDataFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = LocationRelatedDataFailureExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure_protocolExtensions             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationRelatedDataFailure_protocolExtensions (ASN1CTXT* pctxt, LocationRelatedDataFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_LocationRelatedDataFailure_protocolExtensions_element (pctxt, ((LocationRelatedDataFailure_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataFailure                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationRelatedDataFailure (ASN1CTXT* pctxt, LocationRelatedDataFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_LocationRelatedDataFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_LocationRelatedDataFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferIndicationIEs_Value                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InformationTransferIndicationIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferIndicationIEs_Value value = *((_InformationTransferIndicationIEs_Value*)pvalue_);
   stat = asn1PE_InformationTransferID (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferIndicationIEs_Value_1                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InformationTransferIndicationIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferIndicationIEs_Value_1 *pvalue = (_InformationTransferIndicationIEs_Value_1*) pvalue_;
   stat = asn1PE_ProvidedData (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferIndicationIEs_Value_2                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InformationTransferIndicationIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferIndicationIEs_Value_2 value = *((_InformationTransferIndicationIEs_Value_2*)pvalue_);
   stat = asn1PE_CN_DomainIndicator (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferIndicationIEs_Value_3                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InformationTransferIndicationIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferIndicationIEs_Value_3 *pvalue = (_InformationTransferIndicationIEs_Value_3*) pvalue_;
   stat = asn1PE_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolIEs_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationTransferIndication_protocolIEs_element (ASN1CTXT* pctxt, InformationTransferIndication_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_InformationTransferIndication_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolIEs_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_InformationTransferIndication_protocolIEs_element (ASN1CTXT* pctxt,
   InformationTransferIndication_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InformationTransferIndicationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferIndicationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferIndicationIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = InformationTransferIndicationIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolIEs                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationTransferIndication_protocolIEs (ASN1CTXT* pctxt, InformationTransferIndication_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_InformationTransferIndication_protocolIEs_element (pctxt, ((InformationTransferIndication_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolExtensions_element  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationTransferIndication_protocolExtensions_element (ASN1CTXT* pctxt, InformationTransferIndication_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_InformationTransferIndication_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolExtensions_element  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_InformationTransferIndication_protocolExtensions_element (ASN1CTXT* pctxt,
   InformationTransferIndication_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InformationTransferIndicationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferIndicationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferIndicationExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = InformationTransferIndicationExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication_protocolExtensions          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationTransferIndication_protocolExtensions (ASN1CTXT* pctxt, InformationTransferIndication_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_InformationTransferIndication_protocolExtensions_element (pctxt, ((InformationTransferIndication_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferIndication                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationTransferIndication (ASN1CTXT* pctxt, InformationTransferIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_InformationTransferIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_InformationTransferIndication_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferConfirmationIEs_Value                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InformationTransferConfirmationIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferConfirmationIEs_Value value = *((_InformationTransferConfirmationIEs_Value*)pvalue_);
   stat = asn1PE_InformationTransferID (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferConfirmationIEs_Value_1               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InformationTransferConfirmationIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferConfirmationIEs_Value_1 value = *((_InformationTransferConfirmationIEs_Value_1*)pvalue_);
   stat = asn1PE_CN_DomainIndicator (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferConfirmationIEs_Value_2               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InformationTransferConfirmationIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferConfirmationIEs_Value_2 *pvalue = (_InformationTransferConfirmationIEs_Value_2*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferConfirmationIEs_Value_3               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InformationTransferConfirmationIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferConfirmationIEs_Value_3 *pvalue = (_InformationTransferConfirmationIEs_Value_3*) pvalue_;
   stat = asn1PE_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolIEs_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationTransferConfirmation_protocolIEs_element (ASN1CTXT* pctxt, InformationTransferConfirmation_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_InformationTransferConfirmation_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolIEs_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_InformationTransferConfirmation_protocolIEs_element (ASN1CTXT* pctxt,
   InformationTransferConfirmation_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InformationTransferConfirmationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferConfirmationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferConfirmationIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = InformationTransferConfirmationIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolIEs               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationTransferConfirmation_protocolIEs (ASN1CTXT* pctxt, InformationTransferConfirmation_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_InformationTransferConfirmation_protocolIEs_element (pctxt, ((InformationTransferConfirmation_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolExtensions_eleme  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationTransferConfirmation_protocolExtensions_element (ASN1CTXT* pctxt, InformationTransferConfirmation_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_InformationTransferConfirmation_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolExtensions_eleme  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_InformationTransferConfirmation_protocolExtensions_element (ASN1CTXT* pctxt,
   InformationTransferConfirmation_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InformationTransferConfirmationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferConfirmationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferConfirmationExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = InformationTransferConfirmationExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation_protocolExtensions        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationTransferConfirmation_protocolExtensions (ASN1CTXT* pctxt, InformationTransferConfirmation_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_InformationTransferConfirmation_protocolExtensions_element (pctxt, ((InformationTransferConfirmation_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferConfirmation                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationTransferConfirmation (ASN1CTXT* pctxt, InformationTransferConfirmation* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_InformationTransferConfirmation_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_InformationTransferConfirmation_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InformationTransferFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferFailureIEs_Value value = *((_InformationTransferFailureIEs_Value*)pvalue_);
   stat = asn1PE_InformationTransferID (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value_1                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InformationTransferFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferFailureIEs_Value_1 value = *((_InformationTransferFailureIEs_Value_1*)pvalue_);
   stat = asn1PE_CN_DomainIndicator (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value_2                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InformationTransferFailureIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferFailureIEs_Value_2 *pvalue = (_InformationTransferFailureIEs_Value_2*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value_3                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InformationTransferFailureIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferFailureIEs_Value_3 *pvalue = (_InformationTransferFailureIEs_Value_3*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _InformationTransferFailureIEs_Value_4                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__InformationTransferFailureIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _InformationTransferFailureIEs_Value_4 *pvalue = (_InformationTransferFailureIEs_Value_4*) pvalue_;
   stat = asn1PE_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolIEs_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationTransferFailure_protocolIEs_element (ASN1CTXT* pctxt, InformationTransferFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_InformationTransferFailure_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolIEs_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_InformationTransferFailure_protocolIEs_element (ASN1CTXT* pctxt,
   InformationTransferFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InformationTransferFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferFailureIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = InformationTransferFailureIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolIEs                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationTransferFailure_protocolIEs (ASN1CTXT* pctxt, InformationTransferFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_InformationTransferFailure_protocolIEs_element (pctxt, ((InformationTransferFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationTransferFailure_protocolExtensions_element (ASN1CTXT* pctxt, InformationTransferFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_InformationTransferFailure_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolExtensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_InformationTransferFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   InformationTransferFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InformationTransferFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InformationTransferFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == InformationTransferFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = InformationTransferFailureExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure_protocolExtensions             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationTransferFailure_protocolExtensions (ASN1CTXT* pctxt, InformationTransferFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_InformationTransferFailure_protocolExtensions_element (pctxt, ((InformationTransferFailure_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferFailure                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationTransferFailure (ASN1CTXT* pctxt, InformationTransferFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_InformationTransferFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_InformationTransferFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UESpecificInformationIndicationIEs_Value                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__UESpecificInformationIndicationIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UESpecificInformationIndicationIEs_Value *pvalue = (_UESpecificInformationIndicationIEs_Value*) pvalue_;
   stat = asn1PE_UESBI_Iu (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolIEs_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UESpecificInformationIndication_protocolIEs_element (ASN1CTXT* pctxt, UESpecificInformationIndication_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_UESpecificInformationIndication_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolIEs_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_UESpecificInformationIndication_protocolIEs_element (ASN1CTXT* pctxt,
   UESpecificInformationIndication_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UESpecificInformationIndicationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UESpecificInformationIndicationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UESpecificInformationIndicationIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = UESpecificInformationIndicationIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolIEs               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UESpecificInformationIndication_protocolIEs (ASN1CTXT* pctxt, UESpecificInformationIndication_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_UESpecificInformationIndication_protocolIEs_element (pctxt, ((UESpecificInformationIndication_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolExtensions_eleme  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UESpecificInformationIndication_protocolExtensions_element (ASN1CTXT* pctxt, UESpecificInformationIndication_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_UESpecificInformationIndication_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolExtensions_eleme  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_UESpecificInformationIndication_protocolExtensions_element (ASN1CTXT* pctxt,
   UESpecificInformationIndication_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UESpecificInformationIndicationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UESpecificInformationIndicationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == UESpecificInformationIndicationExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = UESpecificInformationIndicationExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication_protocolExtensions        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UESpecificInformationIndication_protocolExtensions (ASN1CTXT* pctxt, UESpecificInformationIndication_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_UESpecificInformationIndication_protocolExtensions_element (pctxt, ((UESpecificInformationIndication_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESpecificInformationIndication                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UESpecificInformationIndication (ASN1CTXT* pctxt, UESpecificInformationIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_UESpecificInformationIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_UESpecificInformationIndication_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectInformationTransferIEs_Value                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__DirectInformationTransferIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectInformationTransferIEs_Value *pvalue = (_DirectInformationTransferIEs_Value*) pvalue_;
   stat = asn1PE_InterSystemInformationTransferType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectInformationTransferIEs_Value_1                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__DirectInformationTransferIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectInformationTransferIEs_Value_1 value = *((_DirectInformationTransferIEs_Value_1*)pvalue_);
   stat = asn1PE_CN_DomainIndicator (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectInformationTransferIEs_Value_2                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__DirectInformationTransferIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectInformationTransferIEs_Value_2 *pvalue = (_DirectInformationTransferIEs_Value_2*) pvalue_;
   stat = asn1PE_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _DirectInformationTransferIEs_Value_3                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__DirectInformationTransferIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _DirectInformationTransferIEs_Value_3 *pvalue = (_DirectInformationTransferIEs_Value_3*) pvalue_;
   stat = asn1PE_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolIEs_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DirectInformationTransfer_protocolIEs_element (ASN1CTXT* pctxt, DirectInformationTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_DirectInformationTransfer_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolIEs_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_DirectInformationTransfer_protocolIEs_element (ASN1CTXT* pctxt,
   DirectInformationTransfer_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DirectInformationTransferIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectInformationTransferIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DirectInformationTransferIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = DirectInformationTransferIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolIEs                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DirectInformationTransfer_protocolIEs (ASN1CTXT* pctxt, DirectInformationTransfer_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_DirectInformationTransfer_protocolIEs_element (pctxt, ((DirectInformationTransfer_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolExtensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DirectInformationTransfer_protocolExtensions_element (ASN1CTXT* pctxt, DirectInformationTransfer_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_DirectInformationTransfer_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolExtensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_DirectInformationTransfer_protocolExtensions_element (ASN1CTXT* pctxt,
   DirectInformationTransfer_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DirectInformationTransferExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DirectInformationTransferExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == DirectInformationTransferExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = DirectInformationTransferExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer_protocolExtensions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DirectInformationTransfer_protocolExtensions (ASN1CTXT* pctxt, DirectInformationTransfer_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_DirectInformationTransfer_protocolExtensions_element (pctxt, ((DirectInformationTransfer_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectInformationTransfer                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DirectInformationTransfer (ASN1CTXT* pctxt, DirectInformationTransfer* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_DirectInformationTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_DirectInformationTransfer_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__UplinkInformationExchangeRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeRequestIEs_Value value = *((_UplinkInformationExchangeRequestIEs_Value*)pvalue_);
   stat = asn1PE_InformationExchangeID (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_1              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__UplinkInformationExchangeRequestIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeRequestIEs_Value_1 value = *((_UplinkInformationExchangeRequestIEs_Value_1*)pvalue_);
   stat = asn1PE_InformationExchangeType (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_2              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__UplinkInformationExchangeRequestIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeRequestIEs_Value_2 *pvalue = (_UplinkInformationExchangeRequestIEs_Value_2*) pvalue_;
   stat = asn1PE_InformationTransferType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_3              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__UplinkInformationExchangeRequestIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeRequestIEs_Value_3 *pvalue = (_UplinkInformationExchangeRequestIEs_Value_3*) pvalue_;
   stat = asn1PE_InformationRequestType (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_4              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__UplinkInformationExchangeRequestIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeRequestIEs_Value_4 value = *((_UplinkInformationExchangeRequestIEs_Value_4*)pvalue_);
   stat = asn1PE_CN_DomainIndicator (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeRequestIEs_Value_5              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__UplinkInformationExchangeRequestIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeRequestIEs_Value_5 *pvalue = (_UplinkInformationExchangeRequestIEs_Value_5*) pvalue_;
   stat = asn1PE_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolIEs_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UplinkInformationExchangeRequest_protocolIEs_element (ASN1CTXT* pctxt, UplinkInformationExchangeRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_UplinkInformationExchangeRequest_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolIEs_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_UplinkInformationExchangeRequest_protocolIEs_element (ASN1CTXT* pctxt,
   UplinkInformationExchangeRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UplinkInformationExchangeRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeRequestIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = UplinkInformationExchangeRequestIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolIEs              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UplinkInformationExchangeRequest_protocolIEs (ASN1CTXT* pctxt, UplinkInformationExchangeRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_UplinkInformationExchangeRequest_protocolIEs_element (pctxt, ((UplinkInformationExchangeRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolExtensions_elem  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UplinkInformationExchangeRequest_protocolExtensions_element (ASN1CTXT* pctxt, UplinkInformationExchangeRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_UplinkInformationExchangeRequest_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolExtensions_elem  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_UplinkInformationExchangeRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   UplinkInformationExchangeRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UplinkInformationExchangeRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = UplinkInformationExchangeRequestExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest_protocolExtensions       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UplinkInformationExchangeRequest_protocolExtensions (ASN1CTXT* pctxt, UplinkInformationExchangeRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_UplinkInformationExchangeRequest_protocolExtensions_element (pctxt, ((UplinkInformationExchangeRequest_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeRequest                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UplinkInformationExchangeRequest (ASN1CTXT* pctxt, UplinkInformationExchangeRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_UplinkInformationExchangeRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_UplinkInformationExchangeRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__UplinkInformationExchangeResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeResponseIEs_Value value = *((_UplinkInformationExchangeResponseIEs_Value*)pvalue_);
   stat = asn1PE_InformationExchangeID (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value_1             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__UplinkInformationExchangeResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeResponseIEs_Value_1 *pvalue = (_UplinkInformationExchangeResponseIEs_Value_1*) pvalue_;
   stat = asn1PE_InformationRequested (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value_2             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__UplinkInformationExchangeResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeResponseIEs_Value_2 value = *((_UplinkInformationExchangeResponseIEs_Value_2*)pvalue_);
   stat = asn1PE_CN_DomainIndicator (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value_3             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__UplinkInformationExchangeResponseIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeResponseIEs_Value_3 *pvalue = (_UplinkInformationExchangeResponseIEs_Value_3*) pvalue_;
   stat = asn1PE_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeResponseIEs_Value_4             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__UplinkInformationExchangeResponseIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeResponseIEs_Value_4 *pvalue = (_UplinkInformationExchangeResponseIEs_Value_4*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolIEs_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UplinkInformationExchangeResponse_protocolIEs_element (ASN1CTXT* pctxt, UplinkInformationExchangeResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_UplinkInformationExchangeResponse_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolIEs_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_UplinkInformationExchangeResponse_protocolIEs_element (ASN1CTXT* pctxt,
   UplinkInformationExchangeResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UplinkInformationExchangeResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeResponseIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = UplinkInformationExchangeResponseIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolIEs             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UplinkInformationExchangeResponse_protocolIEs (ASN1CTXT* pctxt, UplinkInformationExchangeResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_UplinkInformationExchangeResponse_protocolIEs_element (pctxt, ((UplinkInformationExchangeResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolExtensions_ele  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UplinkInformationExchangeResponse_protocolExtensions_element (ASN1CTXT* pctxt, UplinkInformationExchangeResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_UplinkInformationExchangeResponse_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolExtensions_ele  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_UplinkInformationExchangeResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   UplinkInformationExchangeResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UplinkInformationExchangeResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = UplinkInformationExchangeResponseExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse_protocolExtensions      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UplinkInformationExchangeResponse_protocolExtensions (ASN1CTXT* pctxt, UplinkInformationExchangeResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_UplinkInformationExchangeResponse_protocolExtensions_element (pctxt, ((UplinkInformationExchangeResponse_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeResponse                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UplinkInformationExchangeResponse (ASN1CTXT* pctxt, UplinkInformationExchangeResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_UplinkInformationExchangeResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_UplinkInformationExchangeResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__UplinkInformationExchangeFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeFailureIEs_Value value = *((_UplinkInformationExchangeFailureIEs_Value*)pvalue_);
   stat = asn1PE_InformationExchangeID (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value_1              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__UplinkInformationExchangeFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeFailureIEs_Value_1 value = *((_UplinkInformationExchangeFailureIEs_Value_1*)pvalue_);
   stat = asn1PE_CN_DomainIndicator (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value_2              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__UplinkInformationExchangeFailureIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeFailureIEs_Value_2 *pvalue = (_UplinkInformationExchangeFailureIEs_Value_2*) pvalue_;
   stat = asn1PE_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value_3              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__UplinkInformationExchangeFailureIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeFailureIEs_Value_3 *pvalue = (_UplinkInformationExchangeFailureIEs_Value_3*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _UplinkInformationExchangeFailureIEs_Value_4              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__UplinkInformationExchangeFailureIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkInformationExchangeFailureIEs_Value_4 *pvalue = (_UplinkInformationExchangeFailureIEs_Value_4*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolIEs_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UplinkInformationExchangeFailure_protocolIEs_element (ASN1CTXT* pctxt, UplinkInformationExchangeFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_UplinkInformationExchangeFailure_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolIEs_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_UplinkInformationExchangeFailure_protocolIEs_element (ASN1CTXT* pctxt,
   UplinkInformationExchangeFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UplinkInformationExchangeFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeFailureIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = UplinkInformationExchangeFailureIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolIEs              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UplinkInformationExchangeFailure_protocolIEs (ASN1CTXT* pctxt, UplinkInformationExchangeFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_UplinkInformationExchangeFailure_protocolIEs_element (pctxt, ((UplinkInformationExchangeFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolExtensions_elem  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UplinkInformationExchangeFailure_protocolExtensions_element (ASN1CTXT* pctxt, UplinkInformationExchangeFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_UplinkInformationExchangeFailure_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolExtensions_elem  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_UplinkInformationExchangeFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   UplinkInformationExchangeFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UplinkInformationExchangeFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UplinkInformationExchangeFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == UplinkInformationExchangeFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = UplinkInformationExchangeFailureExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure_protocolExtensions       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UplinkInformationExchangeFailure_protocolExtensions (ASN1CTXT* pctxt, UplinkInformationExchangeFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_UplinkInformationExchangeFailure_protocolExtensions_element (pctxt, ((UplinkInformationExchangeFailure_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UplinkInformationExchangeFailure                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UplinkInformationExchangeFailure (ASN1CTXT* pctxt, UplinkInformationExchangeFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_UplinkInformationExchangeFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_UplinkInformationExchangeFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStartIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value *pvalue = (_MBMSSessionStartIEs_Value*) pvalue_;
   stat = asn1PE_TMGI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_1                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStartIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_1 *pvalue = (_MBMSSessionStartIEs_Value_1*) pvalue_;
   stat = asn1PE_MBMSSessionIdentity (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_2                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStartIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_2 value = *((_MBMSSessionStartIEs_Value_2*)pvalue_);
   stat = asn1PE_MBMSBearerServiceType (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_3                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStartIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_3 *pvalue = (_MBMSSessionStartIEs_Value_3*) pvalue_;
   stat = asn1PE_IuSignallingConnectionIdentifier (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_4                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStartIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_4 *pvalue = (_MBMSSessionStartIEs_Value_4*) pvalue_;
   stat = asn1PE_RAB_Parameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_5                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStartIEs_Value_5 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_5 *pvalue = (_MBMSSessionStartIEs_Value_5*) pvalue_;
   stat = asn1PE_PDP_TypeInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_6                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStartIEs_Value_6 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_6 *pvalue = (_MBMSSessionStartIEs_Value_6*) pvalue_;
   stat = asn1PE_MBMSSessionDuration (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_7                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStartIEs_Value_7 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_7 value = *((_MBMSSessionStartIEs_Value_7*)pvalue_);
   stat = asn1PE_MBMSServiceArea (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_8                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStartIEs_Value_8 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_8 value = *((_MBMSSessionStartIEs_Value_8*)pvalue_);
   stat = asn1PE_FrequenceLayerConvergenceFlag (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_9                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStartIEs_Value_9 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_9 *pvalue = (_MBMSSessionStartIEs_Value_9*) pvalue_;
   stat = asn1PE_RAListofIdleModeUEs (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_10                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStartIEs_Value_10 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_10 *pvalue = (_MBMSSessionStartIEs_Value_10*) pvalue_;
   stat = asn1PE_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_11                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStartIEs_Value_11 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_11 value = *((_MBMSSessionStartIEs_Value_11*)pvalue_);
   stat = asn1PE_MBMSSessionRepetitionNumber (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartIEs_Value_12                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStartIEs_Value_12 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartIEs_Value_12 *pvalue = (_MBMSSessionStartIEs_Value_12*) pvalue_;
   stat = asn1PE_TimeToMBMSDataTransfer (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStart_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionStart_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSSessionStart_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolIEs_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSSessionStart_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionStart_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStartIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSSessionStartIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolIEs                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStart_protocolIEs (ASN1CTXT* pctxt, MBMSSessionStart_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSSessionStart_protocolIEs_element (pctxt, ((MBMSSessionStart_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStart_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionStart_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSSessionStart_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolExtensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSSessionStart_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionStart_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStartExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSSessionStartExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart_protocolExtensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStart_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionStart_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSSessionStart_protocolExtensions_element (pctxt, ((MBMSSessionStart_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStart                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStart (ASN1CTXT* pctxt, MBMSSessionStart* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSSessionStart_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSSessionStart_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartResponseIEs_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStartResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartResponseIEs_Value *pvalue = (_MBMSSessionStartResponseIEs_Value*) pvalue_;
   stat = asn1PE_TransportLayerInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartResponseIEs_Value_1                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStartResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartResponseIEs_Value_1 *pvalue = (_MBMSSessionStartResponseIEs_Value_1*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartResponseIEs_Value_2                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStartResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartResponseIEs_Value_2 *pvalue = (_MBMSSessionStartResponseIEs_Value_2*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStartResponse_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionStartResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSSessionStartResponse_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSSessionStartResponse_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionStartResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStartResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartResponseIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSSessionStartResponseIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolIEs                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStartResponse_protocolIEs (ASN1CTXT* pctxt, MBMSSessionStartResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSSessionStartResponse_protocolIEs_element (pctxt, ((MBMSSessionStartResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStartResponse_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionStartResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSSessionStartResponse_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSSessionStartResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionStartResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStartResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSSessionStartResponseExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse_protocolExtensions               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStartResponse_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionStartResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSSessionStartResponse_protocolExtensions_element (pctxt, ((MBMSSessionStartResponse_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartResponse                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStartResponse (ASN1CTXT* pctxt, MBMSSessionStartResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSSessionStartResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSSessionStartResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartFailureIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStartFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartFailureIEs_Value *pvalue = (_MBMSSessionStartFailureIEs_Value*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStartFailureIEs_Value_1                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStartFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStartFailureIEs_Value_1 *pvalue = (_MBMSSessionStartFailureIEs_Value_1*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStartFailure_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionStartFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSSessionStartFailure_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSSessionStartFailure_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionStartFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStartFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartFailureIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSSessionStartFailureIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolIEs                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStartFailure_protocolIEs (ASN1CTXT* pctxt, MBMSSessionStartFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSSessionStartFailure_protocolIEs_element (pctxt, ((MBMSSessionStartFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStartFailure_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionStartFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSSessionStartFailure_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSSessionStartFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionStartFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStartFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStartFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStartFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSSessionStartFailureExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure_protocolExtensions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStartFailure_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionStartFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSSessionStartFailure_protocolExtensions_element (pctxt, ((MBMSSessionStartFailure_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStartFailure                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStartFailure (ASN1CTXT* pctxt, MBMSSessionStartFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSSessionStartFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSSessionStartFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateIEs_Value                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionUpdateIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateIEs_Value value = *((_MBMSSessionUpdateIEs_Value*)pvalue_);
   stat = asn1PE_SessionUpdateID (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateIEs_Value_1                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionUpdateIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateIEs_Value_1 *pvalue = (_MBMSSessionUpdateIEs_Value_1*) pvalue_;
   stat = asn1PE_DeltaRAListofIdleModeUEs (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionUpdate_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionUpdate_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSSessionUpdate_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolIEs_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSSessionUpdate_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionUpdate_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionUpdateIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSSessionUpdateIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolIEs                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionUpdate_protocolIEs (ASN1CTXT* pctxt, MBMSSessionUpdate_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSSessionUpdate_protocolIEs_element (pctxt, ((MBMSSessionUpdate_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionUpdate_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionUpdate_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSSessionUpdate_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolExtensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSSessionUpdate_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionUpdate_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionUpdateExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSSessionUpdateExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate_protocolExtensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionUpdate_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionUpdate_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSSessionUpdate_protocolExtensions_element (pctxt, ((MBMSSessionUpdate_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdate                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionUpdate (ASN1CTXT* pctxt, MBMSSessionUpdate* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSSessionUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSSessionUpdate_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateResponseIEs_Value                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionUpdateResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateResponseIEs_Value value = *((_MBMSSessionUpdateResponseIEs_Value*)pvalue_);
   stat = asn1PE_SessionUpdateID (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateResponseIEs_Value_1                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionUpdateResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateResponseIEs_Value_1 *pvalue = (_MBMSSessionUpdateResponseIEs_Value_1*) pvalue_;
   stat = asn1PE_TransportLayerInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateResponseIEs_Value_2                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionUpdateResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateResponseIEs_Value_2 *pvalue = (_MBMSSessionUpdateResponseIEs_Value_2*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateResponseIEs_Value_3                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionUpdateResponseIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateResponseIEs_Value_3 *pvalue = (_MBMSSessionUpdateResponseIEs_Value_3*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolIEs_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionUpdateResponse_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionUpdateResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSSessionUpdateResponse_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolIEs_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSSessionUpdateResponse_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionUpdateResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionUpdateResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateResponseIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSSessionUpdateResponseIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolIEs                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionUpdateResponse_protocolIEs (ASN1CTXT* pctxt, MBMSSessionUpdateResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSSessionUpdateResponse_protocolIEs_element (pctxt, ((MBMSSessionUpdateResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolExtensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionUpdateResponse_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionUpdateResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSSessionUpdateResponse_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolExtensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSSessionUpdateResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionUpdateResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionUpdateResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSSessionUpdateResponseExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse_protocolExtensions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionUpdateResponse_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionUpdateResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSSessionUpdateResponse_protocolExtensions_element (pctxt, ((MBMSSessionUpdateResponse_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateResponse                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionUpdateResponse (ASN1CTXT* pctxt, MBMSSessionUpdateResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSSessionUpdateResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSSessionUpdateResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateFailureIEs_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionUpdateFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateFailureIEs_Value value = *((_MBMSSessionUpdateFailureIEs_Value*)pvalue_);
   stat = asn1PE_SessionUpdateID (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateFailureIEs_Value_1                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionUpdateFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateFailureIEs_Value_1 *pvalue = (_MBMSSessionUpdateFailureIEs_Value_1*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionUpdateFailureIEs_Value_2                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionUpdateFailureIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionUpdateFailureIEs_Value_2 *pvalue = (_MBMSSessionUpdateFailureIEs_Value_2*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionUpdateFailure_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionUpdateFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSSessionUpdateFailure_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSSessionUpdateFailure_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionUpdateFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionUpdateFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateFailureIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSSessionUpdateFailureIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolIEs                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionUpdateFailure_protocolIEs (ASN1CTXT* pctxt, MBMSSessionUpdateFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSSessionUpdateFailure_protocolIEs_element (pctxt, ((MBMSSessionUpdateFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionUpdateFailure_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionUpdateFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSSessionUpdateFailure_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSSessionUpdateFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionUpdateFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionUpdateFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionUpdateFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionUpdateFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSSessionUpdateFailureExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure_protocolExtensions               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionUpdateFailure_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionUpdateFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSSessionUpdateFailure_protocolExtensions_element (pctxt, ((MBMSSessionUpdateFailure_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionUpdateFailure                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionUpdateFailure (ASN1CTXT* pctxt, MBMSSessionUpdateFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSSessionUpdateFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSSessionUpdateFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStopIEs_Value                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStopIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStopIEs_Value value = *((_MBMSSessionStopIEs_Value*)pvalue_);
   stat = asn1PE_MBMSCNDe_Registration (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolIEs_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStop_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionStop_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSSessionStop_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolIEs_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSSessionStop_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionStop_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStopIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStopIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStopIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSSessionStopIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolIEs                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStop_protocolIEs (ASN1CTXT* pctxt, MBMSSessionStop_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSSessionStop_protocolIEs_element (pctxt, ((MBMSSessionStop_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolExtensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStop_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionStop_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSSessionStop_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolExtensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSSessionStop_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionStop_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStopExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStopExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStopExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSSessionStopExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop_protocolExtensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStop_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionStop_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSSessionStop_protocolExtensions_element (pctxt, ((MBMSSessionStop_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStop                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStop (ASN1CTXT* pctxt, MBMSSessionStop* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSSessionStop_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSSessionStop_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStopResponseIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStopResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStopResponseIEs_Value *pvalue = (_MBMSSessionStopResponseIEs_Value*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSSessionStopResponseIEs_Value_1                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSSessionStopResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSSessionStopResponseIEs_Value_1 *pvalue = (_MBMSSessionStopResponseIEs_Value_1*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStopResponse_protocolIEs_element (ASN1CTXT* pctxt, MBMSSessionStopResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSSessionStopResponse_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSSessionStopResponse_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSSessionStopResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStopResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStopResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStopResponseIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSSessionStopResponseIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolIEs                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStopResponse_protocolIEs (ASN1CTXT* pctxt, MBMSSessionStopResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSSessionStopResponse_protocolIEs_element (pctxt, ((MBMSSessionStopResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStopResponse_protocolExtensions_element (ASN1CTXT* pctxt, MBMSSessionStopResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSSessionStopResponse_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSSessionStopResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSSessionStopResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSSessionStopResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSSessionStopResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSSessionStopResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSSessionStopResponseExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse_protocolExtensions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStopResponse_protocolExtensions (ASN1CTXT* pctxt, MBMSSessionStopResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSSessionStopResponse_protocolExtensions_element (pctxt, ((MBMSSessionStopResponse_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionStopResponse                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionStopResponse (ASN1CTXT* pctxt, MBMSSessionStopResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSSessionStopResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSSessionStopResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSUELinkingRequestIEs_Value                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSUELinkingRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSUELinkingRequestIEs_Value *pvalue = (_MBMSUELinkingRequestIEs_Value*) pvalue_;
   stat = asn1PE_JoinedMBMSBearerService_IEs (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs_element_iE_Extensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LeftMBMSBearerService_IEs_element_iE_Extensions_element (ASN1CTXT* pctxt, LeftMBMSBearerService_IEs_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_LeftMBMSBearerService_IEs_element_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs_element_iE_Extensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_LeftMBMSBearerService_IEs_element_iE_Extensions_element (ASN1CTXT* pctxt,
   LeftMBMSBearerService_IEs_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LeftMBMSBearerService_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LeftMBMSBearerService_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LeftMBMSBearerService_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = LeftMBMSBearerService_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs_element_iE_Extensions           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LeftMBMSBearerService_IEs_element_iE_Extensions (ASN1CTXT* pctxt, LeftMBMSBearerService_IEs_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_LeftMBMSBearerService_IEs_element_iE_Extensions_element (pctxt, ((LeftMBMSBearerService_IEs_element_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LeftMBMSBearerService_IEs_element (ASN1CTXT* pctxt, LeftMBMSBearerService_IEs_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode tMGI */

   stat = asn1PE_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_LeftMBMSBearerService_IEs_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LeftMBMSBearerService_IEs                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LeftMBMSBearerService_IEs (ASN1CTXT* pctxt, LeftMBMSBearerService_IEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_LeftMBMSBearerService_IEs_element (pctxt, ((LeftMBMSBearerService_IEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSUELinkingRequestIEs_Value_1                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSUELinkingRequestIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSUELinkingRequestIEs_Value_1 *pvalue = (_MBMSUELinkingRequestIEs_Value_1*) pvalue_;
   stat = asn1PE_LeftMBMSBearerService_IEs (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSUELinkingRequest_protocolIEs_element (ASN1CTXT* pctxt, MBMSUELinkingRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSUELinkingRequest_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolIEs_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSUELinkingRequest_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSUELinkingRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSUELinkingRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSUELinkingRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSUELinkingRequestIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSUELinkingRequestIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolIEs                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSUELinkingRequest_protocolIEs (ASN1CTXT* pctxt, MBMSUELinkingRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSUELinkingRequest_protocolIEs_element (pctxt, ((MBMSUELinkingRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSUELinkingRequest_protocolExtensions_element (ASN1CTXT* pctxt, MBMSUELinkingRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSUELinkingRequest_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolExtensions_element           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSUELinkingRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSUELinkingRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSUELinkingRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSUELinkingRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSUELinkingRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSUELinkingRequestExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest_protocolExtensions                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSUELinkingRequest_protocolExtensions (ASN1CTXT* pctxt, MBMSUELinkingRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSUELinkingRequest_protocolExtensions_element (pctxt, ((MBMSUELinkingRequest_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingRequest                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSUELinkingRequest (ASN1CTXT* pctxt, MBMSUELinkingRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSUELinkingRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSUELinkingRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs_element_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UnsuccessfulLinking_IEs_element_iE_Extensions_element (ASN1CTXT* pctxt, UnsuccessfulLinking_IEs_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_UnsuccessfulLinking_IEs_element_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs_element_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_UnsuccessfulLinking_IEs_element_iE_Extensions_element (ASN1CTXT* pctxt,
   UnsuccessfulLinking_IEs_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UnsuccessfulLinking_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UnsuccessfulLinking_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UnsuccessfulLinking_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = UnsuccessfulLinking_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs_element_iE_Extensions             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UnsuccessfulLinking_IEs_element_iE_Extensions (ASN1CTXT* pctxt, UnsuccessfulLinking_IEs_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_UnsuccessfulLinking_IEs_element_iE_Extensions_element (pctxt, ((UnsuccessfulLinking_IEs_element_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UnsuccessfulLinking_IEs_element (ASN1CTXT* pctxt, UnsuccessfulLinking_IEs_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode tMGI */

   stat = asn1PE_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode cause */

   stat = asn1PE_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_UnsuccessfulLinking_IEs_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfulLinking_IEs                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UnsuccessfulLinking_IEs (ASN1CTXT* pctxt, UnsuccessfulLinking_IEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_UnsuccessfulLinking_IEs_element (pctxt, ((UnsuccessfulLinking_IEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSUELinkingResponseIEs_Value                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSUELinkingResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSUELinkingResponseIEs_Value *pvalue = (_MBMSUELinkingResponseIEs_Value*) pvalue_;
   stat = asn1PE_UnsuccessfulLinking_IEs (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSUELinkingResponseIEs_Value_1                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSUELinkingResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSUELinkingResponseIEs_Value_1 *pvalue = (_MBMSUELinkingResponseIEs_Value_1*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSUELinkingResponse_protocolIEs_element (ASN1CTXT* pctxt, MBMSUELinkingResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSUELinkingResponse_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSUELinkingResponse_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSUELinkingResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSUELinkingResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSUELinkingResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSUELinkingResponseIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSUELinkingResponseIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolIEs                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSUELinkingResponse_protocolIEs (ASN1CTXT* pctxt, MBMSUELinkingResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSUELinkingResponse_protocolIEs_element (pctxt, ((MBMSUELinkingResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSUELinkingResponse_protocolExtensions_element (ASN1CTXT* pctxt, MBMSUELinkingResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSUELinkingResponse_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSUELinkingResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSUELinkingResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSUELinkingResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSUELinkingResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSUELinkingResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSUELinkingResponseExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse_protocolExtensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSUELinkingResponse_protocolExtensions (ASN1CTXT* pctxt, MBMSUELinkingResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSUELinkingResponse_protocolExtensions_element (pctxt, ((MBMSUELinkingResponse_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSUELinkingResponse                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSUELinkingResponse (ASN1CTXT* pctxt, MBMSUELinkingResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSUELinkingResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSUELinkingResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSRegistrationRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationRequestIEs_Value value = *((_MBMSRegistrationRequestIEs_Value*)pvalue_);
   stat = asn1PE_MBMSRegistrationRequestType (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value_1                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSRegistrationRequestIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationRequestIEs_Value_1 *pvalue = (_MBMSRegistrationRequestIEs_Value_1*) pvalue_;
   stat = asn1PE_TMGI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value_2                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSRegistrationRequestIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationRequestIEs_Value_2 *pvalue = (_MBMSRegistrationRequestIEs_Value_2*) pvalue_;
   stat = asn1PE_IPMulticastAddress (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value_3                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSRegistrationRequestIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationRequestIEs_Value_3 *pvalue = (_MBMSRegistrationRequestIEs_Value_3*) pvalue_;
   stat = asn1PE_APN (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationRequestIEs_Value_4                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSRegistrationRequestIEs_Value_4 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationRequestIEs_Value_4 *pvalue = (_MBMSRegistrationRequestIEs_Value_4*) pvalue_;
   stat = asn1PE_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRegistrationRequest_protocolIEs_element (ASN1CTXT* pctxt, MBMSRegistrationRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSRegistrationRequest_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSRegistrationRequest_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRegistrationRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRegistrationRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationRequestIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSRegistrationRequestIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolIEs                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRegistrationRequest_protocolIEs (ASN1CTXT* pctxt, MBMSRegistrationRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSRegistrationRequest_protocolIEs_element (pctxt, ((MBMSRegistrationRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRegistrationRequest_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRegistrationRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSRegistrationRequest_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSRegistrationRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRegistrationRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRegistrationRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSRegistrationRequestExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest_protocolExtensions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRegistrationRequest_protocolExtensions (ASN1CTXT* pctxt, MBMSRegistrationRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSRegistrationRequest_protocolExtensions_element (pctxt, ((MBMSRegistrationRequest_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequest                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRegistrationRequest (ASN1CTXT* pctxt, MBMSRegistrationRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSRegistrationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSRegistrationRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationResponseIEs_Value                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSRegistrationResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationResponseIEs_Value *pvalue = (_MBMSRegistrationResponseIEs_Value*) pvalue_;
   stat = asn1PE_TMGI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationResponseIEs_Value_1                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSRegistrationResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationResponseIEs_Value_1 *pvalue = (_MBMSRegistrationResponseIEs_Value_1*) pvalue_;
   stat = asn1PE_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationResponseIEs_Value_2                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSRegistrationResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationResponseIEs_Value_2 *pvalue = (_MBMSRegistrationResponseIEs_Value_2*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRegistrationResponse_protocolIEs_element (ASN1CTXT* pctxt, MBMSRegistrationResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSRegistrationResponse_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolIEs_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSRegistrationResponse_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRegistrationResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRegistrationResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationResponseIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSRegistrationResponseIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolIEs                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRegistrationResponse_protocolIEs (ASN1CTXT* pctxt, MBMSRegistrationResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSRegistrationResponse_protocolIEs_element (pctxt, ((MBMSRegistrationResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRegistrationResponse_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRegistrationResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSRegistrationResponse_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolExtensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSRegistrationResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRegistrationResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRegistrationResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSRegistrationResponseExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse_protocolExtensions               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRegistrationResponse_protocolExtensions (ASN1CTXT* pctxt, MBMSRegistrationResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSRegistrationResponse_protocolExtensions_element (pctxt, ((MBMSRegistrationResponse_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationResponse                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRegistrationResponse (ASN1CTXT* pctxt, MBMSRegistrationResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSRegistrationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSRegistrationResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationFailureIEs_Value                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSRegistrationFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationFailureIEs_Value *pvalue = (_MBMSRegistrationFailureIEs_Value*) pvalue_;
   stat = asn1PE_TMGI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationFailureIEs_Value_1                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSRegistrationFailureIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationFailureIEs_Value_1 *pvalue = (_MBMSRegistrationFailureIEs_Value_1*) pvalue_;
   stat = asn1PE_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationFailureIEs_Value_2                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSRegistrationFailureIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationFailureIEs_Value_2 *pvalue = (_MBMSRegistrationFailureIEs_Value_2*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRegistrationFailureIEs_Value_3                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSRegistrationFailureIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRegistrationFailureIEs_Value_3 *pvalue = (_MBMSRegistrationFailureIEs_Value_3*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRegistrationFailure_protocolIEs_element (ASN1CTXT* pctxt, MBMSRegistrationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSRegistrationFailure_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolIEs_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSRegistrationFailure_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRegistrationFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRegistrationFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationFailureIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSRegistrationFailureIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolIEs                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRegistrationFailure_protocolIEs (ASN1CTXT* pctxt, MBMSRegistrationFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSRegistrationFailure_protocolIEs_element (pctxt, ((MBMSRegistrationFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRegistrationFailure_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRegistrationFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSRegistrationFailure_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolExtensions_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSRegistrationFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRegistrationFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRegistrationFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRegistrationFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRegistrationFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSRegistrationFailureExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure_protocolExtensions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRegistrationFailure_protocolExtensions (ASN1CTXT* pctxt, MBMSRegistrationFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSRegistrationFailure_protocolExtensions_element (pctxt, ((MBMSRegistrationFailure_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationFailure                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRegistrationFailure (ASN1CTXT* pctxt, MBMSRegistrationFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSRegistrationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSRegistrationFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationRequestIEs_Value                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSCNDe_RegistrationRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSCNDe_RegistrationRequestIEs_Value *pvalue = (_MBMSCNDe_RegistrationRequestIEs_Value*) pvalue_;
   stat = asn1PE_TMGI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationRequestIEs_Value_1                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSCNDe_RegistrationRequestIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSCNDe_RegistrationRequestIEs_Value_1 *pvalue = (_MBMSCNDe_RegistrationRequestIEs_Value_1*) pvalue_;
   stat = asn1PE_GlobalCN_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolIEs_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSCNDe_RegistrationRequest_protocolIEs_element (ASN1CTXT* pctxt, MBMSCNDe_RegistrationRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSCNDe_RegistrationRequest_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolIEs_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSCNDe_RegistrationRequest_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSCNDe_RegistrationRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSCNDe_RegistrationRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSCNDe_RegistrationRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSCNDe_RegistrationRequestIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSCNDe_RegistrationRequestIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolIEs                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSCNDe_RegistrationRequest_protocolIEs (ASN1CTXT* pctxt, MBMSCNDe_RegistrationRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSCNDe_RegistrationRequest_protocolIEs_element (pctxt, ((MBMSCNDe_RegistrationRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSCNDe_RegistrationRequest_protocolExtensions_element (ASN1CTXT* pctxt, MBMSCNDe_RegistrationRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSCNDe_RegistrationRequest_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolExtensions_element   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSCNDe_RegistrationRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSCNDe_RegistrationRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSCNDe_RegistrationRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSCNDe_RegistrationRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSCNDe_RegistrationRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSCNDe_RegistrationRequestExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest_protocolExtensions           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSCNDe_RegistrationRequest_protocolExtensions (ASN1CTXT* pctxt, MBMSCNDe_RegistrationRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSCNDe_RegistrationRequest_protocolExtensions_element (pctxt, ((MBMSCNDe_RegistrationRequest_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationRequest                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSCNDe_RegistrationRequest (ASN1CTXT* pctxt, MBMSCNDe_RegistrationRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSCNDe_RegistrationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSCNDe_RegistrationRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationResponseIEs_Value                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSCNDe_RegistrationResponseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSCNDe_RegistrationResponseIEs_Value *pvalue = (_MBMSCNDe_RegistrationResponseIEs_Value*) pvalue_;
   stat = asn1PE_TMGI (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationResponseIEs_Value_1                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSCNDe_RegistrationResponseIEs_Value_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSCNDe_RegistrationResponseIEs_Value_1 *pvalue = (_MBMSCNDe_RegistrationResponseIEs_Value_1*) pvalue_;
   stat = asn1PE_GlobalRNC_ID (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationResponseIEs_Value_2                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSCNDe_RegistrationResponseIEs_Value_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSCNDe_RegistrationResponseIEs_Value_2 *pvalue = (_MBMSCNDe_RegistrationResponseIEs_Value_2*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSCNDe_RegistrationResponseIEs_Value_3                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSCNDe_RegistrationResponseIEs_Value_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSCNDe_RegistrationResponseIEs_Value_3 *pvalue = (_MBMSCNDe_RegistrationResponseIEs_Value_3*) pvalue_;
   stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolIEs_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSCNDe_RegistrationResponse_protocolIEs_element (ASN1CTXT* pctxt, MBMSCNDe_RegistrationResponse_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSCNDe_RegistrationResponse_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolIEs_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSCNDe_RegistrationResponse_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSCNDe_RegistrationResponse_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSCNDe_RegistrationResponseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSCNDe_RegistrationResponseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSCNDe_RegistrationResponseIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSCNDe_RegistrationResponseIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolIEs                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSCNDe_RegistrationResponse_protocolIEs (ASN1CTXT* pctxt, MBMSCNDe_RegistrationResponse_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSCNDe_RegistrationResponse_protocolIEs_element (pctxt, ((MBMSCNDe_RegistrationResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolExtensions_element  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSCNDe_RegistrationResponse_protocolExtensions_element (ASN1CTXT* pctxt, MBMSCNDe_RegistrationResponse_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSCNDe_RegistrationResponse_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolExtensions_element  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSCNDe_RegistrationResponse_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSCNDe_RegistrationResponse_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSCNDe_RegistrationResponseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSCNDe_RegistrationResponseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSCNDe_RegistrationResponseExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSCNDe_RegistrationResponseExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse_protocolExtensions          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSCNDe_RegistrationResponse_protocolExtensions (ASN1CTXT* pctxt, MBMSCNDe_RegistrationResponse_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSCNDe_RegistrationResponse_protocolExtensions_element (pctxt, ((MBMSCNDe_RegistrationResponse_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_RegistrationResponse                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSCNDe_RegistrationResponse (ASN1CTXT* pctxt, MBMSCNDe_RegistrationResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSCNDe_RegistrationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSCNDe_RegistrationResponse_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRABEstablishmentIndicationIEs_Value                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSRABEstablishmentIndicationIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRABEstablishmentIndicationIEs_Value *pvalue = (_MBMSRABEstablishmentIndicationIEs_Value*) pvalue_;
   stat = asn1PE_TransportLayerInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolIEs_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABEstablishmentIndication_protocolIEs_element (ASN1CTXT* pctxt, MBMSRABEstablishmentIndication_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSRABEstablishmentIndication_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolIEs_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSRABEstablishmentIndication_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRABEstablishmentIndication_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABEstablishmentIndicationIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABEstablishmentIndicationIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABEstablishmentIndicationIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSRABEstablishmentIndicationIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolIEs                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABEstablishmentIndication_protocolIEs (ASN1CTXT* pctxt, MBMSRABEstablishmentIndication_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSRABEstablishmentIndication_protocolIEs_element (pctxt, ((MBMSRABEstablishmentIndication_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolExtensions_elemen  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABEstablishmentIndication_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRABEstablishmentIndication_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSRABEstablishmentIndication_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolExtensions_elemen  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSRABEstablishmentIndication_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRABEstablishmentIndication_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABEstablishmentIndicationExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABEstablishmentIndicationExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABEstablishmentIndicationExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSRABEstablishmentIndicationExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication_protocolExtensions         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABEstablishmentIndication_protocolExtensions (ASN1CTXT* pctxt, MBMSRABEstablishmentIndication_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSRABEstablishmentIndication_protocolExtensions_element (pctxt, ((MBMSRABEstablishmentIndication_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABEstablishmentIndication                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABEstablishmentIndication (ASN1CTXT* pctxt, MBMSRABEstablishmentIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSRABEstablishmentIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSRABEstablishmentIndication_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRABReleaseRequestIEs_Value                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSRABReleaseRequestIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRABReleaseRequestIEs_Value *pvalue = (_MBMSRABReleaseRequestIEs_Value*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABReleaseRequest_protocolIEs_element (ASN1CTXT* pctxt, MBMSRABReleaseRequest_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSRABReleaseRequest_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSRABReleaseRequest_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRABReleaseRequest_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABReleaseRequestIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseRequestIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseRequestIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSRABReleaseRequestIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolIEs                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABReleaseRequest_protocolIEs (ASN1CTXT* pctxt, MBMSRABReleaseRequest_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSRABReleaseRequest_protocolIEs_element (pctxt, ((MBMSRABReleaseRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABReleaseRequest_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRABReleaseRequest_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSRABReleaseRequest_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSRABReleaseRequest_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRABReleaseRequest_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABReleaseRequestExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseRequestExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseRequestExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSRABReleaseRequestExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest_protocolExtensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABReleaseRequest_protocolExtensions (ASN1CTXT* pctxt, MBMSRABReleaseRequest_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSRABReleaseRequest_protocolExtensions_element (pctxt, ((MBMSRABReleaseRequest_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseRequest                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABReleaseRequest (ASN1CTXT* pctxt, MBMSRABReleaseRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSRABReleaseRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSRABReleaseRequest_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRABReleaseIEs_Value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSRABReleaseIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRABReleaseIEs_Value *pvalue = (_MBMSRABReleaseIEs_Value*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABRelease_protocolIEs_element (ASN1CTXT* pctxt, MBMSRABRelease_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSRABRelease_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolIEs_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSRABRelease_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRABRelease_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABReleaseIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSRABReleaseIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolIEs                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABRelease_protocolIEs (ASN1CTXT* pctxt, MBMSRABRelease_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSRABRelease_protocolIEs_element (pctxt, ((MBMSRABRelease_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABRelease_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRABRelease_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSRABRelease_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolExtensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSRABRelease_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRABRelease_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABReleaseExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSRABReleaseExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease_protocolExtensions                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABRelease_protocolExtensions (ASN1CTXT* pctxt, MBMSRABRelease_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSRABRelease_protocolExtensions_element (pctxt, ((MBMSRABRelease_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABRelease                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABRelease (ASN1CTXT* pctxt, MBMSRABRelease* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSRABRelease_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSRABRelease_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _MBMSRABReleaseFailureIEs_Value                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__MBMSRABReleaseFailureIEs_Value (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _MBMSRABReleaseFailureIEs_Value *pvalue = (_MBMSRABReleaseFailureIEs_Value*) pvalue_;
   stat = asn1PE_Cause (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABReleaseFailure_protocolIEs_element (ASN1CTXT* pctxt, MBMSRABReleaseFailure_protocolIEs_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSRABReleaseFailure_protocolIEs_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.encoded.numocts, pvalue->value.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolIEs_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSRABReleaseFailure_protocolIEs_element (ASN1CTXT* pctxt,
   MBMSRABReleaseFailure_protocolIEs_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABReleaseFailureIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseFailureIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseFailureIEs_Size) return 0;

   /* check value */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSRABReleaseFailureIEs[index].encodeValue(pctxt, pvalue->value.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->value.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->value.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolIEs                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABReleaseFailure_protocolIEs (ASN1CTXT* pctxt, MBMSRABReleaseFailure_protocolIEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(0), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSRABReleaseFailure_protocolIEs_element (pctxt, ((MBMSRABReleaseFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABReleaseFailure_protocolExtensions_element (ASN1CTXT* pctxt, MBMSRABReleaseFailure_protocolExtensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSRABReleaseFailure_protocolExtensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolExtensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSRABReleaseFailure_protocolExtensions_element (ASN1CTXT* pctxt,
   MBMSRABReleaseFailure_protocolExtensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSRABReleaseFailureExtensions_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSRABReleaseFailureExtensions[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSRABReleaseFailureExtensions_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSRABReleaseFailureExtensions[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure_protocolExtensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABReleaseFailure_protocolExtensions (ASN1CTXT* pctxt, MBMSRABReleaseFailure_protocolExtensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSRABReleaseFailure_protocolExtensions_element (pctxt, ((MBMSRABReleaseFailure_protocolExtensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRABReleaseFailure                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRABReleaseFailure (ASN1CTXT* pctxt, MBMSRABReleaseFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_MBMSRABReleaseFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_MBMSRABReleaseFailure_protocolExtensions (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

