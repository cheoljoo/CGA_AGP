/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.83, Date: 20-Mar-2007.
 */
#include "asn1intl.h"
#include "RANAP-IEsTable.h"

/**************************************************************/
/*                                                            */
/*  CauseRadioNetwork                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CauseRadioNetwork (ASN1CTXT* pctxt, CauseRadioNetwork value)
{
   int stat = 0;

   if ( (value >= 1 && value <= 64) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(64));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseTransmissionNetwork                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CauseTransmissionNetwork (ASN1CTXT* pctxt, CauseTransmissionNetwork value)
{
   int stat = 0;

   if ( (value >= 65 && value <= 80) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(65), OSUINTCONST(80));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseNAS                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CauseNAS (ASN1CTXT* pctxt, CauseNAS value)
{
   int stat = 0;

   if ( (value >= 81 && value <= 96) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(81), OSUINTCONST(96));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseProtocol                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CauseProtocol (ASN1CTXT* pctxt, CauseProtocol value)
{
   int stat = 0;

   if ( (value >= 97 && value <= 112) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(97), OSUINTCONST(112));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseMisc                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CauseMisc (ASN1CTXT* pctxt, CauseMisc value)
{
   int stat = 0;

   if ( (value >= 113 && value <= 128) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(113), OSUINTCONST(128));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseNon_Standard                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CauseNon_Standard (ASN1CTXT* pctxt, CauseNon_Standard value)
{
   int stat = 0;

   if ( (value >= 129 && value <= 256) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(129), OSUINTCONST(256));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CauseRadioNetworkExtension                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CauseRadioNetworkExtension (ASN1CTXT* pctxt, CauseRadioNetworkExtension value)
{
   int stat = 0;

   if ( (value >= 257 && value <= 512) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(257), OSUINTCONST(512));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cause                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Cause (ASN1CTXT* pctxt, Cause* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 6);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 5);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* radioNetwork */
         case 1:
            stat = asn1PE_CauseRadioNetwork (pctxt, pvalue->u.radioNetwork);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* transmissionNetwork */
         case 2:
            stat = asn1PE_CauseTransmissionNetwork (pctxt, pvalue->u.transmissionNetwork);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* nAS */
         case 3:
            stat = asn1PE_CauseNAS (pctxt, pvalue->u.nAS);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* protocol */
         case 4:
            stat = asn1PE_CauseProtocol (pctxt, pvalue->u.protocol);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* misc */
         case 5:
            stat = asn1PE_CauseMisc (pctxt, pvalue->u.misc);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* non_Standard */
         case 6:
            stat = asn1PE_CauseNon_Standard (pctxt, pvalue->u.non_Standard);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 7);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      rtInitSubContext (&lctxt, pctxt);
      stat = pu_setBuffer (&lctxt, 0, 0, pctxt->buffer.aligned);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      switch (pvalue->t)
      {
         /* radioNetworkExtension */
         case 7:
            stat = asn1PE_CauseRadioNetworkExtension (&lctxt, pvalue->u.radioNetworkExtension);
            if (stat != 0) {
               rtFreeContext (&lctxt);
               return LOG_ASN1ERR (pctxt, stat);
            }
            openType.data = pe_GetMsgPtr (&lctxt, (int*)&openType.numocts);
            break;

         default:
            openType.numocts = pvalue->u.extElem1->numocts;
            openType.data = pvalue->u.extElem1->data;
      }

      stat = pe_byte_align (pctxt);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      rtFreeContext (&lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_ID (ASN1CTXT* pctxt, RAB_ID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnsuccessfullyTransmittedDataVolume                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UnsuccessfullyTransmittedDataVolume (ASN1CTXT* pctxt, UnsuccessfullyTransmittedDataVolume value)
{
   int stat = 0;

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINT32_MAX);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReference                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DataVolumeReference (ASN1CTXT* pctxt, DataVolumeReference value)
{
   int stat = 0;

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_GTP_PDU_SequenceNumber                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_GTP_PDU_SequenceNumber (ASN1CTXT* pctxt, DL_GTP_PDU_SequenceNumber value)
{
   int stat = 0;

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_GTP_PDU_SequenceNumber                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_GTP_PDU_SequenceNumber (ASN1CTXT* pctxt, UL_GTP_PDU_SequenceNumber value)
{
   int stat = 0;

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RepetitionNumber0                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RepetitionNumber0 (ASN1CTXT* pctxt, RepetitionNumber0 value)
{
   int stat = 0;

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RepetitionNumber1                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RepetitionNumber1 (ASN1CTXT* pctxt, RepetitionNumber1 value)
{
   int stat = 0;

   if ( (value >= 1 && value <= 256) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(256));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageStructure_element_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MessageStructure_element_iE_Extensions_element (ASN1CTXT* pctxt, MessageStructure_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MessageStructure_element_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageStructure_element_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MessageStructure_element_iE_Extensions_element (ASN1CTXT* pctxt,
   MessageStructure_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MessageStructure_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MessageStructure_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MessageStructure_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MessageStructure_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MessageStructure_element_iE_Extensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MessageStructure_element_iE_Extensions (ASN1CTXT* pctxt, MessageStructure_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MessageStructure_element_iE_Extensions_element (pctxt, ((MessageStructure_element_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageStructure_element                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MessageStructure_element (ASN1CTXT* pctxt, MessageStructure_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.repetitionNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_ID */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->iE_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode repetitionNumber */

   if (pvalue->m.repetitionNumberPresent) {
      stat = asn1PE_RepetitionNumber1 (pctxt, pvalue->repetitionNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_MessageStructure_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageStructure                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MessageStructure (ASN1CTXT* pctxt, MessageStructure* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MessageStructure_element (pctxt, ((MessageStructure_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CriticalityDiagnostics_IE_List_ExtIEs_Extension          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__CriticalityDiagnostics_IE_List_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CriticalityDiagnostics_IE_List_ExtIEs_Extension *pvalue = (_CriticalityDiagnostics_IE_List_ExtIEs_Extension*) pvalue_;
   stat = asn1PE_MessageStructure (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TypeOfError                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TypeOfError (ASN1CTXT* pctxt, TypeOfError value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case not_understood: ui = 0; break;
      case missing: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CriticalityDiagnostics_IE_List_ExtIEs_Extension_1        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__CriticalityDiagnostics_IE_List_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CriticalityDiagnostics_IE_List_ExtIEs_Extension_1 value = *((_CriticalityDiagnostics_IE_List_ExtIEs_Extension_1*)pvalue_);
   stat = asn1PE_TypeOfError (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List_element_iE_Extensions_ele  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (ASN1CTXT* pctxt, CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List_element_iE_Extensions_ele  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (ASN1CTXT* pctxt,
   CriticalityDiagnostics_IE_List_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CriticalityDiagnostics_IE_List_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CriticalityDiagnostics_IE_List_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CriticalityDiagnostics_IE_List_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = CriticalityDiagnostics_IE_List_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List_element_iE_Extensions      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CriticalityDiagnostics_IE_List_element_iE_Extensions (ASN1CTXT* pctxt, CriticalityDiagnostics_IE_List_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (pctxt, ((CriticalityDiagnostics_IE_List_element_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List_element                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CriticalityDiagnostics_IE_List_element (ASN1CTXT* pctxt, CriticalityDiagnostics_IE_List_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.repetitionNumberPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iECriticality */

   stat = asn1PE_Criticality (pctxt, pvalue->iECriticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_ID */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->iE_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode repetitionNumber */

   if (pvalue->m.repetitionNumberPresent) {
      stat = asn1PE_RepetitionNumber0 (pctxt, pvalue->repetitionNumber);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_CriticalityDiagnostics_IE_List_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_IE_List                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CriticalityDiagnostics_IE_List (ASN1CTXT* pctxt, CriticalityDiagnostics_IE_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_CriticalityDiagnostics_IE_List_element (pctxt, ((CriticalityDiagnostics_IE_List_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CriticalityDiagnostics_iE_Extensions_element (ASN1CTXT* pctxt, CriticalityDiagnostics_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_CriticalityDiagnostics_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_CriticalityDiagnostics_iE_Extensions_element (ASN1CTXT* pctxt,
   CriticalityDiagnostics_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CriticalityDiagnostics_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CriticalityDiagnostics_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CriticalityDiagnostics_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = CriticalityDiagnostics_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics_iE_Extensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CriticalityDiagnostics_iE_Extensions (ASN1CTXT* pctxt, CriticalityDiagnostics_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_CriticalityDiagnostics_iE_Extensions_element (pctxt, ((CriticalityDiagnostics_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CriticalityDiagnostics                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CriticalityDiagnostics (ASN1CTXT* pctxt, CriticalityDiagnostics* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.procedureCodePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.triggeringMessagePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.procedureCriticalityPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iEsCriticalityDiagnosticsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode procedureCode */

   if (pvalue->m.procedureCodePresent) {
      stat = asn1PE_ProcedureCode (pctxt, pvalue->procedureCode);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode triggeringMessage */

   if (pvalue->m.triggeringMessagePresent) {
      stat = asn1PE_TriggeringMessage (pctxt, pvalue->triggeringMessage);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode procedureCriticality */

   if (pvalue->m.procedureCriticalityPresent) {
      stat = asn1PE_Criticality (pctxt, pvalue->procedureCriticality);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iEsCriticalityDiagnostics */

   if (pvalue->m.iEsCriticalityDiagnosticsPresent) {
      stat = asn1PE_CriticalityDiagnostics_IE_List (pctxt, &pvalue->iEsCriticalityDiagnostics);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_CriticalityDiagnostics_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationType                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationType (ASN1CTXT* pctxt, RelocationType value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case ue_not_involved: ui = 0; break;
      case ue_involved: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TBCD_STRING                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TBCD_STRING (ASN1CTXT* pctxt, TBCD_STRING value)
{
   int stat = 0;

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PLMNidentity                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PLMNidentity (ASN1CTXT* pctxt, PLMNidentity value)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(3), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RNC_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RNC_ID (ASN1CTXT* pctxt, RNC_ID value)
{
   int stat = 0;

   if ( (value <= 4095) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(4095));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ID_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SourceRNC_ID_iE_Extensions_element (ASN1CTXT* pctxt, SourceRNC_ID_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SourceRNC_ID_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ID_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SourceRNC_ID_iE_Extensions_element (ASN1CTXT* pctxt,
   SourceRNC_ID_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SourceRNC_ID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SourceRNC_ID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SourceRNC_ID_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SourceRNC_ID_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ID_iE_Extensions                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SourceRNC_ID_iE_Extensions (ASN1CTXT* pctxt, SourceRNC_ID_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SourceRNC_ID_iE_Extensions_element (pctxt, ((SourceRNC_ID_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ID                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SourceRNC_ID (ASN1CTXT* pctxt, SourceRNC_ID* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode pLMNidentity */

   stat = asn1PE_PLMNidentity (pctxt, pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rNC_ID */

   stat = asn1PE_RNC_ID (pctxt, pvalue->rNC_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_SourceRNC_ID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LAC                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LAC (ASN1CTXT* pctxt, LAC* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAC                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAC (ASN1CTXT* pctxt, SAC* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAI_iE_Extensions_element (ASN1CTXT* pctxt, SAI_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SAI_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SAI_iE_Extensions_element (ASN1CTXT* pctxt,
   SAI_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SAI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SAI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SAI_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SAI_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SAI_iE_Extensions                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAI_iE_Extensions (ASN1CTXT* pctxt, SAI_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SAI_iE_Extensions_element (pctxt, ((SAI_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAI                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAI (ASN1CTXT* pctxt, SAI* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode pLMNidentity */

   stat = asn1PE_PLMNidentity (pctxt, pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode lAC */

   stat = asn1PE_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode sAC */

   stat = asn1PE_SAC (pctxt, &pvalue->sAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_SAI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceID                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SourceID (ASN1CTXT* pctxt, SourceID* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* sourceRNC_ID */
         case 1:
            stat = asn1PE_SourceRNC_ID (pctxt, pvalue->u.sourceRNC_ID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* sAI */
         case 2:
            stat = asn1PE_SAI (pctxt, pvalue->u.sAI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LAI_iE_Extensions_element (ASN1CTXT* pctxt, LAI_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_LAI_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_LAI_iE_Extensions_element (ASN1CTXT* pctxt,
   LAI_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LAI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LAI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LAI_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = LAI_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LAI_iE_Extensions                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LAI_iE_Extensions (ASN1CTXT* pctxt, LAI_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_LAI_iE_Extensions_element (pctxt, ((LAI_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LAI                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LAI (ASN1CTXT* pctxt, LAI* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode pLMNidentity */

   stat = asn1PE_PLMNidentity (pctxt, pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode lAC */

   stat = asn1PE_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_LAI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAC                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAC (ASN1CTXT* pctxt, RAC* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ID_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TargetRNC_ID_iE_Extensions_element (ASN1CTXT* pctxt, TargetRNC_ID_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_TargetRNC_ID_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ID_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_TargetRNC_ID_iE_Extensions_element (ASN1CTXT* pctxt,
   TargetRNC_ID_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TargetRNC_ID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TargetRNC_ID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TargetRNC_ID_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = TargetRNC_ID_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ID_iE_Extensions                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TargetRNC_ID_iE_Extensions (ASN1CTXT* pctxt, TargetRNC_ID_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_TargetRNC_ID_iE_Extensions_element (pctxt, ((TargetRNC_ID_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ID                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TargetRNC_ID (ASN1CTXT* pctxt, TargetRNC_ID* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.rACPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode lAI */

   stat = asn1PE_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAC */

   if (pvalue->m.rACPresent) {
      stat = asn1PE_RAC (pctxt, &pvalue->rAC);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode rNC_ID */

   stat = asn1PE_RNC_ID (pctxt, pvalue->rNC_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_TargetRNC_ID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CI                                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CI (ASN1CTXT* pctxt, CI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _CGI_ExtIEs_Extension                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__CGI_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _CGI_ExtIEs_Extension *pvalue = (_CGI_ExtIEs_Extension*) pvalue_;
   stat = asn1PE_RAC (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CGI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CGI_iE_Extensions_element (ASN1CTXT* pctxt, CGI_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_CGI_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CGI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_CGI_iE_Extensions_element (ASN1CTXT* pctxt,
   CGI_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CGI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CGI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CGI_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = CGI_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CGI_iE_Extensions                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CGI_iE_Extensions (ASN1CTXT* pctxt, CGI_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_CGI_iE_Extensions_element (pctxt, ((CGI_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CGI                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CGI (ASN1CTXT* pctxt, CGI* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode pLMNidentity */

   stat = asn1PE_PLMNidentity (pctxt, pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode lAC */

   stat = asn1PE_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode cI */

   stat = asn1PE_CI (pctxt, &pvalue->cI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_CGI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetID                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TargetID (ASN1CTXT* pctxt, TargetID* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* targetRNC_ID */
         case 1:
            stat = asn1PE_TargetRNC_ID (pctxt, pvalue->u.targetRNC_ID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* cGI */
         case 2:
            stat = asn1PE_CGI (pctxt, pvalue->u.cGI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ClassmarkInformation2                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ClassmarkInformation2 (ASN1CTXT* pctxt, ClassmarkInformation2 value)
{
   int stat = 0;

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ClassmarkInformation3                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ClassmarkInformation3 (ASN1CTXT* pctxt, ClassmarkInformation3 value)
{
   int stat = 0;

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RRC_Container                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RRC_Container (ASN1CTXT* pctxt, RRC_Container value)
{
   int stat = 0;

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NumberOfIuInstances                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NumberOfIuInstances (ASN1CTXT* pctxt, NumberOfIuInstances value)
{
   int stat = 0;

   if ( (value >= 1 && value <= 2) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionAlgorithm                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IntegrityProtectionAlgorithm (ASN1CTXT* pctxt, IntegrityProtectionAlgorithm value)
{
   int stat = 0;

   if ( (value <= 15) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ChosenIntegrityProtectionAlgorithm                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ChosenIntegrityProtectionAlgorithm (ASN1CTXT* pctxt, ChosenIntegrityProtectionAlgorithm value)
{
   int stat = 0;

   stat = asn1PE_IntegrityProtectionAlgorithm (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionKey                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IntegrityProtectionKey (ASN1CTXT* pctxt, IntegrityProtectionKey* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(128), OSUINTCONST(128), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionAlgorithm                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_EncryptionAlgorithm (ASN1CTXT* pctxt, EncryptionAlgorithm value)
{
   int stat = 0;

   if ( (value <= 15) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ChosenEncryptionAlgorithm                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ChosenEncryptionAlgorithm (ASN1CTXT* pctxt, ChosenEncryptionAlgorithm value)
{
   int stat = 0;

   stat = asn1PE_EncryptionAlgorithm (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionKey                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_EncryptionKey (ASN1CTXT* pctxt, EncryptionKey* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(128), OSUINTCONST(128), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  D_RNTI                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_D_RNTI (ASN1CTXT* pctxt, D_RNTI value)
{
   int stat = 0;

   if ( (value <= 1048575) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(1048575));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetCellId                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TargetCellId (ASN1CTXT* pctxt, TargetCellId value)
{
   int stat = 0;

   if ( (value <= 268435455) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(268435455));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DCH_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DCH_ID (ASN1CTXT* pctxt, DCH_ID value)
{
   int stat = 0;

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSCH_ID                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DSCH_ID (ASN1CTXT* pctxt, DSCH_ID value)
{
   int stat = 0;

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  USCH_ID                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_USCH_ID (ASN1CTXT* pctxt, USCH_ID value)
{
   int stat = 0;

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HS_DSCH_MAC_d_Flow_ID                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_HS_DSCH_MAC_d_Flow_ID (ASN1CTXT* pctxt, HS_DSCH_MAC_d_Flow_ID value)
{
   int stat = 0;

   if ( (value <= 7) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _TrCH_ID_ExtIEs_Extension                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__TrCH_ID_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _TrCH_ID_ExtIEs_Extension value = *((_TrCH_ID_ExtIEs_Extension*)pvalue_);
   stat = asn1PE_HS_DSCH_MAC_d_Flow_ID (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  E_DCH_MAC_d_Flow_ID                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_E_DCH_MAC_d_Flow_ID (ASN1CTXT* pctxt, E_DCH_MAC_d_Flow_ID value)
{
   int stat = 0;

   if ( (value <= 7) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _TrCH_ID_ExtIEs_Extension_1                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__TrCH_ID_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _TrCH_ID_ExtIEs_Extension_1 value = *((_TrCH_ID_ExtIEs_Extension_1*)pvalue_);
   stat = asn1PE_E_DCH_MAC_d_Flow_ID (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrCH_ID_iE_Extensions_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TrCH_ID_iE_Extensions_element (ASN1CTXT* pctxt, TrCH_ID_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_TrCH_ID_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrCH_ID_iE_Extensions_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_TrCH_ID_iE_Extensions_element (ASN1CTXT* pctxt,
   TrCH_ID_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TrCH_ID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TrCH_ID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TrCH_ID_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = TrCH_ID_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TrCH_ID_iE_Extensions                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TrCH_ID_iE_Extensions (ASN1CTXT* pctxt, TrCH_ID_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_TrCH_ID_iE_Extensions_element (pctxt, ((TrCH_ID_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrCH_ID                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TrCH_ID (ASN1CTXT* pctxt, TrCH_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dCH_IDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.dSCH_IDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.uSCH_IDPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode dCH_ID */

   if (pvalue->m.dCH_IDPresent) {
      stat = asn1PE_DCH_ID (pctxt, pvalue->dCH_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode dSCH_ID */

   if (pvalue->m.dSCH_IDPresent) {
      stat = asn1PE_DSCH_ID (pctxt, pvalue->dSCH_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode uSCH_ID */

   if (pvalue->m.uSCH_IDPresent) {
      stat = asn1PE_USCH_ID (pctxt, pvalue->uSCH_ID);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_TrCH_ID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrCH_ID_List                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TrCH_ID_List (ASN1CTXT* pctxt, TrCH_ID_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(7), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_TrCH_ID (pctxt, ((TrCH_ID*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_DomainIndicator                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CN_DomainIndicator (ASN1CTXT* pctxt, CN_DomainIndicator value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case cs_domain: ui = 0; break;
      case ps_domain: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_TrCH_MappingItem_ExtIEs_Extension                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_TrCH_MappingItem_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_TrCH_MappingItem_ExtIEs_Extension value = *((_RAB_TrCH_MappingItem_ExtIEs_Extension*)pvalue_);
   stat = asn1PE_CN_DomainIndicator (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_MappingItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_TrCH_MappingItem_iE_Extensions_element (ASN1CTXT* pctxt, RAB_TrCH_MappingItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_TrCH_MappingItem_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_MappingItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_TrCH_MappingItem_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_TrCH_MappingItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_TrCH_MappingItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_TrCH_MappingItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_TrCH_MappingItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_TrCH_MappingItem_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_MappingItem_iE_Extensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_TrCH_MappingItem_iE_Extensions (ASN1CTXT* pctxt, RAB_TrCH_MappingItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_TrCH_MappingItem_iE_Extensions_element (pctxt, ((RAB_TrCH_MappingItem_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_MappingItem                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_TrCH_MappingItem (ASN1CTXT* pctxt, RAB_TrCH_MappingItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_ID */

   stat = asn1PE_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode trCH_ID_List */

   stat = asn1PE_TrCH_ID_List (pctxt, &pvalue->trCH_ID_List);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_TrCH_MappingItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_TrCH_Mapping                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_TrCH_Mapping (ASN1CTXT* pctxt, RAB_TrCH_Mapping* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_TrCH_MappingItem (pctxt, ((RAB_TrCH_MappingItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRB_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRB_ID (ASN1CTXT* pctxt, SRB_ID value)
{
   int stat = 0;

   if ( (value >= 1 && value <= 32) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(32));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_MappingItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRB_TrCH_MappingItem_iE_Extensions_element (ASN1CTXT* pctxt, SRB_TrCH_MappingItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SRB_TrCH_MappingItem_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_MappingItem_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SRB_TrCH_MappingItem_iE_Extensions_element (ASN1CTXT* pctxt,
   SRB_TrCH_MappingItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SRB_TrCH_MappingItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SRB_TrCH_MappingItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SRB_TrCH_MappingItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SRB_TrCH_MappingItem_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_MappingItem_iE_Extensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRB_TrCH_MappingItem_iE_Extensions (ASN1CTXT* pctxt, SRB_TrCH_MappingItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SRB_TrCH_MappingItem_iE_Extensions_element (pctxt, ((SRB_TrCH_MappingItem_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_MappingItem                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRB_TrCH_MappingItem (ASN1CTXT* pctxt, SRB_TrCH_MappingItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode sRB_ID */

   stat = asn1PE_SRB_ID (pctxt, pvalue->sRB_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode trCH_ID */

   stat = asn1PE_TrCH_ID (pctxt, &pvalue->trCH_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_SRB_TrCH_MappingItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SRB_TrCH_Mapping                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SRB_TrCH_Mapping (ASN1CTXT* pctxt, SRB_TrCH_Mapping* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(8), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SRB_TrCH_MappingItem (pctxt, ((SRB_TrCH_MappingItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Exten  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension *pvalue = (_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension*) pvalue_;
   stat = asn1PE_SRB_TrCH_Mapping (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceUTRANCellID_iE_Extensions_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SourceUTRANCellID_iE_Extensions_element (ASN1CTXT* pctxt, SourceUTRANCellID_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SourceUTRANCellID_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceUTRANCellID_iE_Extensions_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SourceUTRANCellID_iE_Extensions_element (ASN1CTXT* pctxt,
   SourceUTRANCellID_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SourceUTRANCellID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SourceUTRANCellID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SourceUTRANCellID_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SourceUTRANCellID_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SourceUTRANCellID_iE_Extensions                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SourceUTRANCellID_iE_Extensions (ASN1CTXT* pctxt, SourceUTRANCellID_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SourceUTRANCellID_iE_Extensions_element (pctxt, ((SourceUTRANCellID_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceUTRANCellID                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SourceUTRANCellID (ASN1CTXT* pctxt, SourceUTRANCellID* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode pLMNidentity */

   stat = asn1PE_PLMNidentity (pctxt, pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode uTRANcellID */

   stat = asn1PE_TargetCellId (pctxt, pvalue->uTRANcellID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_SourceUTRANCellID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceCellID                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SourceCellID (ASN1CTXT* pctxt, SourceCellID* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* sourceUTRANCellID */
         case 1:
            stat = asn1PE_SourceUTRANCellID (pctxt, pvalue->u.sourceUTRANCellID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* sourceGERANCellID */
         case 2:
            stat = asn1PE_CGI (pctxt, pvalue->u.sourceGERANCellID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_Capacity_Class_Value                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Cell_Capacity_Class_Value (ASN1CTXT* pctxt, Cell_Capacity_Class_Value value)
{
   int stat = 0;
   OSBOOL extbit;

   if ( (value >= 1 && value <= 100) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(1), OSINTCONST(100));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LoadValue                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LoadValue (ASN1CTXT* pctxt, LoadValue value)
{
   int stat = 0;

   if ( (value <= 100) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(100));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RTLoadValue                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RTLoadValue (ASN1CTXT* pctxt, RTLoadValue value)
{
   int stat = 0;

   if ( (value <= 100) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(100));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NRTLoadInformationValue                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NRTLoadInformationValue (ASN1CTXT* pctxt, NRTLoadInformationValue value)
{
   int stat = 0;

   if ( (value <= 3) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformation_iE_Extensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CellLoadInformation_iE_Extensions_element (ASN1CTXT* pctxt, CellLoadInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_CellLoadInformation_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformation_iE_Extensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_CellLoadInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   CellLoadInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CellLoadInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CellLoadInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CellLoadInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = CellLoadInformation_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformation_iE_Extensions                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CellLoadInformation_iE_Extensions (ASN1CTXT* pctxt, CellLoadInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_CellLoadInformation_iE_Extensions_element (pctxt, ((CellLoadInformation_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformation                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CellLoadInformation (ASN1CTXT* pctxt, CellLoadInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.rTLoadValuePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.nRTLoadInformationValuePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode cell_Capacity_Class_Value */

   stat = asn1PE_Cell_Capacity_Class_Value (pctxt, pvalue->cell_Capacity_Class_Value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode loadValue */

   stat = asn1PE_LoadValue (pctxt, pvalue->loadValue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rTLoadValue */

   if (pvalue->m.rTLoadValuePresent) {
      stat = asn1PE_RTLoadValue (pctxt, pvalue->rTLoadValue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode nRTLoadInformationValue */

   if (pvalue->m.nRTLoadInformationValuePresent) {
      stat = asn1PE_NRTLoadInformationValue (pctxt, pvalue->nRTLoadInformationValue);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_CellLoadInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformationGroup_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CellLoadInformationGroup_iE_Extensions_element (ASN1CTXT* pctxt, CellLoadInformationGroup_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_CellLoadInformationGroup_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformationGroup_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_CellLoadInformationGroup_iE_Extensions_element (ASN1CTXT* pctxt,
   CellLoadInformationGroup_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < CellLoadInformationGroup_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &CellLoadInformationGroup_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == CellLoadInformationGroup_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = CellLoadInformationGroup_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformationGroup_iE_Extensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CellLoadInformationGroup_iE_Extensions (ASN1CTXT* pctxt, CellLoadInformationGroup_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_CellLoadInformationGroup_iE_Extensions_element (pctxt, ((CellLoadInformationGroup_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CellLoadInformationGroup                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CellLoadInformationGroup (ASN1CTXT* pctxt, CellLoadInformationGroup* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.uplinkCellLoadInformationPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.downlinkCellLoadInformationPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode sourceCellID */

   stat = asn1PE_SourceCellID (pctxt, &pvalue->sourceCellID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode uplinkCellLoadInformation */

   if (pvalue->m.uplinkCellLoadInformationPresent) {
      stat = asn1PE_CellLoadInformation (pctxt, &pvalue->uplinkCellLoadInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode downlinkCellLoadInformation */

   if (pvalue->m.downlinkCellLoadInformationPresent) {
      stat = asn1PE_CellLoadInformation (pctxt, &pvalue->downlinkCellLoadInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_CellLoadInformationGroup_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Exten  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_1 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_1 *pvalue = (_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_1*) pvalue_;
   stat = asn1PE_CellLoadInformationGroup (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceReference                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TraceReference (ASN1CTXT* pctxt, TraceReference* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(3), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionReference                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TraceRecordingSessionReference (ASN1CTXT* pctxt, TraceRecordingSessionReference value)
{
   int stat = 0;

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionInformation_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TraceRecordingSessionInformation_iE_Extensions_element (ASN1CTXT* pctxt, TraceRecordingSessionInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_TraceRecordingSessionInformation_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionInformation_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_TraceRecordingSessionInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   TraceRecordingSessionInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TraceRecordingSessionInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TraceRecordingSessionInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TraceRecordingSessionInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = TraceRecordingSessionInformation_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionInformation_iE_Extensions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TraceRecordingSessionInformation_iE_Extensions (ASN1CTXT* pctxt, TraceRecordingSessionInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_TraceRecordingSessionInformation_iE_Extensions_element (pctxt, ((TraceRecordingSessionInformation_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceRecordingSessionInformation                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TraceRecordingSessionInformation (ASN1CTXT* pctxt, TraceRecordingSessionInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode traceReference */

   stat = asn1PE_TraceReference (pctxt, &pvalue->traceReference);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode traceRecordingSessionReference */

   stat = asn1PE_TraceRecordingSessionReference (pctxt, pvalue->traceRecordingSessionReference);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_TraceRecordingSessionInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Exten  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_2 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_2 *pvalue = (_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_2*) pvalue_;
   stat = asn1PE_TraceRecordingSessionInformation (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSLinkingInformation                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSLinkingInformation (ASN1CTXT* pctxt, MBMSLinkingInformation value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case uE_has_joined_multicast_services: ui = 0; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Exten  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_3 (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_3 value = *((_SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Extension_3*)pvalue_);
   stat = asn1PE_MBMSLinkingInformation (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element (ASN1CTXT* pctxt, SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element (ASN1CTXT* pctxt,
   SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SourceRNC_ToTargetRNC_TransparentContainer_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions (ASN1CTXT* pctxt, SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element (pctxt, ((SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceRNC_ToTargetRNC_TransparentContainer                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SourceRNC_ToTargetRNC_TransparentContainer (ASN1CTXT* pctxt, SourceRNC_ToTargetRNC_TransparentContainer* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.chosenIntegrityProtectionAlgorithmPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.integrityProtectionKeyPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.chosenEncryptionAlgorithForSignallingPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.cipheringKeyPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.chosenEncryptionAlgorithForCSPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.chosenEncryptionAlgorithForPSPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.d_RNTIPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.targetCellIdPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.rAB_TrCH_MappingPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rRC_Container */

   stat = asn1PE_RRC_Container (pctxt, pvalue->rRC_Container);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode numberOfIuInstances */

   stat = asn1PE_NumberOfIuInstances (pctxt, pvalue->numberOfIuInstances);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode relocationType */

   stat = asn1PE_RelocationType (pctxt, pvalue->relocationType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode chosenIntegrityProtectionAlgorithm */

   if (pvalue->m.chosenIntegrityProtectionAlgorithmPresent) {
      stat = asn1PE_ChosenIntegrityProtectionAlgorithm (pctxt, pvalue->chosenIntegrityProtectionAlgorithm);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode integrityProtectionKey */

   if (pvalue->m.integrityProtectionKeyPresent) {
      stat = asn1PE_IntegrityProtectionKey (pctxt, &pvalue->integrityProtectionKey);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode chosenEncryptionAlgorithForSignalling */

   if (pvalue->m.chosenEncryptionAlgorithForSignallingPresent) {
      stat = asn1PE_ChosenEncryptionAlgorithm (pctxt, pvalue->chosenEncryptionAlgorithForSignalling);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode cipheringKey */

   if (pvalue->m.cipheringKeyPresent) {
      stat = asn1PE_EncryptionKey (pctxt, &pvalue->cipheringKey);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode chosenEncryptionAlgorithForCS */

   if (pvalue->m.chosenEncryptionAlgorithForCSPresent) {
      stat = asn1PE_ChosenEncryptionAlgorithm (pctxt, pvalue->chosenEncryptionAlgorithForCS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode chosenEncryptionAlgorithForPS */

   if (pvalue->m.chosenEncryptionAlgorithForPSPresent) {
      stat = asn1PE_ChosenEncryptionAlgorithm (pctxt, pvalue->chosenEncryptionAlgorithForPS);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode d_RNTI */

   if (pvalue->m.d_RNTIPresent) {
      stat = asn1PE_D_RNTI (pctxt, pvalue->d_RNTI);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode targetCellId */

   if (pvalue->m.targetCellIdPresent) {
      stat = asn1PE_TargetCellId (pctxt, pvalue->targetCellId);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode rAB_TrCH_Mapping */

   if (pvalue->m.rAB_TrCH_MappingPresent) {
      stat = asn1PE_RAB_TrCH_Mapping (pctxt, &pvalue->rAB_TrCH_Mapping);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_SourceRNC_ToTargetRNC_TransparentContainer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OldBSS_ToNewBSS_Information                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_OldBSS_ToNewBSS_Information (ASN1CTXT* pctxt, OldBSS_ToNewBSS_Information value)
{
   int stat = 0;

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Classmark                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GERAN_Classmark (ASN1CTXT* pctxt, GERAN_Classmark value)
{
   int stat = 0;

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceBSS_ToTargetBSS_TransparentContainer                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SourceBSS_ToTargetBSS_TransparentContainer (ASN1CTXT* pctxt, SourceBSS_ToTargetBSS_TransparentContainer value)
{
   int stat = 0;

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element (ASN1CTXT* pctxt, TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element (ASN1CTXT* pctxt,
   TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = TargetRNC_ToSourceRNC_TransparentContainer_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions (ASN1CTXT* pctxt, TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element (pctxt, ((TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetRNC_ToSourceRNC_TransparentContainer                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TargetRNC_ToSourceRNC_TransparentContainer (ASN1CTXT* pctxt, TargetRNC_ToSourceRNC_TransparentContainer* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.d_RNTIPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rRC_Container */

   stat = asn1PE_RRC_Container (pctxt, pvalue->rRC_Container);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode d_RNTI */

   if (pvalue->m.d_RNTIPresent) {
      stat = asn1PE_D_RNTI (pctxt, pvalue->d_RNTI);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_TargetRNC_ToSourceRNC_TransparentContainer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  L3_Information                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_L3_Information (ASN1CTXT* pctxt, L3_Information value)
{
   int stat = 0;

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportLayerAddress                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransportLayerAddress (ASN1CTXT* pctxt, TransportLayerAddress value)
{
   static Asn1SizeCnst lsize2 = { 1, OSUINTCONST(0), OSUINT32_MAX, 0 };
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(160), 0 };
   int stat = 0;

   lsize1.next = &lsize2;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, value.numbits, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GTP_TEI                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GTP_TEI (ASN1CTXT* pctxt, GTP_TEI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BindingID                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_BindingID (ASN1CTXT* pctxt, BindingID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IuTransportAssociation                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IuTransportAssociation (ASN1CTXT* pctxt, IuTransportAssociation* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* gTP_TEI */
         case 1:
            stat = asn1PE_GTP_TEI (pctxt, pvalue->u.gTP_TEI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* bindingID */
         case 2:
            stat = asn1PE_BindingID (pctxt, pvalue->u.bindingID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterSystemInformation_TransparentContainer_iE_Extension  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InterSystemInformation_TransparentContainer_iE_Extensions_element (ASN1CTXT* pctxt, InterSystemInformation_TransparentContainer_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_InterSystemInformation_TransparentContainer_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterSystemInformation_TransparentContainer_iE_Extension  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_InterSystemInformation_TransparentContainer_iE_Extensions_element (ASN1CTXT* pctxt,
   InterSystemInformation_TransparentContainer_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InterSystemInformation_TransparentContainer_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InterSystemInformation_TransparentContainer_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InterSystemInformation_TransparentContainer_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = InterSystemInformation_TransparentContainer_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InterSystemInformation_TransparentContainer_iE_Extension  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InterSystemInformation_TransparentContainer_iE_Extensions (ASN1CTXT* pctxt, InterSystemInformation_TransparentContainer_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_InterSystemInformation_TransparentContainer_iE_Extensions_element (pctxt, ((InterSystemInformation_TransparentContainer_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterSystemInformation_TransparentContainer               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InterSystemInformation_TransparentContainer (ASN1CTXT* pctxt, InterSystemInformation_TransparentContainer* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.downlinkCellLoadInformationPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.uplinkCellLoadInformationPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode downlinkCellLoadInformation */

   if (pvalue->m.downlinkCellLoadInformationPresent) {
      stat = asn1PE_CellLoadInformation (pctxt, &pvalue->downlinkCellLoadInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode uplinkCellLoadInformation */

   if (pvalue->m.uplinkCellLoadInformationPresent) {
      stat = asn1PE_CellLoadInformation (pctxt, &pvalue->uplinkCellLoadInformation);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_InterSystemInformation_TransparentContainer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetBSS_ToSourceBSS_TransparentContainer                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TargetBSS_ToSourceBSS_TransparentContainer (ASN1CTXT* pctxt, TargetBSS_ToSourceBSS_TransparentContainer value)
{
   int stat = 0;

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMSI                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IMSI (ASN1CTXT* pctxt, IMSI value)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(8), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PermanentNAS_UE_ID                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PermanentNAS_UE_ID (ASN1CTXT* pctxt, PermanentNAS_UE_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 1);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 0);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* iMSI */
         case 1:
            stat = asn1PE_IMSI (pctxt, *pvalue->u.iMSI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NAS_SynchronisationIndicator                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NAS_SynchronisationIndicator (ASN1CTXT* pctxt, NAS_SynchronisationIndicator* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrafficClass                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TrafficClass (ASN1CTXT* pctxt, TrafficClass value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case conversational: ui = 0; break;
      case streaming: ui = 1; break;
      case interactive: ui = 2; break;
      case background: ui = 3; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_AsymmetryIndicator                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_AsymmetryIndicator (ASN1CTXT* pctxt, RAB_AsymmetryIndicator value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case symmetric_bidirectional: ui = 0; break;
      case asymmetric_unidirectional_downlink: ui = 1; break;
      case asymmetric_unidirectional_uplink: ui = 2; break;
      case asymmetric_bidirectional: ui = 3; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaxBitrate                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MaxBitrate (ASN1CTXT* pctxt, MaxBitrate value)
{
   int stat = 0;

   if ( (value >= 1 && value <= 16000000) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(16000000));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameter_MaxBitrateList                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_Parameter_MaxBitrateList (ASN1CTXT* pctxt, RAB_Parameter_MaxBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_MaxBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GuaranteedBitrate                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GuaranteedBitrate (ASN1CTXT* pctxt, GuaranteedBitrate value)
{
   int stat = 0;

   if ( (value <= 16000000) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(16000000));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameter_GuaranteedBitrateList                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_Parameter_GuaranteedBitrateList (ASN1CTXT* pctxt, RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_GuaranteedBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeliveryOrder                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DeliveryOrder (ASN1CTXT* pctxt, DeliveryOrder value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case delivery_order_requested: ui = 0; break;
      case delivery_order_not_requested: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaxSDU_Size                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MaxSDU_Size (ASN1CTXT* pctxt, MaxSDU_Size value)
{
   int stat = 0;

   if ( (value <= 32768) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(32768));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_ErrorRatio_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SDU_ErrorRatio_iE_Extensions_element (ASN1CTXT* pctxt, SDU_ErrorRatio_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SDU_ErrorRatio_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_ErrorRatio_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SDU_ErrorRatio_iE_Extensions_element (ASN1CTXT* pctxt,
   SDU_ErrorRatio_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SDU_ErrorRatio_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SDU_ErrorRatio_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SDU_ErrorRatio_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SDU_ErrorRatio_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SDU_ErrorRatio_iE_Extensions                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SDU_ErrorRatio_iE_Extensions (ASN1CTXT* pctxt, SDU_ErrorRatio_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SDU_ErrorRatio_iE_Extensions_element (pctxt, ((SDU_ErrorRatio_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_ErrorRatio                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SDU_ErrorRatio (ASN1CTXT* pctxt, SDU_ErrorRatio* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode mantissa */

   if ( (pvalue->mantissa >= 1 && pvalue->mantissa <= 9) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->mantissa, OSUINTCONST(1), OSUINTCONST(9));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   /* encode exponent */

   if ( (pvalue->exponent >= 1 && pvalue->exponent <= 6) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->exponent, OSUINTCONST(1), OSUINTCONST(6));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_SDU_ErrorRatio_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResidualBitErrorRatio_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResidualBitErrorRatio_iE_Extensions_element (ASN1CTXT* pctxt, ResidualBitErrorRatio_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_ResidualBitErrorRatio_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResidualBitErrorRatio_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_ResidualBitErrorRatio_iE_Extensions_element (ASN1CTXT* pctxt,
   ResidualBitErrorRatio_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < ResidualBitErrorRatio_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &ResidualBitErrorRatio_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == ResidualBitErrorRatio_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = ResidualBitErrorRatio_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  ResidualBitErrorRatio_iE_Extensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResidualBitErrorRatio_iE_Extensions (ASN1CTXT* pctxt, ResidualBitErrorRatio_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_ResidualBitErrorRatio_iE_Extensions_element (pctxt, ((ResidualBitErrorRatio_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResidualBitErrorRatio                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResidualBitErrorRatio (ASN1CTXT* pctxt, ResidualBitErrorRatio* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode mantissa */

   if ( (pvalue->mantissa >= 1 && pvalue->mantissa <= 9) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->mantissa, OSUINTCONST(1), OSUINTCONST(9));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   /* encode exponent */

   if ( (pvalue->exponent >= 1 && pvalue->exponent <= 8) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->exponent, OSUINTCONST(1), OSUINTCONST(8));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_ResidualBitErrorRatio_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeliveryOfErroneousSDU                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DeliveryOfErroneousSDU (ASN1CTXT* pctxt, DeliveryOfErroneousSDU value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case yes: ui = 0; break;
      case no: ui = 1; break;
      case no_error_detection_consideration: ui = 2; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SubflowSDU_Size                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SubflowSDU_Size (ASN1CTXT* pctxt, SubflowSDU_Size value)
{
   int stat = 0;

   if ( (value <= 4095) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(4095));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_SubflowCombinationBitRate                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_SubflowCombinationBitRate (ASN1CTXT* pctxt, RAB_SubflowCombinationBitRate value)
{
   int stat = 0;

   if ( (value <= 16000000) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(16000000));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters_element_iE_Extensions_el  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SDU_FormatInformationParameters_element_iE_Extensions_element (ASN1CTXT* pctxt, SDU_FormatInformationParameters_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SDU_FormatInformationParameters_element_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters_element_iE_Extensions_el  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SDU_FormatInformationParameters_element_iE_Extensions_element (ASN1CTXT* pctxt,
   SDU_FormatInformationParameters_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SDU_FormatInformationParameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SDU_FormatInformationParameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SDU_FormatInformationParameters_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SDU_FormatInformationParameters_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters_element_iE_Extensions     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SDU_FormatInformationParameters_element_iE_Extensions (ASN1CTXT* pctxt, SDU_FormatInformationParameters_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SDU_FormatInformationParameters_element_iE_Extensions_element (pctxt, ((SDU_FormatInformationParameters_element_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SDU_FormatInformationParameters_element (ASN1CTXT* pctxt, SDU_FormatInformationParameters_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.subflowSDU_SizePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.rAB_SubflowCombinationBitRatePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode subflowSDU_Size */

   if (pvalue->m.subflowSDU_SizePresent) {
      stat = asn1PE_SubflowSDU_Size (pctxt, pvalue->subflowSDU_Size);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode rAB_SubflowCombinationBitRate */

   if (pvalue->m.rAB_SubflowCombinationBitRatePresent) {
      stat = asn1PE_RAB_SubflowCombinationBitRate (pctxt, pvalue->rAB_SubflowCombinationBitRate);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_SDU_FormatInformationParameters_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_FormatInformationParameters                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SDU_FormatInformationParameters (ASN1CTXT* pctxt, SDU_FormatInformationParameters* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SDU_FormatInformationParameters_element (pctxt, ((SDU_FormatInformationParameters_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters_element_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SDU_Parameters_element_iE_Extensions_element (ASN1CTXT* pctxt, SDU_Parameters_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SDU_Parameters_element_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters_element_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SDU_Parameters_element_iE_Extensions_element (ASN1CTXT* pctxt,
   SDU_Parameters_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SDU_Parameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SDU_Parameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SDU_Parameters_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SDU_Parameters_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters_element_iE_Extensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SDU_Parameters_element_iE_Extensions (ASN1CTXT* pctxt, SDU_Parameters_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SDU_Parameters_element_iE_Extensions_element (pctxt, ((SDU_Parameters_element_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters_element                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SDU_Parameters_element (ASN1CTXT* pctxt, SDU_Parameters_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.sDU_ErrorRatioPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.sDU_FormatInformationParametersPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode sDU_ErrorRatio */

   if (pvalue->m.sDU_ErrorRatioPresent) {
      stat = asn1PE_SDU_ErrorRatio (pctxt, &pvalue->sDU_ErrorRatio);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode residualBitErrorRatio */

   stat = asn1PE_ResidualBitErrorRatio (pctxt, &pvalue->residualBitErrorRatio);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode deliveryOfErroneousSDU */

   stat = asn1PE_DeliveryOfErroneousSDU (pctxt, pvalue->deliveryOfErroneousSDU);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode sDU_FormatInformationParameters */

   if (pvalue->m.sDU_FormatInformationParametersPresent) {
      stat = asn1PE_SDU_FormatInformationParameters (pctxt, &pvalue->sDU_FormatInformationParameters);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_SDU_Parameters_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDU_Parameters                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SDU_Parameters (ASN1CTXT* pctxt, SDU_Parameters* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(7), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SDU_Parameters_element (pctxt, ((SDU_Parameters_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransferDelay                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TransferDelay (ASN1CTXT* pctxt, TransferDelay value)
{
   int stat = 0;

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrafficHandlingPriority                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TrafficHandlingPriority (ASN1CTXT* pctxt, TrafficHandlingPriority value)
{
   int stat = 0;

   if ( (value <= 15) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityLevel                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PriorityLevel (ASN1CTXT* pctxt, PriorityLevel value)
{
   int stat = 0;

   if ( (value <= 15) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Pre_emptionCapability                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Pre_emptionCapability (ASN1CTXT* pctxt, Pre_emptionCapability value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case shall_not_trigger_pre_emption: ui = 0; break;
      case may_trigger_pre_emption: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Pre_emptionVulnerability                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Pre_emptionVulnerability (ASN1CTXT* pctxt, Pre_emptionVulnerability value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case not_pre_emptable: ui = 0; break;
      case pre_emptable: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QueuingAllowed                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_QueuingAllowed (ASN1CTXT* pctxt, QueuingAllowed value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case queueing_not_allowed: ui = 0; break;
      case queueing_allowed: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AllocationOrRetentionPriority_iE_Extensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AllocationOrRetentionPriority_iE_Extensions_element (ASN1CTXT* pctxt, AllocationOrRetentionPriority_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_AllocationOrRetentionPriority_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AllocationOrRetentionPriority_iE_Extensions_element       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_AllocationOrRetentionPriority_iE_Extensions_element (ASN1CTXT* pctxt,
   AllocationOrRetentionPriority_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < AllocationOrRetentionPriority_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &AllocationOrRetentionPriority_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == AllocationOrRetentionPriority_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = AllocationOrRetentionPriority_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  AllocationOrRetentionPriority_iE_Extensions               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AllocationOrRetentionPriority_iE_Extensions (ASN1CTXT* pctxt, AllocationOrRetentionPriority_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_AllocationOrRetentionPriority_iE_Extensions_element (pctxt, ((AllocationOrRetentionPriority_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AllocationOrRetentionPriority                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AllocationOrRetentionPriority (ASN1CTXT* pctxt, AllocationOrRetentionPriority* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode priorityLevel */

   stat = asn1PE_PriorityLevel (pctxt, pvalue->priorityLevel);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode pre_emptionCapability */

   stat = asn1PE_Pre_emptionCapability (pctxt, pvalue->pre_emptionCapability);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode pre_emptionVulnerability */

   stat = asn1PE_Pre_emptionVulnerability (pctxt, pvalue->pre_emptionVulnerability);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode queuingAllowed */

   stat = asn1PE_QueuingAllowed (pctxt, pvalue->queuingAllowed);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_AllocationOrRetentionPriority_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceStatisticsDescriptor                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SourceStatisticsDescriptor (ASN1CTXT* pctxt, SourceStatisticsDescriptor value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case speech: ui = 0; break;
      case unknown: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelocationRequirement                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RelocationRequirement (ASN1CTXT* pctxt, RelocationRequirement value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case lossless: ui = 0; break;
      case none: ui = 1; break;
      case realtime: ui = 0; extbit = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignallingIndication                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SignallingIndication (ASN1CTXT* pctxt, SignallingIndication value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case signalling: ui = 0; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _RAB_Parameters_ExtIEs_Extension                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__RAB_Parameters_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RAB_Parameters_ExtIEs_Extension value = *((_RAB_Parameters_ExtIEs_Extension*)pvalue_);
   stat = asn1PE_SignallingIndication (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameters_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_Parameters_iE_Extensions_element (ASN1CTXT* pctxt, RAB_Parameters_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAB_Parameters_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameters_iE_Extensions_element                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAB_Parameters_iE_Extensions_element (ASN1CTXT* pctxt,
   RAB_Parameters_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAB_Parameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAB_Parameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAB_Parameters_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAB_Parameters_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameters_iE_Extensions                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_Parameters_iE_Extensions (ASN1CTXT* pctxt, RAB_Parameters_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAB_Parameters_iE_Extensions_element (pctxt, ((RAB_Parameters_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAB_Parameters                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAB_Parameters (ASN1CTXT* pctxt, RAB_Parameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.guaranteedBitRatePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.transferDelayPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.trafficHandlingPriorityPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.allocationOrRetentionPriorityPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.sourceStatisticsDescriptorPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.relocationRequirementPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode trafficClass */

   stat = asn1PE_TrafficClass (pctxt, pvalue->trafficClass);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAB_AsymmetryIndicator */

   stat = asn1PE_RAB_AsymmetryIndicator (pctxt, pvalue->rAB_AsymmetryIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode maxBitrate */

   stat = asn1PE_RAB_Parameter_MaxBitrateList (pctxt, &pvalue->maxBitrate);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode guaranteedBitRate */

   if (pvalue->m.guaranteedBitRatePresent) {
      stat = asn1PE_RAB_Parameter_GuaranteedBitrateList (pctxt, &pvalue->guaranteedBitRate);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode deliveryOrder */

   stat = asn1PE_DeliveryOrder (pctxt, pvalue->deliveryOrder);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode maxSDU_Size */

   stat = asn1PE_MaxSDU_Size (pctxt, pvalue->maxSDU_Size);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode sDU_Parameters */

   stat = asn1PE_SDU_Parameters (pctxt, &pvalue->sDU_Parameters);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode transferDelay */

   if (pvalue->m.transferDelayPresent) {
      stat = asn1PE_TransferDelay (pctxt, pvalue->transferDelay);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode trafficHandlingPriority */

   if (pvalue->m.trafficHandlingPriorityPresent) {
      stat = asn1PE_TrafficHandlingPriority (pctxt, pvalue->trafficHandlingPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode allocationOrRetentionPriority */

   if (pvalue->m.allocationOrRetentionPriorityPresent) {
      stat = asn1PE_AllocationOrRetentionPriority (pctxt, &pvalue->allocationOrRetentionPriority);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode sourceStatisticsDescriptor */

   if (pvalue->m.sourceStatisticsDescriptorPresent) {
      stat = asn1PE_SourceStatisticsDescriptor (pctxt, pvalue->sourceStatisticsDescriptor);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode relocationRequirement */

   if (pvalue->m.relocationRequirementPresent) {
      stat = asn1PE_RelocationRequirement (pctxt, pvalue->relocationRequirement);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAB_Parameters_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataVolumeReportingIndication                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DataVolumeReportingIndication (ASN1CTXT* pctxt, DataVolumeReportingIndication value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case do_report: ui = 0; break;
      case do_not_report: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDP_Type                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PDP_Type (ASN1CTXT* pctxt, PDP_Type value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case empty: ui = 0; break;
      case ppp: ui = 1; break;
      case osp_ihoss: ui = 2; break;
      case ipv4: ui = 3; break;
      case ipv6: ui = 4; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PDP_TypeInformation                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PDP_TypeInformation (ASN1CTXT* pctxt, PDP_TypeInformation* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_PDP_Type (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserPlaneMode                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UserPlaneMode (ASN1CTXT* pctxt, UserPlaneMode value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case transparent_mode: ui = 0; break;
      case support_mode_for_predefined_SDU_sizes: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UP_ModeVersions                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UP_ModeVersions (ASN1CTXT* pctxt, UP_ModeVersions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Service_Handover                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Service_Handover (ASN1CTXT* pctxt, Service_Handover value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case handover_to_GSM_should_be_performed: ui = 0; break;
      case handover_to_GSM_should_not_be_performed: ui = 1; break;
      case handover_to_GSM_shall_not_be_performed: ui = 2; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_MaxBitrateType                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Alt_RAB_Parameter_MaxBitrateType (ASN1CTXT* pctxt, Alt_RAB_Parameter_MaxBitrateType value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case unspecified_1: ui = 0; break;
      case value_range_1: ui = 1; break;
      case discrete_values_1: ui = 2; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_MaxBitrateList                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Alt_RAB_Parameter_MaxBitrateList (ASN1CTXT* pctxt, Alt_RAB_Parameter_MaxBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_MaxBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_MaxBitrates                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Alt_RAB_Parameter_MaxBitrates (ASN1CTXT* pctxt, Alt_RAB_Parameter_MaxBitrates* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_Alt_RAB_Parameter_MaxBitrateList (pctxt, ((Alt_RAB_Parameter_MaxBitrateList*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_MaxBitrateInf                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Alt_RAB_Parameter_MaxBitrateInf (ASN1CTXT* pctxt, Alt_RAB_Parameter_MaxBitrateInf* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.altMaxBitratesPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode altMaxBitrateType */

   stat = asn1PE_Alt_RAB_Parameter_MaxBitrateType (pctxt, pvalue->altMaxBitrateType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode altMaxBitrates */

   if (pvalue->m.altMaxBitratesPresent) {
      stat = asn1PE_Alt_RAB_Parameter_MaxBitrates (pctxt, &pvalue->altMaxBitrates);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_GuaranteedBitrateType                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Alt_RAB_Parameter_GuaranteedBitrateType (ASN1CTXT* pctxt, Alt_RAB_Parameter_GuaranteedBitrateType value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case unspecified: ui = 0; break;
      case value_range: ui = 1; break;
      case discrete_values: ui = 2; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_GuaranteedBitrateList                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Alt_RAB_Parameter_GuaranteedBitrateList (ASN1CTXT* pctxt, Alt_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_GuaranteedBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_GuaranteedBitrates                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Alt_RAB_Parameter_GuaranteedBitrates (ASN1CTXT* pctxt, Alt_RAB_Parameter_GuaranteedBitrates* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_Alt_RAB_Parameter_GuaranteedBitrateList (pctxt, ((Alt_RAB_Parameter_GuaranteedBitrateList*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameter_GuaranteedBitrateInf                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Alt_RAB_Parameter_GuaranteedBitrateInf (ASN1CTXT* pctxt, Alt_RAB_Parameter_GuaranteedBitrateInf* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.altGuaranteedBitratesPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode altGuaranteedBitrateType */

   stat = asn1PE_Alt_RAB_Parameter_GuaranteedBitrateType (pctxt, pvalue->altGuaranteedBitrateType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode altGuaranteedBitrates */

   if (pvalue->m.altGuaranteedBitratesPresent) {
      stat = asn1PE_Alt_RAB_Parameter_GuaranteedBitrates (pctxt, &pvalue->altGuaranteedBitrates);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _Alt_RAB_Parameters_ExtIEs_Extension                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__Alt_RAB_Parameters_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Alt_RAB_Parameters_ExtIEs_Extension *pvalue = (_Alt_RAB_Parameters_ExtIEs_Extension*) pvalue_;
   stat = asn1PE_RAB_Parameters (pctxt, pvalue);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameters_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Alt_RAB_Parameters_iE_Extensions_element (ASN1CTXT* pctxt, Alt_RAB_Parameters_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_Alt_RAB_Parameters_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameters_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_Alt_RAB_Parameters_iE_Extensions_element (ASN1CTXT* pctxt,
   Alt_RAB_Parameters_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Alt_RAB_Parameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Alt_RAB_Parameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Alt_RAB_Parameters_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = Alt_RAB_Parameters_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameters_iE_Extensions                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Alt_RAB_Parameters_iE_Extensions (ASN1CTXT* pctxt, Alt_RAB_Parameters_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_Alt_RAB_Parameters_iE_Extensions_element (pctxt, ((Alt_RAB_Parameters_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alt_RAB_Parameters                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Alt_RAB_Parameters (ASN1CTXT* pctxt, Alt_RAB_Parameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.altMaxBitrateInfPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.altGuaranteedBitRateInfPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode altMaxBitrateInf */

   if (pvalue->m.altMaxBitrateInfPresent) {
      stat = asn1PE_Alt_RAB_Parameter_MaxBitrateInf (pctxt, &pvalue->altMaxBitrateInf);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode altGuaranteedBitRateInf */

   if (pvalue->m.altGuaranteedBitRateInfPresent) {
      stat = asn1PE_Alt_RAB_Parameter_GuaranteedBitrateInf (pctxt, &pvalue->altGuaranteedBitRateInf);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_Alt_RAB_Parameters_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_BSC_Container                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GERAN_BSC_Container (ASN1CTXT* pctxt, GERAN_BSC_Container value)
{
   int stat = 0;

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PermittedIntegrityProtectionAlgorithms                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PermittedIntegrityProtectionAlgorithms (ASN1CTXT* pctxt, PermittedIntegrityProtectionAlgorithms* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_IntegrityProtectionAlgorithm (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionInformation_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IntegrityProtectionInformation_iE_Extensions_element (ASN1CTXT* pctxt, IntegrityProtectionInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_IntegrityProtectionInformation_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionInformation_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_IntegrityProtectionInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   IntegrityProtectionInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < IntegrityProtectionInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &IntegrityProtectionInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == IntegrityProtectionInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = IntegrityProtectionInformation_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionInformation_iE_Extensions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IntegrityProtectionInformation_iE_Extensions (ASN1CTXT* pctxt, IntegrityProtectionInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_IntegrityProtectionInformation_iE_Extensions_element (pctxt, ((IntegrityProtectionInformation_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntegrityProtectionInformation                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IntegrityProtectionInformation (ASN1CTXT* pctxt, IntegrityProtectionInformation* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode permittedAlgorithms */

   stat = asn1PE_PermittedIntegrityProtectionAlgorithms (pctxt, &pvalue->permittedAlgorithms);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode key */

   stat = asn1PE_IntegrityProtectionKey (pctxt, &pvalue->key);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_IntegrityProtectionInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PermittedEncryptionAlgorithms                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PermittedEncryptionAlgorithms (ASN1CTXT* pctxt, PermittedEncryptionAlgorithms* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_EncryptionAlgorithm (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionInformation_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_EncryptionInformation_iE_Extensions_element (ASN1CTXT* pctxt, EncryptionInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_EncryptionInformation_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionInformation_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_EncryptionInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   EncryptionInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < EncryptionInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &EncryptionInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == EncryptionInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = EncryptionInformation_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  EncryptionInformation_iE_Extensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_EncryptionInformation_iE_Extensions (ASN1CTXT* pctxt, EncryptionInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_EncryptionInformation_iE_Extensions_element (pctxt, ((EncryptionInformation_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionInformation                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_EncryptionInformation (ASN1CTXT* pctxt, EncryptionInformation* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode permittedAlgorithms */

   stat = asn1PE_PermittedEncryptionAlgorithms (pctxt, &pvalue->permittedAlgorithms);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode key */

   stat = asn1PE_EncryptionKey (pctxt, &pvalue->key);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_EncryptionInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IuSignallingConnectionIdentifier                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IuSignallingConnectionIdentifier (ASN1CTXT* pctxt, IuSignallingConnectionIdentifier* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CN_ID                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_CN_ID (ASN1CTXT* pctxt, CN_ID value)
{
   int stat = 0;

   if ( (value <= 4095) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(4095));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GlobalCN_ID                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GlobalCN_ID (ASN1CTXT* pctxt, GlobalCN_ID* pvalue)
{
   int stat = 0;

   /* encode pLMNidentity */

   stat = asn1PE_PLMNidentity (pctxt, pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode cN_ID */

   stat = asn1PE_CN_ID (pctxt, pvalue->cN_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SNAC                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SNAC (ASN1CTXT* pctxt, SNAC value)
{
   int stat = 0;

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuthorisedSNAs                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AuthorisedSNAs (ASN1CTXT* pctxt, AuthorisedSNAs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65536), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_SNAC (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs_element_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AuthorisedPLMNs_element_iE_Extensions_element (ASN1CTXT* pctxt, AuthorisedPLMNs_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_AuthorisedPLMNs_element_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs_element_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_AuthorisedPLMNs_element_iE_Extensions_element (ASN1CTXT* pctxt,
   AuthorisedPLMNs_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < AuthorisedPLMNs_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &AuthorisedPLMNs_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == AuthorisedPLMNs_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = AuthorisedPLMNs_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs_element_iE_Extensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AuthorisedPLMNs_element_iE_Extensions (ASN1CTXT* pctxt, AuthorisedPLMNs_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_AuthorisedPLMNs_element_iE_Extensions_element (pctxt, ((AuthorisedPLMNs_element_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs_element                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AuthorisedPLMNs_element (ASN1CTXT* pctxt, AuthorisedPLMNs_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.authorisedSNAsListPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode pLMNidentity */

   stat = asn1PE_PLMNidentity (pctxt, pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode authorisedSNAsList */

   if (pvalue->m.authorisedSNAsListPresent) {
      stat = asn1PE_AuthorisedSNAs (pctxt, &pvalue->authorisedSNAsList);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_AuthorisedPLMNs_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuthorisedPLMNs                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AuthorisedPLMNs (ASN1CTXT* pctxt, AuthorisedPLMNs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_AuthorisedPLMNs_element (pctxt, ((AuthorisedPLMNs_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SNA_Access_Information_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SNA_Access_Information_iE_Extensions_element (ASN1CTXT* pctxt, SNA_Access_Information_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_SNA_Access_Information_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SNA_Access_Information_iE_Extensions_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_SNA_Access_Information_iE_Extensions_element (ASN1CTXT* pctxt,
   SNA_Access_Information_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < SNA_Access_Information_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &SNA_Access_Information_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == SNA_Access_Information_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = SNA_Access_Information_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  SNA_Access_Information_iE_Extensions                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SNA_Access_Information_iE_Extensions (ASN1CTXT* pctxt, SNA_Access_Information_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_SNA_Access_Information_iE_Extensions_element (pctxt, ((SNA_Access_Information_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SNA_Access_Information                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SNA_Access_Information (ASN1CTXT* pctxt, SNA_Access_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode authorisedPLMNs */

   stat = asn1PE_AuthorisedPLMNs (pctxt, &pvalue->authorisedPLMNs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_SNA_Access_Information_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESBI_IuA                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UESBI_IuA (ASN1CTXT* pctxt, UESBI_IuA* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESBI_IuB                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UESBI_IuB (ASN1CTXT* pctxt, UESBI_IuB* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESBI_Iu_iE_Extensions_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UESBI_Iu_iE_Extensions_element (ASN1CTXT* pctxt, UESBI_Iu_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_UESBI_Iu_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESBI_Iu_iE_Extensions_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_UESBI_Iu_iE_Extensions_element (ASN1CTXT* pctxt,
   UESBI_Iu_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < UESBI_Iu_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &UESBI_Iu_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == UESBI_Iu_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = UESBI_Iu_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  UESBI_Iu_iE_Extensions                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UESBI_Iu_iE_Extensions (ASN1CTXT* pctxt, UESBI_Iu_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_UESBI_Iu_iE_Extensions_element (pctxt, ((UESBI_Iu_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UESBI_Iu                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UESBI_Iu (ASN1CTXT* pctxt, UESBI_Iu* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.uESBI_IuAPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.uESBI_IuBPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode uESBI_IuA */

   if (pvalue->m.uESBI_IuAPresent) {
      stat = asn1PE_UESBI_IuA (pctxt, &pvalue->uESBI_IuA);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode uESBI_IuB */

   if (pvalue->m.uESBI_IuBPresent) {
      stat = asn1PE_UESBI_IuB (pctxt, &pvalue->uESBI_IuB);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_UESBI_Iu_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TMGI_serviceID                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TMGI_serviceID (ASN1CTXT* pctxt, TMGI_serviceID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(3), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TMGI_iE_Extensions_element                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TMGI_iE_Extensions_element (ASN1CTXT* pctxt, TMGI_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_TMGI_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TMGI_iE_Extensions_element                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_TMGI_iE_Extensions_element (ASN1CTXT* pctxt,
   TMGI_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TMGI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TMGI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TMGI_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = TMGI_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TMGI_iE_Extensions                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TMGI_iE_Extensions (ASN1CTXT* pctxt, TMGI_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_TMGI_iE_Extensions_element (pctxt, ((TMGI_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TMGI                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TMGI (ASN1CTXT* pctxt, TMGI* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode pLMNidentity */

   stat = asn1PE_PLMNidentity (pctxt, pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode serviceID */

   stat = asn1PE_TMGI_serviceID (pctxt, &pvalue->serviceID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_TMGI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMS_PTP_RAB_ID                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMS_PTP_RAB_ID (ASN1CTXT* pctxt, MBMS_PTP_RAB_ID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameter_MaxBitrateList                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Ass_RAB_Parameter_MaxBitrateList (ASN1CTXT* pctxt, Ass_RAB_Parameter_MaxBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_MaxBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameter_GuaranteedBitrateList                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Ass_RAB_Parameter_GuaranteedBitrateList (ASN1CTXT* pctxt, Ass_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_GuaranteedBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameters_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Ass_RAB_Parameters_iE_Extensions_element (ASN1CTXT* pctxt, Ass_RAB_Parameters_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_Ass_RAB_Parameters_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameters_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_Ass_RAB_Parameters_iE_Extensions_element (ASN1CTXT* pctxt,
   Ass_RAB_Parameters_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Ass_RAB_Parameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Ass_RAB_Parameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Ass_RAB_Parameters_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = Ass_RAB_Parameters_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameters_iE_Extensions                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Ass_RAB_Parameters_iE_Extensions (ASN1CTXT* pctxt, Ass_RAB_Parameters_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_Ass_RAB_Parameters_iE_Extensions_element (pctxt, ((Ass_RAB_Parameters_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ass_RAB_Parameters                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Ass_RAB_Parameters (ASN1CTXT* pctxt, Ass_RAB_Parameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.assMaxBitrateInfPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.assGuaranteedBitRateInfPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode assMaxBitrateInf */

   if (pvalue->m.assMaxBitrateInfPresent) {
      stat = asn1PE_Ass_RAB_Parameter_MaxBitrateList (pctxt, &pvalue->assMaxBitrateInf);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode assGuaranteedBitRateInf */

   if (pvalue->m.assGuaranteedBitRateInfPresent) {
      stat = asn1PE_Ass_RAB_Parameter_GuaranteedBitrateList (pctxt, &pvalue->assGuaranteedBitRateInf);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_Ass_RAB_Parameters_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewBSS_To_OldBSS_Information                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NewBSS_To_OldBSS_Information (ASN1CTXT* pctxt, NewBSS_To_OldBSS_Information value)
{
   int stat = 0;

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DL_N_PDU_SequenceNumber                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DL_N_PDU_SequenceNumber (ASN1CTXT* pctxt, DL_N_PDU_SequenceNumber value)
{
   int stat = 0;

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UL_N_PDU_SequenceNumber                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UL_N_PDU_SequenceNumber (ASN1CTXT* pctxt, UL_N_PDU_SequenceNumber value)
{
   int stat = 0;

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KeyStatus                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_KeyStatus (ASN1CTXT* pctxt, KeyStatus value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case old: ui = 0; break;
      case new_: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GlobalRNC_ID                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GlobalRNC_ID (ASN1CTXT* pctxt, GlobalRNC_ID* pvalue)
{
   int stat = 0;

   /* encode pLMNidentity */

   stat = asn1PE_PLMNidentity (pctxt, pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rNC_ID */

   stat = asn1PE_RNC_ID (pctxt, pvalue->rNC_ID);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TMSI                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TMSI (ASN1CTXT* pctxt, TMSI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  P_TMSI                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_P_TMSI (ASN1CTXT* pctxt, P_TMSI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TemporaryUE_ID                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TemporaryUE_ID (ASN1CTXT* pctxt, TemporaryUE_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* tMSI */
         case 1:
            stat = asn1PE_TMSI (pctxt, pvalue->u.tMSI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* p_TMSI */
         case 2:
            stat = asn1PE_P_TMSI (pctxt, pvalue->u.p_TMSI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAI_iE_Extensions_element (ASN1CTXT* pctxt, RAI_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RAI_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAI_iE_Extensions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RAI_iE_Extensions_element (ASN1CTXT* pctxt,
   RAI_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RAI_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RAI_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RAI_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RAI_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RAI_iE_Extensions                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAI_iE_Extensions (ASN1CTXT* pctxt, RAI_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RAI_iE_Extensions_element (pctxt, ((RAI_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAI                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAI (ASN1CTXT* pctxt, RAI* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode lAI */

   stat = asn1PE_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAC */

   stat = asn1PE_RAC (pctxt, &pvalue->rAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RAI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PagingAreaID                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PagingAreaID (ASN1CTXT* pctxt, PagingAreaID* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* lAI */
         case 1:
            stat = asn1PE_LAI (pctxt, pvalue->u.lAI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* rAI */
         case 2:
            stat = asn1PE_RAI (pctxt, pvalue->u.rAI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PagingCause                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PagingCause (ASN1CTXT* pctxt, PagingCause value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case terminating_conversational_call: ui = 0; break;
      case terminating_streaming_call: ui = 1; break;
      case terminating_interactive_call: ui = 2; break;
      case terminating_background_call: ui = 3; break;
      case terminating_low_priority_signalling: ui = 4; break;
      case terminating_high_priority_signalling: ui = 0; extbit = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NonSearchingIndication                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NonSearchingIndication (ASN1CTXT* pctxt, NonSearchingIndication value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case non_searching: ui = 0; break;
      case searching: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DRX_CycleLengthCoefficient                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DRX_CycleLengthCoefficient (ASN1CTXT* pctxt, DRX_CycleLengthCoefficient value)
{
   int stat = 0;

   if ( (value >= 6 && value <= 9) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(6), OSUINTCONST(9));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceType                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TraceType (ASN1CTXT* pctxt, TraceType* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TriggerID                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TriggerID (ASN1CTXT* pctxt, TriggerID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(22), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEI                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IMEI (ASN1CTXT* pctxt, IMEI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEISV                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IMEISV (ASN1CTXT* pctxt, IMEISV* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(8), OSUINTCONST(8), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UE_ID                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_UE_ID (ASN1CTXT* pctxt, UE_ID* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* imsi */
         case 1:
            stat = asn1PE_IMSI (pctxt, *pvalue->u.imsi);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* imei */
         case 2:
            stat = asn1PE_IMEI (pctxt, pvalue->u.imei);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      rtInitSubContext (&lctxt, pctxt);
      stat = pu_setBuffer (&lctxt, 0, 0, pctxt->buffer.aligned);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      switch (pvalue->t)
      {
         /* imeisv */
         case 3:
            stat = asn1PE_IMEISV (&lctxt, pvalue->u.imeisv);
            if (stat != 0) {
               rtFreeContext (&lctxt);
               return LOG_ASN1ERR (pctxt, stat);
            }
            openType.data = pe_GetMsgPtr (&lctxt, (int*)&openType.numocts);
            break;

         default:
            openType.numocts = pvalue->u.extElem1->numocts;
            openType.data = pvalue->u.extElem1->data;
      }

      stat = pe_byte_align (pctxt);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      rtFreeContext (&lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OMC_ID                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_OMC_ID (ASN1CTXT* pctxt, OMC_ID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(22), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TraceDepth                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TraceDepth (ASN1CTXT* pctxt, TraceDepth value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case minimum: ui = 0; break;
      case medium: ui = 1; break;
      case maximum: ui = 2; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem_interface_                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InterfacesToTraceItem_interface_ (ASN1CTXT* pctxt, InterfacesToTraceItem_interface_ value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case iu_cs: ui = 0; break;
      case iu_ps: ui = 1; break;
      case iur: ui = 2; break;
      case iub: ui = 3; break;
      case uu: ui = 4; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InterfacesToTraceItem_iE_Extensions_element (ASN1CTXT* pctxt, InterfacesToTraceItem_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_InterfacesToTraceItem_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem_iE_Extensions_element               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_InterfacesToTraceItem_iE_Extensions_element (ASN1CTXT* pctxt,
   InterfacesToTraceItem_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < InterfacesToTraceItem_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &InterfacesToTraceItem_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == InterfacesToTraceItem_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = InterfacesToTraceItem_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem_iE_Extensions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InterfacesToTraceItem_iE_Extensions (ASN1CTXT* pctxt, InterfacesToTraceItem_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_InterfacesToTraceItem_iE_Extensions_element (pctxt, ((InterfacesToTraceItem_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterfacesToTraceItem                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InterfacesToTraceItem (ASN1CTXT* pctxt, InterfacesToTraceItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode interface_ */

   stat = asn1PE_InterfacesToTraceItem_interface_ (pctxt, pvalue->interface_);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_InterfacesToTraceItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ListOfInterfacesToTrace                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ListOfInterfacesToTrace (ASN1CTXT* pctxt, ListOfInterfacesToTrace* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(16), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_InterfacesToTraceItem (pctxt, ((InterfacesToTraceItem*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TracePropagationParameters_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TracePropagationParameters_iE_Extensions_element (ASN1CTXT* pctxt, TracePropagationParameters_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_TracePropagationParameters_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TracePropagationParameters_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_TracePropagationParameters_iE_Extensions_element (ASN1CTXT* pctxt,
   TracePropagationParameters_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < TracePropagationParameters_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &TracePropagationParameters_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == TracePropagationParameters_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = TracePropagationParameters_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  TracePropagationParameters_iE_Extensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TracePropagationParameters_iE_Extensions (ASN1CTXT* pctxt, TracePropagationParameters_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_TracePropagationParameters_iE_Extensions_element (pctxt, ((TracePropagationParameters_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TracePropagationParameters                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TracePropagationParameters (ASN1CTXT* pctxt, TracePropagationParameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.listOfInterfacesToTracePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode traceRecordingSessionReference */

   stat = asn1PE_TraceRecordingSessionReference (pctxt, pvalue->traceRecordingSessionReference);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode traceDepth */

   stat = asn1PE_TraceDepth (pctxt, pvalue->traceDepth);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode listOfInterfacesToTrace */

   if (pvalue->m.listOfInterfacesToTracePresent) {
      stat = asn1PE_ListOfInterfacesToTrace (pctxt, &pvalue->listOfInterfacesToTrace);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_TracePropagationParameters_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Event                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Event (ASN1CTXT* pctxt, Event value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case stop_change_of_service_area: ui = 0; break;
      case direct: ui = 1; break;
      case change_of_servicearea: ui = 2; break;
      case stop_direct: ui = 0; extbit = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportArea                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ReportArea (ASN1CTXT* pctxt, ReportArea value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case service_area: ui = 0; break;
      case geographical_area: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RequestType (ASN1CTXT* pctxt, RequestType* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.accuracyCodePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode event */

   stat = asn1PE_Event (pctxt, pvalue->event);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode reportArea */

   stat = asn1PE_ReportArea (pctxt, pvalue->reportArea);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode accuracyCode */

   if (pvalue->m.accuracyCodePresent) {
      if ( (pvalue->accuracyCode <= 127) ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->accuracyCode, OSUINTCONST(0), OSUINTCONST(127));
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
      else
         return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VerticalAccuracyCode                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_VerticalAccuracyCode (ASN1CTXT* pctxt, VerticalAccuracyCode value)
{
   int stat = 0;

   if ( (value <= 127) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResponseTime                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ResponseTime (ASN1CTXT* pctxt, ResponseTime value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case lowdelay: ui = 0; break;
      case delaytolerant: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositioningPriority                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PositioningPriority (ASN1CTXT* pctxt, PositioningPriority value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case high_Priority: ui = 0; break;
      case normal_Priority: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ClientType                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ClientType (ASN1CTXT* pctxt, ClientType value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case emergency_Services: ui = 0; break;
      case value_Added_Services: ui = 1; break;
      case pLMN_Operator_Services: ui = 2; break;
      case lawful_Intercept_Services: ui = 3; break;
      case pLMN_Operator_Broadcast_Services: ui = 4; break;
      case pLMN_Operator_O_et_M: ui = 5; break;
      case pLMN_Operator_Anonymous_Statistics: ui = 6; break;
      case pLMN_Operator_Target_MS_Service_Support: ui = 7; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates_latitudeSign                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GeographicalCoordinates_latitudeSign (ASN1CTXT* pctxt, GeographicalCoordinates_latitudeSign value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case north: ui = 0; break;
      case south: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GeographicalCoordinates_iE_Extensions_element (ASN1CTXT* pctxt, GeographicalCoordinates_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_GeographicalCoordinates_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_GeographicalCoordinates_iE_Extensions_element (ASN1CTXT* pctxt,
   GeographicalCoordinates_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GeographicalCoordinates_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GeographicalCoordinates_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GeographicalCoordinates_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = GeographicalCoordinates_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates_iE_Extensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GeographicalCoordinates_iE_Extensions (ASN1CTXT* pctxt, GeographicalCoordinates_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_GeographicalCoordinates_iE_Extensions_element (pctxt, ((GeographicalCoordinates_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeographicalCoordinates                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GeographicalCoordinates (ASN1CTXT* pctxt, GeographicalCoordinates* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode latitudeSign */

   stat = asn1PE_GeographicalCoordinates_latitudeSign (pctxt, pvalue->latitudeSign);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode latitude */

   if ( (pvalue->latitude <= 8388607) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->latitude, OSUINTCONST(0), OSUINTCONST(8388607));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   /* encode longitude */

   if ( (pvalue->longitude >= -8388608 && pvalue->longitude <= 8388607) ) {
      stat = pe_ConsInteger (pctxt, pvalue->longitude, OSINTCONST(-8388608), OSINTCONST(8388607));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_GeographicalCoordinates_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Point_iE_Extensions_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_Point_iE_Extensions_element (ASN1CTXT* pctxt, GA_Point_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_GA_Point_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Point_iE_Extensions_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_GA_Point_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_Point_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_Point_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_Point_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_Point_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = GA_Point_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_Point_iE_Extensions                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_Point_iE_Extensions (ASN1CTXT* pctxt, GA_Point_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_GA_Point_iE_Extensions_element (pctxt, ((GA_Point_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Point                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_Point (ASN1CTXT* pctxt, GA_Point* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode geographicalCoordinates */

   stat = asn1PE_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_GA_Point_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertainty_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_PointWithUnCertainty_iE_Extensions_element (ASN1CTXT* pctxt, GA_PointWithUnCertainty_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_GA_PointWithUnCertainty_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertainty_iE_Extensions_element             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_GA_PointWithUnCertainty_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_PointWithUnCertainty_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_PointWithUnCertainty_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_PointWithUnCertainty_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_PointWithUnCertainty_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = GA_PointWithUnCertainty_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertainty_iE_Extensions                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_PointWithUnCertainty_iE_Extensions (ASN1CTXT* pctxt, GA_PointWithUnCertainty_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_GA_PointWithUnCertainty_iE_Extensions_element (pctxt, ((GA_PointWithUnCertainty_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertainty                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_PointWithUnCertainty (ASN1CTXT* pctxt, GA_PointWithUnCertainty* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode geographicalCoordinates */

   stat = asn1PE_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_GA_PointWithUnCertainty_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode uncertaintyCode */

   if ( (pvalue->uncertaintyCode <= 127) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->uncertaintyCode, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Polygon_element_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_Polygon_element_iE_Extensions_element (ASN1CTXT* pctxt, GA_Polygon_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_GA_Polygon_element_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Polygon_element_iE_Extensions_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_GA_Polygon_element_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_Polygon_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_Polygon_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_Polygon_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_Polygon_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = GA_Polygon_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_Polygon_element_iE_Extensions                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_Polygon_element_iE_Extensions (ASN1CTXT* pctxt, GA_Polygon_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_GA_Polygon_element_iE_Extensions_element (pctxt, ((GA_Polygon_element_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Polygon_element                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_Polygon_element (ASN1CTXT* pctxt, GA_Polygon_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode geographicalCoordinates */

   stat = asn1PE_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_GA_Polygon_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_Polygon                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_Polygon (ASN1CTXT* pctxt, GA_Polygon* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(15), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_GA_Polygon_element (pctxt, ((GA_Polygon_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_UncertaintyEllipse                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_UncertaintyEllipse (ASN1CTXT* pctxt, GA_UncertaintyEllipse* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode uncertaintySemi_major */

   if ( (pvalue->uncertaintySemi_major <= 127) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->uncertaintySemi_major, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   /* encode uncertaintySemi_minor */

   if ( (pvalue->uncertaintySemi_minor <= 127) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->uncertaintySemi_minor, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   /* encode orientationOfMajorAxis */

   if ( (pvalue->orientationOfMajorAxis <= 179) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->orientationOfMajorAxis, OSUINTCONST(0), OSUINTCONST(179));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertaintyEllipse_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_PointWithUnCertaintyEllipse_iE_Extensions_element (ASN1CTXT* pctxt, GA_PointWithUnCertaintyEllipse_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_GA_PointWithUnCertaintyEllipse_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertaintyEllipse_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_GA_PointWithUnCertaintyEllipse_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_PointWithUnCertaintyEllipse_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_PointWithUnCertaintyEllipse_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_PointWithUnCertaintyEllipse_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_PointWithUnCertaintyEllipse_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = GA_PointWithUnCertaintyEllipse_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertaintyEllipse_iE_Extensions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_PointWithUnCertaintyEllipse_iE_Extensions (ASN1CTXT* pctxt, GA_PointWithUnCertaintyEllipse_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_GA_PointWithUnCertaintyEllipse_iE_Extensions_element (pctxt, ((GA_PointWithUnCertaintyEllipse_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithUnCertaintyEllipse                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_PointWithUnCertaintyEllipse (ASN1CTXT* pctxt, GA_PointWithUnCertaintyEllipse* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode geographicalCoordinates */

   stat = asn1PE_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode uncertaintyEllipse */

   stat = asn1PE_GA_UncertaintyEllipse (pctxt, &pvalue->uncertaintyEllipse);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode confidence */

   if ( (pvalue->confidence <= 127) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->confidence, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_GA_PointWithUnCertaintyEllipse_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_AltitudeAndDirection_directionOfAltitude               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_AltitudeAndDirection_directionOfAltitude (ASN1CTXT* pctxt, GA_AltitudeAndDirection_directionOfAltitude value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case height: ui = 0; break;
      case depth: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_AltitudeAndDirection                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_AltitudeAndDirection (ASN1CTXT* pctxt, GA_AltitudeAndDirection* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode directionOfAltitude */

   stat = asn1PE_GA_AltitudeAndDirection_directionOfAltitude (pctxt, pvalue->directionOfAltitude);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode altitude */

   if ( (pvalue->altitude <= 32767) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->altitude, OSUINTCONST(0), OSUINTCONST(32767));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitude_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_PointWithAltitude_iE_Extensions_element (ASN1CTXT* pctxt, GA_PointWithAltitude_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_GA_PointWithAltitude_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitude_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_GA_PointWithAltitude_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_PointWithAltitude_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_PointWithAltitude_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_PointWithAltitude_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_PointWithAltitude_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = GA_PointWithAltitude_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitude_iE_Extensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_PointWithAltitude_iE_Extensions (ASN1CTXT* pctxt, GA_PointWithAltitude_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_GA_PointWithAltitude_iE_Extensions_element (pctxt, ((GA_PointWithAltitude_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitude                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_PointWithAltitude (ASN1CTXT* pctxt, GA_PointWithAltitude* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode geographicalCoordinates */

   stat = asn1PE_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode altitudeAndDirection */

   stat = asn1PE_GA_AltitudeAndDirection (pctxt, &pvalue->altitudeAndDirection);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_GA_PointWithAltitude_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extension  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element (ASN1CTXT* pctxt, GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extension  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = GA_PointWithAltitudeAndUncertaintyEllipsoid_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extension  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions (ASN1CTXT* pctxt, GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element (pctxt, ((GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_PointWithAltitudeAndUncertaintyEllipsoid               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_PointWithAltitudeAndUncertaintyEllipsoid (ASN1CTXT* pctxt, GA_PointWithAltitudeAndUncertaintyEllipsoid* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode geographicalCoordinates */

   stat = asn1PE_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode altitudeAndDirection */

   stat = asn1PE_GA_AltitudeAndDirection (pctxt, &pvalue->altitudeAndDirection);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode uncertaintyEllipse */

   stat = asn1PE_GA_UncertaintyEllipse (pctxt, &pvalue->uncertaintyEllipse);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode uncertaintyAltitude */

   if ( (pvalue->uncertaintyAltitude <= 127) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->uncertaintyAltitude, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   /* encode confidence */

   if ( (pvalue->confidence <= 127) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->confidence, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_GA_PointWithAltitudeAndUncertaintyEllipsoid_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_EllipsoidArc_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_EllipsoidArc_iE_Extensions_element (ASN1CTXT* pctxt, GA_EllipsoidArc_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_GA_EllipsoidArc_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_EllipsoidArc_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_GA_EllipsoidArc_iE_Extensions_element (ASN1CTXT* pctxt,
   GA_EllipsoidArc_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GA_EllipsoidArc_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GA_EllipsoidArc_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GA_EllipsoidArc_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = GA_EllipsoidArc_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GA_EllipsoidArc_iE_Extensions                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_EllipsoidArc_iE_Extensions (ASN1CTXT* pctxt, GA_EllipsoidArc_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_GA_EllipsoidArc_iE_Extensions_element (pctxt, ((GA_EllipsoidArc_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GA_EllipsoidArc                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GA_EllipsoidArc (ASN1CTXT* pctxt, GA_EllipsoidArc* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode geographicalCoordinates */

   stat = asn1PE_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode innerRadius */

   stat = pe_ConsUnsigned (pctxt, pvalue->innerRadius, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode uncertaintyRadius */

   if ( (pvalue->uncertaintyRadius <= 127) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->uncertaintyRadius, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   /* encode offsetAngle */

   if ( (pvalue->offsetAngle <= 179) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->offsetAngle, OSUINTCONST(0), OSUINTCONST(179));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   /* encode includedAngle */

   if ( (pvalue->includedAngle <= 179) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->includedAngle, OSUINTCONST(0), OSUINTCONST(179));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   /* encode confidence */

   if ( (pvalue->confidence <= 127) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->confidence, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_GA_EllipsoidArc_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeographicalArea                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GeographicalArea (ASN1CTXT* pctxt, GeographicalArea* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;
   ASN1OpenType openType;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 3);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* point */
         case 1:
            stat = asn1PE_GA_Point (pctxt, pvalue->u.point);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* pointWithUnCertainty */
         case 2:
            stat = asn1PE_GA_PointWithUnCertainty (pctxt, pvalue->u.pointWithUnCertainty);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* polygon */
         case 3:
            stat = asn1PE_GA_Polygon (pctxt, pvalue->u.polygon);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 4);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      rtInitSubContext (&lctxt, pctxt);
      stat = pu_setBuffer (&lctxt, 0, 0, pctxt->buffer.aligned);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      switch (pvalue->t)
      {
         /* pointWithUncertaintyEllipse */
         case 4:
            stat = asn1PE_GA_PointWithUnCertaintyEllipse (&lctxt, pvalue->u.pointWithUncertaintyEllipse);
            if (stat != 0) {
               rtFreeContext (&lctxt);
               return LOG_ASN1ERR (pctxt, stat);
            }
            openType.data = pe_GetMsgPtr (&lctxt, (int*)&openType.numocts);
            break;

         /* pointWithAltitude */
         case 5:
            stat = asn1PE_GA_PointWithAltitude (&lctxt, pvalue->u.pointWithAltitude);
            if (stat != 0) {
               rtFreeContext (&lctxt);
               return LOG_ASN1ERR (pctxt, stat);
            }
            openType.data = pe_GetMsgPtr (&lctxt, (int*)&openType.numocts);
            break;

         /* pointWithAltitudeAndUncertaintyEllipsoid */
         case 6:
            stat = asn1PE_GA_PointWithAltitudeAndUncertaintyEllipsoid (&lctxt, pvalue->u.pointWithAltitudeAndUncertaintyEllipsoid);
            if (stat != 0) {
               rtFreeContext (&lctxt);
               return LOG_ASN1ERR (pctxt, stat);
            }
            openType.data = pe_GetMsgPtr (&lctxt, (int*)&openType.numocts);
            break;

         /* ellipsoidArc */
         case 7:
            stat = asn1PE_GA_EllipsoidArc (&lctxt, pvalue->u.ellipsoidArc);
            if (stat != 0) {
               rtFreeContext (&lctxt);
               return LOG_ASN1ERR (pctxt, stat);
            }
            openType.data = pe_GetMsgPtr (&lctxt, (int*)&openType.numocts);
            break;

         default:
            openType.numocts = pvalue->u.extElem1->numocts;
            openType.data = pvalue->u.extElem1->data;
      }

      stat = pe_byte_align (pctxt);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
      if (stat != 0) {
         rtFreeContext (&lctxt);
         return LOG_ASN1ERR (pctxt, stat);
      }

      rtFreeContext (&lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AreaIdentity                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AreaIdentity (ASN1CTXT* pctxt, AreaIdentity* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* sAI */
         case 1:
            stat = asn1PE_SAI (pctxt, pvalue->u.sAI);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* geographicalArea */
         case 2:
            stat = asn1PE_GeographicalArea (pctxt, pvalue->u.geographicalArea);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LastKnownServiceArea_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LastKnownServiceArea_iE_Extensions_element (ASN1CTXT* pctxt, LastKnownServiceArea_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_LastKnownServiceArea_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LastKnownServiceArea_iE_Extensions_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_LastKnownServiceArea_iE_Extensions_element (ASN1CTXT* pctxt,
   LastKnownServiceArea_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LastKnownServiceArea_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LastKnownServiceArea_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LastKnownServiceArea_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = LastKnownServiceArea_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LastKnownServiceArea_iE_Extensions                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LastKnownServiceArea_iE_Extensions (ASN1CTXT* pctxt, LastKnownServiceArea_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_LastKnownServiceArea_iE_Extensions_element (pctxt, ((LastKnownServiceArea_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LastKnownServiceArea                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LastKnownServiceArea (ASN1CTXT* pctxt, LastKnownServiceArea* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode sAI */

   stat = asn1PE_SAI (pctxt, &pvalue->sAI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode ageOfSAI */

   if ( (pvalue->ageOfSAI <= 32767) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->ageOfSAI, OSUINTCONST(0), OSUINTCONST(32767));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_LastKnownServiceArea_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositioningDataDiscriminator                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PositioningDataDiscriminator (ASN1CTXT* pctxt, PositioningDataDiscriminator* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositioningMethodAndUsage                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PositioningMethodAndUsage (ASN1CTXT* pctxt, PositioningMethodAndUsage* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositioningDataSet                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PositioningDataSet (ASN1CTXT* pctxt, PositioningDataSet* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(9), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_PositioningMethodAndUsage (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositionData_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PositionData_iE_Extensions_element (ASN1CTXT* pctxt, PositionData_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_PositionData_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositionData_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_PositionData_iE_Extensions_element (ASN1CTXT* pctxt,
   PositionData_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < PositionData_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &PositionData_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == PositionData_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = PositionData_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  PositionData_iE_Extensions                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PositionData_iE_Extensions (ASN1CTXT* pctxt, PositionData_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_PositionData_iE_Extensions_element (pctxt, ((PositionData_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositionData                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PositionData (ASN1CTXT* pctxt, PositionData* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.positioningDataSetPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode positioningDataDiscriminator */

   stat = asn1PE_PositioningDataDiscriminator (pctxt, &pvalue->positioningDataDiscriminator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode positioningDataSet */

   if (pvalue->m.positioningDataSetPresent) {
      stat = asn1PE_PositioningDataSet (pctxt, &pvalue->positioningDataSet);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_PositionData_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositionDataSpecificToGERANIuMode                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PositionDataSpecificToGERANIuMode (ASN1CTXT* pctxt, PositionDataSpecificToGERANIuMode value)
{
   int stat = 0;

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccuracyFulfilmentIndicator                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AccuracyFulfilmentIndicator (ASN1CTXT* pctxt, AccuracyFulfilmentIndicator value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case requested_Accuracy_Fulfilled: ui = 0; break;
      case requested_Accuracy_Not_Fulfilled: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NAS_PDU                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NAS_PDU (ASN1CTXT* pctxt, NAS_PDU value)
{
   int stat = 0;

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NAS_SequenceNumber                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NAS_SequenceNumber (ASN1CTXT* pctxt, NAS_SequenceNumber* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SAPI                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SAPI (ASN1CTXT* pctxt, SAPI value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case sapi_0: ui = 0; break;
      case sapi_3: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RejectCauseValue                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RejectCauseValue (ASN1CTXT* pctxt, RejectCauseValue value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case pLMN_Not_Allowed: ui = 0; break;
      case location_Area_Not_Allowed: ui = 1; break;
      case roaming_Not_Allowed_In_This_Location_Area: ui = 2; break;
      case no_Suitable_Cell_In_Location_Area: ui = 3; break;
      case gPRS_Services_Not_Allowed_In_This_PLMN: ui = 4; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedirectionCompleted                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RedirectionCompleted (ASN1CTXT* pctxt, RedirectionCompleted value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case redirection_completed: ui = 0; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NumberOfSteps                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NumberOfSteps (ASN1CTXT* pctxt, NumberOfSteps value)
{
   int stat = 0;

   if ( (value >= 1 && value <= 16) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(16));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_MaxBitrateList                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Requested_RAB_Parameter_MaxBitrateList (ASN1CTXT* pctxt, Requested_RAB_Parameter_MaxBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_MaxBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_GuaranteedBitrateList             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Requested_RAB_Parameter_GuaranteedBitrateList (ASN1CTXT* pctxt, Requested_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(2), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_GuaranteedBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AlternativeRABConfigurationRequest                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_AlternativeRABConfigurationRequest (ASN1CTXT* pctxt, AlternativeRABConfigurationRequest value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case alternative_RAB_configuration_Requested: ui = 0; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _Requested_RAB_Parameter_Values_ExtIEs_Extension          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE__Requested_RAB_Parameter_Values_ExtIEs_Extension (ASN1CTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _Requested_RAB_Parameter_Values_ExtIEs_Extension value = *((_Requested_RAB_Parameter_Values_ExtIEs_Extension*)pvalue_);
   stat = asn1PE_AlternativeRABConfigurationRequest (pctxt, value);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_Values_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Requested_RAB_Parameter_Values_iE_Extensions_element (ASN1CTXT* pctxt, Requested_RAB_Parameter_Values_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_Requested_RAB_Parameter_Values_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_Values_iE_Extensions_element      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_Requested_RAB_Parameter_Values_iE_Extensions_element (ASN1CTXT* pctxt,
   Requested_RAB_Parameter_Values_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Requested_RAB_Parameter_Values_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Requested_RAB_Parameter_Values_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Requested_RAB_Parameter_Values_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = Requested_RAB_Parameter_Values_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_Values_iE_Extensions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Requested_RAB_Parameter_Values_iE_Extensions (ASN1CTXT* pctxt, Requested_RAB_Parameter_Values_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_Requested_RAB_Parameter_Values_iE_Extensions_element (pctxt, ((Requested_RAB_Parameter_Values_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Requested_RAB_Parameter_Values                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Requested_RAB_Parameter_Values (ASN1CTXT* pctxt, Requested_RAB_Parameter_Values* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.requestedMaxBitratesPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.requestedGuaranteedBitratesPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode requestedMaxBitrates */

   if (pvalue->m.requestedMaxBitratesPresent) {
      stat = asn1PE_Requested_RAB_Parameter_MaxBitrateList (pctxt, &pvalue->requestedMaxBitrates);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode requestedGuaranteedBitrates */

   if (pvalue->m.requestedGuaranteedBitratesPresent) {
      stat = asn1PE_Requested_RAB_Parameter_GuaranteedBitrateList (pctxt, &pvalue->requestedGuaranteedBitrates);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_Requested_RAB_Parameter_Values_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestedLocationRelatedDataType                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RequestedLocationRelatedDataType (ASN1CTXT* pctxt, RequestedLocationRelatedDataType value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case decipheringKeysUEBasedOTDOA: ui = 0; break;
      case decipheringKeysAssistedGPS: ui = 1; break;
      case dedicatedAssistanceDataUEBasedOTDOA: ui = 2; break;
      case dedicatedAssistanceDataAssistedGPS: ui = 3; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestedGPSAssistanceData                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RequestedGPSAssistanceData (ASN1CTXT* pctxt, RequestedGPSAssistanceData* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(38), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequestType                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationRelatedDataRequestType (ASN1CTXT* pctxt, LocationRelatedDataRequestType* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.requestedGPSAssistanceDataPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode requestedLocationRelatedDataType */

   stat = asn1PE_RequestedLocationRelatedDataType (pctxt, pvalue->requestedLocationRelatedDataType);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode requestedGPSAssistanceData */

   if (pvalue->m.requestedGPSAssistanceDataPresent) {
      stat = asn1PE_RequestedGPSAssistanceData (pctxt, &pvalue->requestedGPSAssistanceData);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LocationRelatedDataRequestTypeSpecificToGERANIuMode       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LocationRelatedDataRequestTypeSpecificToGERANIuMode (ASN1CTXT* pctxt, LocationRelatedDataRequestTypeSpecificToGERANIuMode value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case decipheringKeysEOTD: ui = 0; break;
      case dedicatedMobileAssistedEOTDAssistanceData: ui = 1; break;
      case dedicatedMobileBasedEOTDAssistanceData: ui = 2; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BroadcastAssistanceDataDecipheringKeys_cipheringKeyFlag   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_BroadcastAssistanceDataDecipheringKeys_cipheringKeyFlag (ASN1CTXT* pctxt, BroadcastAssistanceDataDecipheringKeys_cipheringKeyFlag* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BroadcastAssistanceDataDecipheringKeys_currentDecipherin  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey (ASN1CTXT* pctxt, BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(56), OSUINTCONST(56), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BroadcastAssistanceDataDecipheringKeys_nextDecipheringKe  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey (ASN1CTXT* pctxt, BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(56), OSUINTCONST(56), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BroadcastAssistanceDataDecipheringKeys                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_BroadcastAssistanceDataDecipheringKeys (ASN1CTXT* pctxt, BroadcastAssistanceDataDecipheringKeys* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode cipheringKeyFlag */

   stat = asn1PE_BroadcastAssistanceDataDecipheringKeys_cipheringKeyFlag (pctxt, &pvalue->cipheringKeyFlag);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode currentDecipheringKey */

   stat = asn1PE_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey (pctxt, &pvalue->currentDecipheringKey);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode nextDecipheringKey */

   stat = asn1PE_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey (pctxt, &pvalue->nextDecipheringKey);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferID                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationTransferID (ASN1CTXT* pctxt, InformationTransferID value)
{
   int stat = 0;

   if ( (value <= 1048575) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(1048575));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ListOF_SNAs                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ListOF_SNAs (ASN1CTXT* pctxt, ListOF_SNAs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65536), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_SNAC (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LA_LIST_element_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LA_LIST_element_iE_Extensions_element (ASN1CTXT* pctxt, LA_LIST_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_LA_LIST_element_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LA_LIST_element_iE_Extensions_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_LA_LIST_element_iE_Extensions_element (ASN1CTXT* pctxt,
   LA_LIST_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < LA_LIST_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &LA_LIST_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == LA_LIST_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = LA_LIST_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  LA_LIST_element_iE_Extensions                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LA_LIST_element_iE_Extensions (ASN1CTXT* pctxt, LA_LIST_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_LA_LIST_element_iE_Extensions_element (pctxt, ((LA_LIST_element_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LA_LIST_element                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LA_LIST_element (ASN1CTXT* pctxt, LA_LIST_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode lAC */

   stat = asn1PE_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode listOF_SNAs */

   stat = asn1PE_ListOF_SNAs (pctxt, &pvalue->listOF_SNAs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_LA_LIST_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LA_LIST                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_LA_LIST (ASN1CTXT* pctxt, LA_LIST* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65536), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;
   OSUINT32 enclen, fraglen;

   enclen = fraglen = xx1 = 0;
   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   pnode = pvalue->head;
   for (;;) {
      /* encode length determinant */

      stat = pe_Length (pctxt, (pvalue->count - enclen));
      if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

      fraglen = stat;
      enclen += fraglen;
      /* encode elements */

      for (; xx1 < enclen; xx1++) {
         stat = asn1PE_LA_LIST_element (pctxt, ((LA_LIST_element*)pnode->data));
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
         pnode = pnode->next;
      }
      if ( pvalue->count == enclen && fraglen < 16384) {
         break;
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network_element_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PLMNs_in_shared_network_element_iE_Extensions_element (ASN1CTXT* pctxt, PLMNs_in_shared_network_element_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_PLMNs_in_shared_network_element_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network_element_iE_Extensions_element     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_PLMNs_in_shared_network_element_iE_Extensions_element (ASN1CTXT* pctxt,
   PLMNs_in_shared_network_element_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < PLMNs_in_shared_network_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &PLMNs_in_shared_network_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == PLMNs_in_shared_network_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = PLMNs_in_shared_network_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network_element_iE_Extensions             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PLMNs_in_shared_network_element_iE_Extensions (ASN1CTXT* pctxt, PLMNs_in_shared_network_element_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_PLMNs_in_shared_network_element_iE_Extensions_element (pctxt, ((PLMNs_in_shared_network_element_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PLMNs_in_shared_network_element (ASN1CTXT* pctxt, PLMNs_in_shared_network_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode pLMNidentity */

   stat = asn1PE_PLMNidentity (pctxt, pvalue->pLMNidentity);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode lA_LIST */

   stat = asn1PE_LA_LIST (pctxt, &pvalue->lA_LIST);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_PLMNs_in_shared_network_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PLMNs_in_shared_network                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_PLMNs_in_shared_network (ASN1CTXT* pctxt, PLMNs_in_shared_network* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(32), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_PLMNs_in_shared_network_element (pctxt, ((PLMNs_in_shared_network_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Shared_Network_Information_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Shared_Network_Information_iE_Extensions_element (ASN1CTXT* pctxt, Shared_Network_Information_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_Shared_Network_Information_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Shared_Network_Information_iE_Extensions_element          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_Shared_Network_Information_iE_Extensions_element (ASN1CTXT* pctxt,
   Shared_Network_Information_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < Shared_Network_Information_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &Shared_Network_Information_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == Shared_Network_Information_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = Shared_Network_Information_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  Shared_Network_Information_iE_Extensions                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Shared_Network_Information_iE_Extensions (ASN1CTXT* pctxt, Shared_Network_Information_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_Shared_Network_Information_iE_Extensions_element (pctxt, ((Shared_Network_Information_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Shared_Network_Information                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_Shared_Network_Information (ASN1CTXT* pctxt, Shared_Network_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode pLMNs_in_shared_network */

   stat = asn1PE_PLMNs_in_shared_network (pctxt, &pvalue->pLMNs_in_shared_network);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_Shared_Network_Information_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ProvidedData                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_ProvidedData (ASN1CTXT* pctxt, ProvidedData* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 1);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 0);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* shared_network_information */
         case 1:
            stat = asn1PE_Shared_Network_Information (pctxt, pvalue->u.shared_network_information);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RIMInformation                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RIMInformation (ASN1CTXT* pctxt, RIMInformation value)
{
   int stat = 0;

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Cell_ID_iE_Extensions_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GERAN_Cell_ID_iE_Extensions_element (ASN1CTXT* pctxt, GERAN_Cell_ID_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_GERAN_Cell_ID_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Cell_ID_iE_Extensions_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_GERAN_Cell_ID_iE_Extensions_element (ASN1CTXT* pctxt,
   GERAN_Cell_ID_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < GERAN_Cell_ID_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &GERAN_Cell_ID_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == GERAN_Cell_ID_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = GERAN_Cell_ID_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  GERAN_Cell_ID_iE_Extensions                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GERAN_Cell_ID_iE_Extensions (ASN1CTXT* pctxt, GERAN_Cell_ID_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_GERAN_Cell_ID_iE_Extensions_element (pctxt, ((GERAN_Cell_ID_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GERAN_Cell_ID                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_GERAN_Cell_ID (ASN1CTXT* pctxt, GERAN_Cell_ID* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode lAI */

   stat = asn1PE_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAC */

   stat = asn1PE_RAC (pctxt, &pvalue->rAC);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode cI */

   stat = asn1PE_CI (pctxt, &pvalue->cI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_GERAN_Cell_ID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RIMRoutingAddress                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RIMRoutingAddress (ASN1CTXT* pctxt, RIMRoutingAddress* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* globalRNC_ID */
         case 1:
            stat = asn1PE_GlobalRNC_ID (pctxt, pvalue->u.globalRNC_ID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* gERAN_Cell_ID */
         case 2:
            stat = asn1PE_GERAN_Cell_ID (pctxt, pvalue->u.gERAN_Cell_ID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RIM_Transfer_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RIM_Transfer_iE_Extensions_element (ASN1CTXT* pctxt, RIM_Transfer_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RIM_Transfer_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RIM_Transfer_iE_Extensions_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RIM_Transfer_iE_Extensions_element (ASN1CTXT* pctxt,
   RIM_Transfer_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RIM_Transfer_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RIM_Transfer_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RIM_Transfer_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RIM_Transfer_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RIM_Transfer_iE_Extensions                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RIM_Transfer_iE_Extensions (ASN1CTXT* pctxt, RIM_Transfer_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RIM_Transfer_iE_Extensions_element (pctxt, ((RIM_Transfer_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RIM_Transfer                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RIM_Transfer (ASN1CTXT* pctxt, RIM_Transfer* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.rIMRoutingAddressPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rIMInformation */

   stat = asn1PE_RIMInformation (pctxt, pvalue->rIMInformation);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rIMRoutingAddress */

   if (pvalue->m.rIMRoutingAddressPresent) {
      stat = asn1PE_RIMRoutingAddress (pctxt, &pvalue->rIMRoutingAddress);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RIM_Transfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterSystemInformationTransferType                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InterSystemInformationTransferType (ASN1CTXT* pctxt, InterSystemInformationTransferType* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 1);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 0);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* rIM_Transfer */
         case 1:
            stat = asn1PE_RIM_Transfer (pctxt, pvalue->u.rIM_Transfer);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationExchangeID                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationExchangeID (ASN1CTXT* pctxt, InformationExchangeID value)
{
   int stat = 0;

   if ( (value <= 1048575) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(1048575));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationExchangeType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationExchangeType (ASN1CTXT* pctxt, InformationExchangeType value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case transfer: ui = 0; break;
      case request: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation_traceActivationIndicator              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RNCTraceInformation_traceActivationIndicator (ASN1CTXT* pctxt, RNCTraceInformation_traceActivationIndicator value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case activated: ui = 0; break;
      case deactivated: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEIList                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IMEIList (ASN1CTXT* pctxt, IMEIList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_IMEI (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEISVList                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IMEISVList (ASN1CTXT* pctxt, IMEISVList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(64), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_IMEISV (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEIGroup_iMEIMask                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IMEIGroup_iMEIMask (ASN1CTXT* pctxt, IMEIGroup_iMEIMask* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(7), OSUINTCONST(7), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEIGroup_iE_Extensions_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IMEIGroup_iE_Extensions_element (ASN1CTXT* pctxt, IMEIGroup_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_IMEIGroup_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEIGroup_iE_Extensions_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_IMEIGroup_iE_Extensions_element (ASN1CTXT* pctxt,
   IMEIGroup_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < IMEIGroup_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &IMEIGroup_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == IMEIGroup_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = IMEIGroup_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  IMEIGroup_iE_Extensions                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IMEIGroup_iE_Extensions (ASN1CTXT* pctxt, IMEIGroup_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_IMEIGroup_iE_Extensions_element (pctxt, ((IMEIGroup_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEIGroup                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IMEIGroup (ASN1CTXT* pctxt, IMEIGroup* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iMEI */

   stat = asn1PE_IMEI (pctxt, &pvalue->iMEI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iMEIMask */

   stat = asn1PE_IMEIGroup_iMEIMask (pctxt, &pvalue->iMEIMask);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_IMEIGroup_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup_iMEISVMask                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IMEISVGroup_iMEISVMask (ASN1CTXT* pctxt, IMEISVGroup_iMEISVMask* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(7), OSUINTCONST(7), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup_iE_Extensions_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IMEISVGroup_iE_Extensions_element (ASN1CTXT* pctxt, IMEISVGroup_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_IMEISVGroup_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup_iE_Extensions_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_IMEISVGroup_iE_Extensions_element (ASN1CTXT* pctxt,
   IMEISVGroup_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < IMEISVGroup_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &IMEISVGroup_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == IMEISVGroup_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = IMEISVGroup_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup_iE_Extensions                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IMEISVGroup_iE_Extensions (ASN1CTXT* pctxt, IMEISVGroup_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_IMEISVGroup_iE_Extensions_element (pctxt, ((IMEISVGroup_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IMEISVGroup                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IMEISVGroup (ASN1CTXT* pctxt, IMEISVGroup* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iMEISV */

   stat = asn1PE_IMEISV (pctxt, &pvalue->iMEISV);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iMEISVMask */

   stat = asn1PE_IMEISVGroup_iMEISVMask (pctxt, &pvalue->iMEISVMask);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_IMEISVGroup_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquipmentsToBeTraced                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_EquipmentsToBeTraced (ASN1CTXT* pctxt, EquipmentsToBeTraced* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 4);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* iMEIlist */
         case 1:
            stat = asn1PE_IMEIList (pctxt, pvalue->u.iMEIlist);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* iMEISVlist */
         case 2:
            stat = asn1PE_IMEISVList (pctxt, pvalue->u.iMEISVlist);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* iMEIgroup */
         case 3:
            stat = asn1PE_IMEIGroup (pctxt, pvalue->u.iMEIgroup);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* iMEISVgroup */
         case 4:
            stat = asn1PE_IMEISVGroup (pctxt, pvalue->u.iMEISVgroup);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 5);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation_iE_Extensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RNCTraceInformation_iE_Extensions_element (ASN1CTXT* pctxt, RNCTraceInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_RNCTraceInformation_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation_iE_Extensions_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_RNCTraceInformation_iE_Extensions_element (ASN1CTXT* pctxt,
   RNCTraceInformation_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < RNCTraceInformation_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &RNCTraceInformation_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == RNCTraceInformation_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = RNCTraceInformation_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation_iE_Extensions                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RNCTraceInformation_iE_Extensions (ASN1CTXT* pctxt, RNCTraceInformation_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_RNCTraceInformation_iE_Extensions_element (pctxt, ((RNCTraceInformation_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RNCTraceInformation                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RNCTraceInformation (ASN1CTXT* pctxt, RNCTraceInformation* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.equipmentsToBeTracedPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode traceReference */

   stat = asn1PE_TraceReference (pctxt, &pvalue->traceReference);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode traceActivationIndicator */

   stat = asn1PE_RNCTraceInformation_traceActivationIndicator (pctxt, pvalue->traceActivationIndicator);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode equipmentsToBeTraced */

   if (pvalue->m.equipmentsToBeTracedPresent) {
      stat = asn1PE_EquipmentsToBeTraced (pctxt, &pvalue->equipmentsToBeTraced);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_RNCTraceInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationTransferType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationTransferType (ASN1CTXT* pctxt, InformationTransferType* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 1);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 0);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* rNCTraceInformation */
         case 1:
            stat = asn1PE_RNCTraceInformation (pctxt, pvalue->u.rNCTraceInformation);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 2);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNRequest                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSIPMulticastAddressandAPNRequest (ASN1CTXT* pctxt, MBMSIPMulticastAddressandAPNRequest* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(512), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_TMGI (pctxt, ((TMGI*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationRequestType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationRequestType (ASN1CTXT* pctxt, InformationRequestType* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* mBMSIPMulticastAddressandAPNRequest */
         case 1:
            stat = asn1PE_MBMSIPMulticastAddressandAPNRequest (pctxt, pvalue->u.mBMSIPMulticastAddressandAPNRequest);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* permanentNAS_UE_ID */
         case 2:
            stat = asn1PE_PermanentNAS_UE_ID (pctxt, pvalue->u.permanentNAS_UE_ID);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IPMulticastAddress                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_IPMulticastAddress (ASN1CTXT* pctxt, IPMulticastAddress* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(16), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  APN                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_APN (ASN1CTXT* pctxt, APN* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(255), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNlist_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSIPMulticastAddressandAPNlist_iE_Extensions_element (ASN1CTXT* pctxt, MBMSIPMulticastAddressandAPNlist_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_MBMSIPMulticastAddressandAPNlist_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNlist_iE_Extensions_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_MBMSIPMulticastAddressandAPNlist_iE_Extensions_element (ASN1CTXT* pctxt,
   MBMSIPMulticastAddressandAPNlist_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < MBMSIPMulticastAddressandAPNlist_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &MBMSIPMulticastAddressandAPNlist_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == MBMSIPMulticastAddressandAPNlist_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = MBMSIPMulticastAddressandAPNlist_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNlist_iE_Extensions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSIPMulticastAddressandAPNlist_iE_Extensions (ASN1CTXT* pctxt, MBMSIPMulticastAddressandAPNlist_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSIPMulticastAddressandAPNlist_iE_Extensions_element (pctxt, ((MBMSIPMulticastAddressandAPNlist_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSIPMulticastAddressandAPNlist                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSIPMulticastAddressandAPNlist (ASN1CTXT* pctxt, MBMSIPMulticastAddressandAPNlist* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode tMGI */

   stat = asn1PE_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iPMulticastAddress */

   stat = asn1PE_IPMulticastAddress (pctxt, &pvalue->iPMulticastAddress);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode aPN */

   stat = asn1PE_APN (pctxt, &pvalue->aPN);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_MBMSIPMulticastAddressandAPNlist_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestedMBMSIPMulticastAddressandAPNRequest              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RequestedMBMSIPMulticastAddressandAPNRequest (ASN1CTXT* pctxt, RequestedMBMSIPMulticastAddressandAPNRequest* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(512), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_MBMSIPMulticastAddressandAPNlist (pctxt, ((MBMSIPMulticastAddressandAPNlist*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestedMulticastServiceList                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RequestedMulticastServiceList (ASN1CTXT* pctxt, RequestedMulticastServiceList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(128), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_TMGI (pctxt, ((TMGI*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationRequested                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_InformationRequested (ASN1CTXT* pctxt, InformationRequested* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* requestedMBMSIPMulticastAddressandAPNRequest */
         case 1:
            stat = asn1PE_RequestedMBMSIPMulticastAddressandAPNRequest (pctxt, pvalue->u.requestedMBMSIPMulticastAddressandAPNRequest);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* requestedMulticastServiceList */
         case 2:
            stat = asn1PE_RequestedMulticastServiceList (pctxt, pvalue->u.requestedMulticastServiceList);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionIdentity                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionIdentity (ASN1CTXT* pctxt, MBMSSessionIdentity* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSBearerServiceType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSBearerServiceType (ASN1CTXT* pctxt, MBMSBearerServiceType value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case multicast: ui = 0; break;
      case broadcast: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionDuration                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionDuration (ASN1CTXT* pctxt, MBMSSessionDuration* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(3), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSServiceArea                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSServiceArea (ASN1CTXT* pctxt, MBMSServiceArea value)
{
   int stat = 0;

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FrequenceLayerConvergenceFlag                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_FrequenceLayerConvergenceFlag (ASN1CTXT* pctxt, FrequenceLayerConvergenceFlag value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case no_FLC_flag: ui = 0; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAofIdleModeUEs                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAofIdleModeUEs (ASN1CTXT* pctxt, RAofIdleModeUEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65536), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_RAC (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotEmptyRAListofIdleModeUEs_iE_Extensions_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NotEmptyRAListofIdleModeUEs_iE_Extensions_element (ASN1CTXT* pctxt, NotEmptyRAListofIdleModeUEs_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_NotEmptyRAListofIdleModeUEs_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotEmptyRAListofIdleModeUEs_iE_Extensions_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_NotEmptyRAListofIdleModeUEs_iE_Extensions_element (ASN1CTXT* pctxt,
   NotEmptyRAListofIdleModeUEs_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < NotEmptyRAListofIdleModeUEs_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &NotEmptyRAListofIdleModeUEs_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == NotEmptyRAListofIdleModeUEs_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = NotEmptyRAListofIdleModeUEs_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  NotEmptyRAListofIdleModeUEs_iE_Extensions                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NotEmptyRAListofIdleModeUEs_iE_Extensions (ASN1CTXT* pctxt, NotEmptyRAListofIdleModeUEs_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_NotEmptyRAListofIdleModeUEs_iE_Extensions_element (pctxt, ((NotEmptyRAListofIdleModeUEs_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotEmptyRAListofIdleModeUEs                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NotEmptyRAListofIdleModeUEs (ASN1CTXT* pctxt, NotEmptyRAListofIdleModeUEs* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode rAofIdleModeUEs */

   stat = asn1PE_RAofIdleModeUEs (pctxt, &pvalue->rAofIdleModeUEs);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_NotEmptyRAListofIdleModeUEs_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs (ASN1CTXT* pctxt, RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case emptylist: ui = 0; break;
      case fulllist: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAListofIdleModeUEs                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAListofIdleModeUEs (ASN1CTXT* pctxt, RAListofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSBOOL extbit;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* notEmptyRAListofIdleModeUEs */
         case 1:
            stat = asn1PE_NotEmptyRAListofIdleModeUEs (pctxt, pvalue->u.notEmptyRAListofIdleModeUEs);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         /* emptyFullRAListofIdleModeUEs */
         case 2:
            stat = asn1PE_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs (pctxt, pvalue->u.emptyFullRAListofIdleModeUEs);
            if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSSessionRepetitionNumber                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSSessionRepetitionNumber (ASN1CTXT* pctxt, MBMSSessionRepetitionNumber value)
{
   int stat = 0;

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeToMBMSDataTransfer                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_TimeToMBMSDataTransfer (ASN1CTXT* pctxt, TimeToMBMSDataTransfer* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SessionUpdateID                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_SessionUpdateID (ASN1CTXT* pctxt, SessionUpdateID value)
{
   int stat = 0;

   if ( (value <= 1048575) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(1048575));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }
   else
      return LOG_ASN1ERR (pctxt, ASN_E_CONSVIO);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewRAListofIdleModeUEs                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_NewRAListofIdleModeUEs (ASN1CTXT* pctxt, NewRAListofIdleModeUEs* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65536), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_RAC (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RAListwithNoIdleModeUEsAnyMore                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RAListwithNoIdleModeUEsAnyMore (ASN1CTXT* pctxt, RAListwithNoIdleModeUEsAnyMore* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65536), 0 };
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_RAC (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeltaRAListofIdleModeUEs_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DeltaRAListofIdleModeUEs_iE_Extensions_element (ASN1CTXT* pctxt, DeltaRAListofIdleModeUEs_iE_Extensions_element* pvalue)
{
   int stat = 0;
   ASN1CTXT lctxt;

   /* invoke table constraint function */

   rtCopyContext (&lctxt, pctxt);
   stat = asn1PETC_DeltaRAListofIdleModeUEs_iE_Extensions_element (pctxt, pvalue);
   if (stat != 0) {
      return LOG_ASN1ERR (pctxt, stat);
   }
   rtCopyContext (pctxt, &lctxt);

   /* encode id */

   stat = asn1PE_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode criticality */

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode extensionValue */

   stat = pe_OpenType (pctxt, pvalue->extensionValue.encoded.numocts, pvalue->extensionValue.encoded.data);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* free dynamic encode buffer */

   rtFreeContext (&lctxt);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeltaRAListofIdleModeUEs_iE_Extensions_element            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PETC_DeltaRAListofIdleModeUEs_iE_Extensions_element (ASN1CTXT* pctxt,
   DeltaRAListofIdleModeUEs_iE_Extensions_element *pvalue)
{
   int stat = 0;
   int index = -1;

   /* check id */
   for(index = 0; index < DeltaRAListofIdleModeUEs_ExtIEs_Size; index++) {
      if(rtCmpTCUSINT(&pvalue->id, &DeltaRAListofIdleModeUEs_ExtIEs[index].id) == 0) {
         break;
      }
   }
   if(index == DeltaRAListofIdleModeUEs_ExtIEs_Size) return 0;

   /* check extensionValue */
   stat = rtInitContextBuffer (pctxt, 0, 0);
   if(stat != 0) return LOG_ASN1ERR (pctxt, stat);
   stat = DeltaRAListofIdleModeUEs_ExtIEs[index].encodeExtension(pctxt, pvalue->extensionValue.decoded );
   if( stat < 0) return LOG_ASN1ERR (pctxt, stat);
   pvalue->extensionValue.encoded.numocts = (OSUINT32)pe_GetMsgLen (pctxt);
   pvalue->extensionValue.encoded.data = pctxt->buffer.data;

   /* use -strict option to validate the "criticality" element */

   return stat;
}

/**************************************************************/
/*                                                            */
/*  DeltaRAListofIdleModeUEs_iE_Extensions                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DeltaRAListofIdleModeUEs_iE_Extensions (ASN1CTXT* pctxt, DeltaRAListofIdleModeUEs_iE_Extensions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(65535), 0 };
   int stat = 0;
   Asn1RTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_DeltaRAListofIdleModeUEs_iE_Extensions_element (pctxt, ((DeltaRAListofIdleModeUEs_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
      pnode = pnode->next;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeltaRAListofIdleModeUEs                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_DeltaRAListofIdleModeUEs (ASN1CTXT* pctxt, DeltaRAListofIdleModeUEs* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.newRAListofIdleModeUEsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.rAListwithNoIdleModeUEsAnyMorePresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   /* encode newRAListofIdleModeUEs */

   if (pvalue->m.newRAListofIdleModeUEsPresent) {
      stat = asn1PE_NewRAListofIdleModeUEs (pctxt, &pvalue->newRAListofIdleModeUEs);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode rAListwithNoIdleModeUEsAnyMore */

   if (pvalue->m.rAListwithNoIdleModeUEsAnyMorePresent) {
      stat = asn1PE_RAListwithNoIdleModeUEsAnyMore (pctxt, &pvalue->rAListwithNoIdleModeUEsAnyMore);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_DeltaRAListofIdleModeUEs_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSCNDe_Registration                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSCNDe_Registration (ASN1CTXT* pctxt, MBMSCNDe_Registration value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case normalsessionstop: ui = 0; break;
      case deregister: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MBMSRegistrationRequestType                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_MBMSRegistrationRequestType (ASN1CTXT* pctxt, MBMSRegistrationRequestType value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit;

   extbit = 0;

   switch (value) {
      case register_: ui = 0; break;
      case deregister_1: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RateControlAllowed                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PE_RateControlAllowed (ASN1CTXT* pctxt, RateControlAllowed value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case not_allowed: ui = 0; break;
      case allowed: ui = 1; break;
      default: rtErrAddIntParm (&pctxt->errInfo, value);
      return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

