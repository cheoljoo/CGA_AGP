Mission 1 : ASPICE traceability
- How to design aspice traceability
  Need a SIMPLE Design (we can start from DRAFT)
- how to connect the link between SRS SAD LLD
- How to make a apsice table from which annotation


*2 Stage for Mission 1

* First Stage for Mission 1
First ,Expand ignoring the following Rules

* Second Stage for Mission 1
Second , Make the hash variables with FILE-LINES
Rule_of_Number :   Number or AUTO
Value : SyAD-ModuleA-ModuleB-0001
  key : UNIQUE_NAME
  key : SyAD-ModuleA-ModuleB-0001
  key : SyAD-UNIQUE_NAME
  key : SyAD-ModuleA-ModuleB-UNIQUE_NAME
  STEP : SAD / HLD / LLD / TC
  Declaration -> @ASPICE:STEP:MODULE_NAMES:Rule_of_Number:UNIQUE_NAME:Description@
	We can use the different two names. UNIQUE_NAME or MODULE_NAMES+Number.
	But , if Number is set automatically  , we can not use as ID.
  Declaration -> @ASPICE:STEP:MODULE_NAMES:NUMBER:UNIQUE_NAME:Description@
      $wholeUniqueID{UNIQUE_NAME} = STEP-MODULE_NAMES-NUMBER,...,...,...
      $uniqueID{UNIQUE_NAME} = STEP-MODULE_NAMES-NUMBER
      $wholeUniqueID{STEP-UNIQUE_NAME} = STEP-MODULE_NAMES-NUMBER,...,...,...
      $uniqueID{STEP-UNIQUE_NAME} = STEP-MODULE_NAMES-NUMBER
      $wholeUniqueID{STEP-MODULE_NAMES-UNIQUE_NAME} = STEP-MODULE_NAMES-NUMBER,...,...,...
      $uniqueID{STEP-MODULE_NAMES-UNIQUE_NAME} = STEP-MODULE_NAMES-NUMBER
      $wholeUniqueID{STEP-MODULE_NAMES-NUMBER} = STEP-MODULE_NAMES-NUMBER,...,...,...
      $uniqueID{STEP-MODULE_NAMES-NUMBER} = STEP-MODULE_NAMES-NUMBER
      $uniqueFile{STEP-MODULE_NAMES-NUMBER} = filename
      $uniqueLine{STEP-MODULE_NAMES-NUMBER} = line#
  Upper Link -> @ASPICE:UPLINK:uniqueID:Description@
	uniqueID => Unique name of combination
  UnitTest -> @ASPICE:TC:CASE:uniqueID:Description@
	uniqueID => Unique name of combination

Have a index or tag for each startUML! Automatically!


*Exmaple :
  SAD : protocol
	@ASPICE:UPLINK:SyAD:description@    @ASPICE:UPLINK:SyAD:description@    --+ should combine to one line.
	@ASPICE:SAD:VIF:AUTO:VIF_PROTOCOL:(description) VIF protocol@           --+
	if I want to describe some detailed information , how to do it?
  HLD : parser and Structure
	@ASPICE:UPLINK:VIF_PROTOCOL@
	@ASPICE:HLD:VIF-STRUCT:AUTO:each structure name:VIF structrue - structure name@
	@ASPICE:UPLINK:VIF_PROTOCOL@
	@ASPICE:HLD:VIF-PARSER:NUMBER:HLDeach parser level:VIF parser level #@
  LLD : each function
	@ASPICE:UPLINK:VIF_PROTOCOL@
	@ASPICE:LLD:VIF-PARSER:NUMBER:LLDeach parser level:VIF parser level #@
  TC and explanation for public function
	@ASPICE:TC:CASE:VIF-PARSER-Number:description@
  UnitTest Table and Result Table


Mission 2 : Merge all branches' technology into master
- Merge the log txt
	- UNITTEST & DOXYGEN -> master
	- LIB_pm includeing DIAG -> master
keep the status of example directory on master git


 ------------------------

New Branch : DOXYGEN (doxygen including plantUML  and  prepare the init for ASPICE )
Mission 1 : ASPICE
- Comments as doxygen for each function (Done)
  Done : add doxygen comments in parser.c ut.c
- Requirement (I do not know how to do.)
  I will explain why I make it.
  @CGA_SyRS Need the protocol between AP and MICOM
  @CGA_SRS   How to match without any fixed number. I wanna make the number automatically.
	- @[SRS_DEFINE_PROTOCOL]@ define protocol
	- @[SRS_PARSER]@ make a parse function
- SAD  (Done)
  What is needed for that
  How to design
	@CGA_SAD I will use UML or flow chart what it is.
	SAD : software architecture design
	parser.aspice.SAD
- SDD/LLD with flow chart / state diagram / progress (Done)
	make the flow  diagram of parser code with platntUML
	(This is LLD)
	@CGA_SDD I will explain what each function does.
	SDD : software detailed design
	each function has tag (down direction) and the will have another link for uplink.


 ------------------------

UnitTest Automation
- m.pl : add unittest variable
  name : %gStructUnitTest
- default.stc
  #pragma pack(1)  <- for processing netowrk protocol
  add TestCase Function : ut.c

  [TestCase Run Result]
0 __START_BYTES__MSG_ODI__SEQ_NUMBER__ODI_MSG_DYN_DATA__FuClass_ID__DataID__DataType__InvalidData__DataValue success RET : 0
0 __START_BYTES__MSG_ODI__SEQ_NUMBER__ODI_MSG_DYN_DATA__FuClass_ID__DataID__DataType__InvalidData__DataValue fail RET : -1
0 __START_BYTES__MSG_ODI__SEQ_NUMBER__ODI_MSG_DYN_DATA__FuClass_ID__DataID__DataType__InvalidData__DataValue fail RET : -1
0 __START_BYTES__MSG_ODI__SEQ_NUMBER__ODI_MSG_DYN_DATA__FuClass_ID__DataID__DataType__InvalidData__DataValue fail RET : -1
0 __START_BYTES__MSG_ODI__SEQ_NUMBER__ODI_MSG_DYN_DATA__FuClass_ID__DataID__DataType__InvalidData__DataValue fail RET : -1
0 __START_BYTES__MSG_ODI__SEQ_NUMBER__ODI_MSG_DYN_DATA__FuClass_ID__DataID__DataType__InvalidData__DataValue fail RET : -1
0 __START_BYTES__MSG_ODI__SEQ_NUMBER__ODI_MSG_DYN_DATA__FuClass_ID__DataID__DataType__InvalidData__DataValue fail RET : -1
1 __START_BYTES__MSG_ODI__SEQ_NUMBER__ODI_MSG_INDICATION__FuClass_ID__DataID__DataValue success RET : 1
1 __START_BYTES__MSG_ODI__SEQ_NUMBER__ODI_MSG_INDICATION__FuClass_ID__DataID__DataValue fail RET : -1
1 __START_BYTES__MSG_ODI__SEQ_NUMBER__ODI_MSG_INDICATION__FuClass_ID__DataID__DataValue fail RET : -1
1 __START_BYTES__MSG_ODI__SEQ_NUMBER__ODI_MSG_INDICATION__FuClass_ID__DataID__DataValue fail RET : -1
1 __START_BYTES__MSG_ODI__SEQ_NUMBER__ODI_MSG_INDICATION__FuClass_ID__DataID__DataValue fail RET : -1
1 __START_BYTES__MSG_ODI__SEQ_NUMBER__ODI_MSG_INDICATION__FuClass_ID__DataID__DataValue fail RET : -1
2 __START_BYTES__MSG_ODI__SEQ_NUMBER__ODI_MSG_PRNDL_MSG__NEW_VALUE success RET : 2
2 __START_BYTES__MSG_ODI__SEQ_NUMBER__ODI_MSG_PRNDL_MSG__NEW_VALUE fail RET : -1
2 __START_BYTES__MSG_ODI__SEQ_NUMBER__ODI_MSG_PRNDL_MSG__NEW_VALUE fail RET : -1
2 __START_BYTES__MSG_ODI__SEQ_NUMBER__ODI_MSG_PRNDL_MSG__NEW_VALUE fail RET : -1
2 __START_BYTES__MSG_ODI__SEQ_NUMBER__ODI_MSG_PRNDL_MSG__NEW_VALUE fail RET : -1
3 __START_BYTES__MSG_ODI_RETRY__SEQ_NUMBER__ODI_MSG_DYN_DATA__FuClass_ID__DataID__DataType__InvalidData__DataValue success RET : 3
3 __START_BYTES__MSG_ODI_RETRY__SEQ_NUMBER__ODI_MSG_DYN_DATA__FuClass_ID__DataID__DataType__InvalidData__DataValue fail RET : -1
3 __START_BYTES__MSG_ODI_RETRY__SEQ_NUMBER__ODI_MSG_DYN_DATA__FuClass_ID__DataID__DataType__InvalidData__DataValue fail RET : -1
3 __START_BYTES__MSG_ODI_RETRY__SEQ_NUMBER__ODI_MSG_DYN_DATA__FuClass_ID__DataID__DataType__InvalidData__DataValue fail RET : -1
3 __START_BYTES__MSG_ODI_RETRY__SEQ_NUMBER__ODI_MSG_DYN_DATA__FuClass_ID__DataID__DataType__InvalidData__DataValue fail RET : -1
3 __START_BYTES__MSG_ODI_RETRY__SEQ_NUMBER__ODI_MSG_DYN_DATA__FuClass_ID__DataID__DataType__InvalidData__DataValue fail RET : -1
3 __START_BYTES__MSG_ODI_RETRY__SEQ_NUMBER__ODI_MSG_DYN_DATA__FuClass_ID__DataID__DataType__InvalidData__DataValue fail RET : -1
4 __START_BYTES__MSG_ODI_RETRY__SEQ_NUMBER__ODI_MSG_INDICATION__FuClass_ID__DataID__DataValue success RET : 4
4 __START_BYTES__MSG_ODI_RETRY__SEQ_NUMBER__ODI_MSG_INDICATION__FuClass_ID__DataID__DataValue fail RET : -1
4 __START_BYTES__MSG_ODI_RETRY__SEQ_NUMBER__ODI_MSG_INDICATION__FuClass_ID__DataID__DataValue fail RET : -1
4 __START_BYTES__MSG_ODI_RETRY__SEQ_NUMBER__ODI_MSG_INDICATION__FuClass_ID__DataID__DataValue fail RET : -1
4 __START_BYTES__MSG_ODI_RETRY__SEQ_NUMBER__ODI_MSG_INDICATION__FuClass_ID__DataID__DataValue fail RET : -1
4 __START_BYTES__MSG_ODI_RETRY__SEQ_NUMBER__ODI_MSG_INDICATION__FuClass_ID__DataID__DataValue fail RET : -1
5 __START_BYTES__MSG_ODI_RETRY__SEQ_NUMBER__ODI_MSG_PRNDL_MSG__NEW_VALUE success RET : 5
5 __START_BYTES__MSG_ODI_RETRY__SEQ_NUMBER__ODI_MSG_PRNDL_MSG__NEW_VALUE fail RET : -1
5 __START_BYTES__MSG_ODI_RETRY__SEQ_NUMBER__ODI_MSG_PRNDL_MSG__NEW_VALUE fail RET : -1
5 __START_BYTES__MSG_ODI_RETRY__SEQ_NUMBER__ODI_MSG_PRNDL_MSG__NEW_VALUE fail RET : -1
5 __START_BYTES__MSG_ODI_RETRY__SEQ_NUMBER__ODI_MSG_PRNDL_MSG__NEW_VALUE fail RET : -1
6 __START_BYTES__MSG_CONTROL__SUB_COMMAND__SIZE_OF_PAYLOAD__Data success RET : 6
6 __START_BYTES__MSG_CONTROL__SUB_COMMAND__SIZE_OF_PAYLOAD__Data fail RET : -1
6 __START_BYTES__MSG_CONTROL__SUB_COMMAND__SIZE_OF_PAYLOAD__Data fail RET : -1
7 __START_BYTES__MSG_ASK_STATUS__SUB_COMMAND__SIZE_OF_PAYLOAD__Data success RET : 7
7 __START_BYTES__MSG_ASK_STATUS__SUB_COMMAND__SIZE_OF_PAYLOAD__Data fail RET : -1
7 __START_BYTES__MSG_ASK_STATUS__SUB_COMMAND__SIZE_OF_PAYLOAD__Data fail RET : -1
8 __START_BYTES__MSG_ENG__SUB_COMMAND__SIZE_OF_PAYLOAD__Data success RET : 8
8 __START_BYTES__MSG_ENG__SUB_COMMAND__SIZE_OF_PAYLOAD__Data fail RET : -1
8 __START_BYTES__MSG_ENG__SUB_COMMAND__SIZE_OF_PAYLOAD__Data fail RET : -1
9 __START_BYTES__MSG_VP_DEBUG__SUB_COMMAND__SIZE_OF_PAYLOAD__WORD__SINGLE__Data success RET : 9
9 __START_BYTES__MSG_VP_DEBUG__SUB_COMMAND__SIZE_OF_PAYLOAD__WORD__SINGLE__Data fail RET : -1
9 __START_BYTES__MSG_VP_DEBUG__SUB_COMMAND__SIZE_OF_PAYLOAD__WORD__SINGLE__Data fail RET : -1
9 __START_BYTES__MSG_VP_DEBUG__SUB_COMMAND__SIZE_OF_PAYLOAD__WORD__SINGLE__Data fail RET : -1
9 __START_BYTES__MSG_VP_DEBUG__SUB_COMMAND__SIZE_OF_PAYLOAD__WORD__SINGLE__Data fail RET : -1
10 __START_BYTES__MSG_DIAG__SUB_COMMAND__SIZE_OF_PAYLOAD__SINGLE__WORD__Data success RET : 10
10 __START_BYTES__MSG_DIAG__SUB_COMMAND__SIZE_OF_PAYLOAD__SINGLE__WORD__Data fail RET : -1
10 __START_BYTES__MSG_DIAG__SUB_COMMAND__SIZE_OF_PAYLOAD__SINGLE__WORD__Data fail RET : -1
10 __START_BYTES__MSG_DIAG__SUB_COMMAND__SIZE_OF_PAYLOAD__SINGLE__WORD__Data fail RET : -1
10 __START_BYTES__MSG_DIAG__SUB_COMMAND__SIZE_OF_PAYLOAD__SINGLE__WORD__Data fail RET : -1


-------------------------

Documents [NEXT]
	. Comments as doxygen for each function
	. ASPICE traceability
	. SDD/LLD with flow chart / state diagram / progress
- Unit test (gtest & vectorCast) 
- Study : Design Pattern , C++ , perlre(ING)

-------------------------

Example : MEM_CPU_LOG
- Draw the chart to check the memory and cpu usage
- It will check every day what is the problem.:q

-------------------------

[Parser Done] : parser.c

make the stc file for html and header file
-header file includes structures autogenerated.
-html file includes the stc format to show the final table.

compiler processes
DONE : front end  (define the syntax and parsing) -> a.pl
DONE : optimizer ( make the added variables) -> m.pl
DONE : back end for STC    -> r.pl

Action Items : input for back end with stc file format
 - structure  (Done)
 - html table  (Done)
 - add + (max_keys) in ITERATE (Done)
 - add array in ITERATE (Done)
 - Optimizer (Done) **
 - Parser (Done) : result - parser.c
	. m.pl will be changed to make parser
			$gCol{0}{0}{"Define"}="START_BYTES"
			$gCol{0}{0}{"Description"}="(Header - Start Bytes)"
			$gCol{0}{0}{"Span"}="10"
			$gCol{0}{0}{"Len"}="1"
			$gCol{0}{0}{"Comments"}=""
			$gCol{0}{0}{"Value"}="0xAA"
		$gCol{1}{0}{"ParserSiblingX"}="prior X index of satisfying the following condition (span > 0)"
		$gCol{1}{0}{"ParserSiblingY"}="prior Y index of satisfying the following condition (len > 0)"
		$gCol{1}{0}{"ParserParentX"}="Parent X Index of Y-1";
		$gCol{1}{0}{"ParserParentY"}="Parent X Index of Y-1";
		$gCol{2}{2}{"LongDefine"}="longname..."
		logname will be defined with special value!
		$ParserCol{2}{1}{"Parent"} = 0 (index of X-structure)
		$ParserRow{1}{2}{"Parent"} = 0 (index of X-structure)
	. Next will have Next code
		funciton for tracing backward of Y ( input : Current LongDefine # ,  Value )
			function name :
			inner call :
			case  
				elsif before status(parent status) + current value;
				elsif 
		bytes [Len:Span:ParserParentX:ParserParentY]
		Byte[_____ 0____] [_____ 1____] [_____ 2____] [_____ 3____] [_____ 4____] [_____ 5____] [_____ 6____] [_____ 7____] [_____ 8____] [_____ 9____] [_____10____] 
		0 [ 1:11: 0: 0] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] 
		0       0xAA                                                                                                                                                
		1 [ 1: 3: 0: 0] [__:__:__:__] [__:__:__:__] [ 1: 3: 0: 0] [__:__:__:__] [__:__:__:__] [ 1: 1: 0: 0] [ 1: 1: 0: 0] [ 1: 1: 0: 0] [ 1: 1: 0: 0] [ 1: 1: 0: 0] 
		1       0x84                                      0x88                                      0x81          0x82          0x85          0x86          0x87    
		if else :
			parent status(0)+0x84 => LongDefine      parent status(0)+0x88 => LongDefine  ..........
		call :
			call_level_3(LongDefine of 1 , next pointer);
		2 [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] 
		2                                                                                                                                                           
		3 [ 2: 1: 0: 1] [ 2: 1: 0: 1] [ 2: 1: 0: 1] [ 2: 1: 3: 1] [ 2: 1: 3: 1] [ 2: 1: 3: 1] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] 
		3     0x0A03        0x0F02        0x01EE        0x0A03        0x0F02        0x01EE                                                                          
										if OK => return Final Structure #
		4 [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] 
		4                                                                                                                                                           
		5 [ 2: 1: 0: 3] [ 2: 1: 1: 3] [__:__:__:__] [ 2: 1: 3: 3] [ 2: 1: 4: 3] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] [__:__:__:__] 
		5       0x03        0x3303                        0x03        0x3303                                                                                        

(Done)
- Add function : various hash type (+V%  : hash value ascending sort)
ITERATE  [+-]?[KV]?[%@&+]
 K : key sort , V : value sort (only hash %)
 [KV] : K is default
 [+-] : + is default
 % : hash
 @ : array
 & : reverse array
 + : 0 ~ max key 
	default : K(key sort) , +(ascending order)
	%&@+
	K or V or nothing : default K   (K :key , V : value)
	+ or - or nothing : default +
	

 - Documents (NEXT)
	. Comments as doxygen for each function
	. ASPICE traceability
	. SDD/LLD with flow chart / state diagram / progress
 - Unit test (gtest & vectorCast)
 - Study : Design Pattern , C++ , perlre(ING)

ADD EXAMPLES for the following test
	$iterate_lines =~ m/([\t ]*)IFEQUAL\s*([^\n#\/]*)\s*\/\#/;       IFEQUAL|IFNOTEQUAL ( () && ||  ) /#
	$iterate_lines =~ m/((?:\/\#(?:[^#]|(?:\#+[^#\/]))*\#+\/))/;     /#   #/
	my @pp = $a =~ s/((?:\/\*(?:[^*]|(?:\*+[^*\/]))*\*+\/)|(?:\/\/.*))//g;    /*   */
	if($a =~ /(\{([^\{\}]|(?R))*\})/)            { {} {} }

	(?=pattern)
		is a positive look-ahead assertion
	(?!pattern)
		is a negative look-ahead assertion
	(?<=pattern)
		is a positive look-behind assertion
	(?<!pattern)
		is a negative look-behind assertion

	https://docstore.mik.ua/orelly/perl3/lperl/ch09_05.htm
	$.    : matched line
	$`
	$&
	$'
	($`)($&)($') : This is location for each variables.


Caller
		#  0         1          2      3            4
		my ($package, $filename, $line, $subroutine, $hasargs,
		    #  5          6          7            8       9         10
		    $wantarray, $evaltext, $is_require, $hints, $bitmask, $hinthash)
		  = caller($i);

