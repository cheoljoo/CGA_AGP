1. LIB.pm
- Each perl module owns their own memory.
  So , we can set the variables in perl module.
  LoadVarFromFile() has a set function in module.
2.Make a new variables for ITERATE
  When we want to change the order of elements , we should generate new variables.
  So I add special function in existed code.  Function LIB->traverse_hash_tree(\%{DIAG},DIAG,"default.GVm",NEW,FUNC,SUBCMD);
- LIB->traverse_hash_tree(\%{DIAG},DIAG,"default.GVm",NEW,FUNC,SUBCMD);
  LIB->traverse_hash_tree : function name
  (
   \%{DIAG} : hashname for output variable
   ,DIAG : variable name for output variable
   ,"default.GVm" : output file name 
   ,NEW : create a new output file name
   ,FUNC,SUBCMD);  : get these variables as array
	 create many variables according to input.
	 FUNC -> create  %DIAG_FUNC
	    $DIAG{0}{function_name}{op}=value   >>  $DIAG_FUNC{function_name}{0}{op}=value
	 SUBCMD -> create  %DIAG_SUBCMD
	    $DIAG{0}{function_name}{op}=value   >>  $DIAG_SUBCMD{op}{function_name}{0}}=value
  This method is not circular but swapable between two indexs. (If you need circular method , let me know.)  cheoljoo@gmail.com  (Charles)

---------------
1. Perl Module : LIB.pm a.pl 
	- Call sub routine has the special first argument with LIB name.)
	- LIB.pm has the check routine for debugging in argument receiving statements.
2. Example : DIAG  (for byun)
- default.def : input file of a.pl
- a.pl : parsing of default.def
- default.stc : code template

Run : 
- perl a.pl
  default input file : default.def -> byun's suggest file : function lists
  default output file : default.GVm   ->   collection of hash values
- perl r.pl 
  default input file 1 : default.GVm  -> So First you can run a.pl.
  default input file 2 : default.stc -> This is a template file.
  output file : OUTPUT/stc/Filename in default.stc
    ex) OUTPUT/stc/diag.c
			define each function
			define parse function


-default.def
Time_information:   0x04 :   read, write:     uint16_t : uint8_t
